
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Issuer
 * 
 */
export type Issuer = $Result.DefaultSelection<Prisma.$IssuerPayload>
/**
 * Model Merchant
 * 
 */
export type Merchant = $Result.DefaultSelection<Prisma.$MerchantPayload>
/**
 * Model MerchantTerminal
 * 
 */
export type MerchantTerminal = $Result.DefaultSelection<Prisma.$MerchantTerminalPayload>
/**
 * Model VCreditDefinition
 * 
 */
export type VCreditDefinition = $Result.DefaultSelection<Prisma.$VCreditDefinitionPayload>
/**
 * Model LiquidityPool
 * 
 */
export type LiquidityPool = $Result.DefaultSelection<Prisma.$LiquidityPoolPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model Balance
 * 
 */
export type Balance = $Result.DefaultSelection<Prisma.$BalancePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model LedgerEntry
 * 
 */
export type LedgerEntry = $Result.DefaultSelection<Prisma.$LedgerEntryPayload>
/**
 * Model Policy
 * 
 */
export type Policy = $Result.DefaultSelection<Prisma.$PolicyPayload>
/**
 * Model PolicyEvaluationLog
 * 
 */
export type PolicyEvaluationLog = $Result.DefaultSelection<Prisma.$PolicyEvaluationLogPayload>
/**
 * Model ComplianceAttestation
 * 
 */
export type ComplianceAttestation = $Result.DefaultSelection<Prisma.$ComplianceAttestationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.issuer`: Exposes CRUD operations for the **Issuer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Issuers
    * const issuers = await prisma.issuer.findMany()
    * ```
    */
  get issuer(): Prisma.IssuerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merchant`: Exposes CRUD operations for the **Merchant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Merchants
    * const merchants = await prisma.merchant.findMany()
    * ```
    */
  get merchant(): Prisma.MerchantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merchantTerminal`: Exposes CRUD operations for the **MerchantTerminal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MerchantTerminals
    * const merchantTerminals = await prisma.merchantTerminal.findMany()
    * ```
    */
  get merchantTerminal(): Prisma.MerchantTerminalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vCreditDefinition`: Exposes CRUD operations for the **VCreditDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VCreditDefinitions
    * const vCreditDefinitions = await prisma.vCreditDefinition.findMany()
    * ```
    */
  get vCreditDefinition(): Prisma.VCreditDefinitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.liquidityPool`: Exposes CRUD operations for the **LiquidityPool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiquidityPools
    * const liquidityPools = await prisma.liquidityPool.findMany()
    * ```
    */
  get liquidityPool(): Prisma.LiquidityPoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.balance`: Exposes CRUD operations for the **Balance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balances
    * const balances = await prisma.balance.findMany()
    * ```
    */
  get balance(): Prisma.BalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ledgerEntry`: Exposes CRUD operations for the **LedgerEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LedgerEntries
    * const ledgerEntries = await prisma.ledgerEntry.findMany()
    * ```
    */
  get ledgerEntry(): Prisma.LedgerEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.policy`: Exposes CRUD operations for the **Policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policies
    * const policies = await prisma.policy.findMany()
    * ```
    */
  get policy(): Prisma.PolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.policyEvaluationLog`: Exposes CRUD operations for the **PolicyEvaluationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PolicyEvaluationLogs
    * const policyEvaluationLogs = await prisma.policyEvaluationLog.findMany()
    * ```
    */
  get policyEvaluationLog(): Prisma.PolicyEvaluationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complianceAttestation`: Exposes CRUD operations for the **ComplianceAttestation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplianceAttestations
    * const complianceAttestations = await prisma.complianceAttestation.findMany()
    * ```
    */
  get complianceAttestation(): Prisma.ComplianceAttestationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Issuer: 'Issuer',
    Merchant: 'Merchant',
    MerchantTerminal: 'MerchantTerminal',
    VCreditDefinition: 'VCreditDefinition',
    LiquidityPool: 'LiquidityPool',
    Wallet: 'Wallet',
    Balance: 'Balance',
    Transaction: 'Transaction',
    LedgerEntry: 'LedgerEntry',
    Policy: 'Policy',
    PolicyEvaluationLog: 'PolicyEvaluationLog',
    ComplianceAttestation: 'ComplianceAttestation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "issuer" | "merchant" | "merchantTerminal" | "vCreditDefinition" | "liquidityPool" | "wallet" | "balance" | "transaction" | "ledgerEntry" | "policy" | "policyEvaluationLog" | "complianceAttestation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Issuer: {
        payload: Prisma.$IssuerPayload<ExtArgs>
        fields: Prisma.IssuerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IssuerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IssuerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuerPayload>
          }
          findFirst: {
            args: Prisma.IssuerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IssuerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuerPayload>
          }
          findMany: {
            args: Prisma.IssuerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuerPayload>[]
          }
          create: {
            args: Prisma.IssuerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuerPayload>
          }
          createMany: {
            args: Prisma.IssuerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IssuerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuerPayload>[]
          }
          delete: {
            args: Prisma.IssuerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuerPayload>
          }
          update: {
            args: Prisma.IssuerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuerPayload>
          }
          deleteMany: {
            args: Prisma.IssuerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IssuerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IssuerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuerPayload>[]
          }
          upsert: {
            args: Prisma.IssuerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuerPayload>
          }
          aggregate: {
            args: Prisma.IssuerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIssuer>
          }
          groupBy: {
            args: Prisma.IssuerGroupByArgs<ExtArgs>
            result: $Utils.Optional<IssuerGroupByOutputType>[]
          }
          count: {
            args: Prisma.IssuerCountArgs<ExtArgs>
            result: $Utils.Optional<IssuerCountAggregateOutputType> | number
          }
        }
      }
      Merchant: {
        payload: Prisma.$MerchantPayload<ExtArgs>
        fields: Prisma.MerchantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MerchantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MerchantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          findFirst: {
            args: Prisma.MerchantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MerchantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          findMany: {
            args: Prisma.MerchantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          create: {
            args: Prisma.MerchantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          createMany: {
            args: Prisma.MerchantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MerchantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          delete: {
            args: Prisma.MerchantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          update: {
            args: Prisma.MerchantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          deleteMany: {
            args: Prisma.MerchantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MerchantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MerchantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>[]
          }
          upsert: {
            args: Prisma.MerchantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantPayload>
          }
          aggregate: {
            args: Prisma.MerchantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchant>
          }
          groupBy: {
            args: Prisma.MerchantGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantGroupByOutputType>[]
          }
          count: {
            args: Prisma.MerchantCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantCountAggregateOutputType> | number
          }
        }
      }
      MerchantTerminal: {
        payload: Prisma.$MerchantTerminalPayload<ExtArgs>
        fields: Prisma.MerchantTerminalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MerchantTerminalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantTerminalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MerchantTerminalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantTerminalPayload>
          }
          findFirst: {
            args: Prisma.MerchantTerminalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantTerminalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MerchantTerminalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantTerminalPayload>
          }
          findMany: {
            args: Prisma.MerchantTerminalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantTerminalPayload>[]
          }
          create: {
            args: Prisma.MerchantTerminalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantTerminalPayload>
          }
          createMany: {
            args: Prisma.MerchantTerminalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MerchantTerminalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantTerminalPayload>[]
          }
          delete: {
            args: Prisma.MerchantTerminalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantTerminalPayload>
          }
          update: {
            args: Prisma.MerchantTerminalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantTerminalPayload>
          }
          deleteMany: {
            args: Prisma.MerchantTerminalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MerchantTerminalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MerchantTerminalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantTerminalPayload>[]
          }
          upsert: {
            args: Prisma.MerchantTerminalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MerchantTerminalPayload>
          }
          aggregate: {
            args: Prisma.MerchantTerminalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchantTerminal>
          }
          groupBy: {
            args: Prisma.MerchantTerminalGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantTerminalGroupByOutputType>[]
          }
          count: {
            args: Prisma.MerchantTerminalCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantTerminalCountAggregateOutputType> | number
          }
        }
      }
      VCreditDefinition: {
        payload: Prisma.$VCreditDefinitionPayload<ExtArgs>
        fields: Prisma.VCreditDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VCreditDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VCreditDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VCreditDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VCreditDefinitionPayload>
          }
          findFirst: {
            args: Prisma.VCreditDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VCreditDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VCreditDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VCreditDefinitionPayload>
          }
          findMany: {
            args: Prisma.VCreditDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VCreditDefinitionPayload>[]
          }
          create: {
            args: Prisma.VCreditDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VCreditDefinitionPayload>
          }
          createMany: {
            args: Prisma.VCreditDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VCreditDefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VCreditDefinitionPayload>[]
          }
          delete: {
            args: Prisma.VCreditDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VCreditDefinitionPayload>
          }
          update: {
            args: Prisma.VCreditDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VCreditDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.VCreditDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VCreditDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VCreditDefinitionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VCreditDefinitionPayload>[]
          }
          upsert: {
            args: Prisma.VCreditDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VCreditDefinitionPayload>
          }
          aggregate: {
            args: Prisma.VCreditDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVCreditDefinition>
          }
          groupBy: {
            args: Prisma.VCreditDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VCreditDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VCreditDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<VCreditDefinitionCountAggregateOutputType> | number
          }
        }
      }
      LiquidityPool: {
        payload: Prisma.$LiquidityPoolPayload<ExtArgs>
        fields: Prisma.LiquidityPoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiquidityPoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidityPoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiquidityPoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidityPoolPayload>
          }
          findFirst: {
            args: Prisma.LiquidityPoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidityPoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiquidityPoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidityPoolPayload>
          }
          findMany: {
            args: Prisma.LiquidityPoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidityPoolPayload>[]
          }
          create: {
            args: Prisma.LiquidityPoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidityPoolPayload>
          }
          createMany: {
            args: Prisma.LiquidityPoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiquidityPoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidityPoolPayload>[]
          }
          delete: {
            args: Prisma.LiquidityPoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidityPoolPayload>
          }
          update: {
            args: Prisma.LiquidityPoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidityPoolPayload>
          }
          deleteMany: {
            args: Prisma.LiquidityPoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiquidityPoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiquidityPoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidityPoolPayload>[]
          }
          upsert: {
            args: Prisma.LiquidityPoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiquidityPoolPayload>
          }
          aggregate: {
            args: Prisma.LiquidityPoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiquidityPool>
          }
          groupBy: {
            args: Prisma.LiquidityPoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiquidityPoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiquidityPoolCountArgs<ExtArgs>
            result: $Utils.Optional<LiquidityPoolCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      Balance: {
        payload: Prisma.$BalancePayload<ExtArgs>
        fields: Prisma.BalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          findFirst: {
            args: Prisma.BalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          findMany: {
            args: Prisma.BalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          create: {
            args: Prisma.BalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          createMany: {
            args: Prisma.BalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          delete: {
            args: Prisma.BalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          update: {
            args: Prisma.BalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          deleteMany: {
            args: Prisma.BalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BalanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          upsert: {
            args: Prisma.BalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          aggregate: {
            args: Prisma.BalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalance>
          }
          groupBy: {
            args: Prisma.BalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BalanceCountArgs<ExtArgs>
            result: $Utils.Optional<BalanceCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      LedgerEntry: {
        payload: Prisma.$LedgerEntryPayload<ExtArgs>
        fields: Prisma.LedgerEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findFirst: {
            args: Prisma.LedgerEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findMany: {
            args: Prisma.LedgerEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          create: {
            args: Prisma.LedgerEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          createMany: {
            args: Prisma.LedgerEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LedgerEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          delete: {
            args: Prisma.LedgerEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          update: {
            args: Prisma.LedgerEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          deleteMany: {
            args: Prisma.LedgerEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LedgerEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          upsert: {
            args: Prisma.LedgerEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          aggregate: {
            args: Prisma.LedgerEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedgerEntry>
          }
          groupBy: {
            args: Prisma.LedgerEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryCountAggregateOutputType> | number
          }
        }
      }
      Policy: {
        payload: Prisma.$PolicyPayload<ExtArgs>
        fields: Prisma.PolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findFirst: {
            args: Prisma.PolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findMany: {
            args: Prisma.PolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          create: {
            args: Prisma.PolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          createMany: {
            args: Prisma.PolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          delete: {
            args: Prisma.PolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          update: {
            args: Prisma.PolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          deleteMany: {
            args: Prisma.PolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          upsert: {
            args: Prisma.PolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          aggregate: {
            args: Prisma.PolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicy>
          }
          groupBy: {
            args: Prisma.PolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyCountAggregateOutputType> | number
          }
        }
      }
      PolicyEvaluationLog: {
        payload: Prisma.$PolicyEvaluationLogPayload<ExtArgs>
        fields: Prisma.PolicyEvaluationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyEvaluationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyEvaluationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyEvaluationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyEvaluationLogPayload>
          }
          findFirst: {
            args: Prisma.PolicyEvaluationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyEvaluationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyEvaluationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyEvaluationLogPayload>
          }
          findMany: {
            args: Prisma.PolicyEvaluationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyEvaluationLogPayload>[]
          }
          create: {
            args: Prisma.PolicyEvaluationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyEvaluationLogPayload>
          }
          createMany: {
            args: Prisma.PolicyEvaluationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolicyEvaluationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyEvaluationLogPayload>[]
          }
          delete: {
            args: Prisma.PolicyEvaluationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyEvaluationLogPayload>
          }
          update: {
            args: Prisma.PolicyEvaluationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyEvaluationLogPayload>
          }
          deleteMany: {
            args: Prisma.PolicyEvaluationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyEvaluationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PolicyEvaluationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyEvaluationLogPayload>[]
          }
          upsert: {
            args: Prisma.PolicyEvaluationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyEvaluationLogPayload>
          }
          aggregate: {
            args: Prisma.PolicyEvaluationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicyEvaluationLog>
          }
          groupBy: {
            args: Prisma.PolicyEvaluationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyEvaluationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyEvaluationLogCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyEvaluationLogCountAggregateOutputType> | number
          }
        }
      }
      ComplianceAttestation: {
        payload: Prisma.$ComplianceAttestationPayload<ExtArgs>
        fields: Prisma.ComplianceAttestationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplianceAttestationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAttestationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplianceAttestationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAttestationPayload>
          }
          findFirst: {
            args: Prisma.ComplianceAttestationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAttestationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplianceAttestationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAttestationPayload>
          }
          findMany: {
            args: Prisma.ComplianceAttestationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAttestationPayload>[]
          }
          create: {
            args: Prisma.ComplianceAttestationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAttestationPayload>
          }
          createMany: {
            args: Prisma.ComplianceAttestationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplianceAttestationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAttestationPayload>[]
          }
          delete: {
            args: Prisma.ComplianceAttestationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAttestationPayload>
          }
          update: {
            args: Prisma.ComplianceAttestationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAttestationPayload>
          }
          deleteMany: {
            args: Prisma.ComplianceAttestationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplianceAttestationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComplianceAttestationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAttestationPayload>[]
          }
          upsert: {
            args: Prisma.ComplianceAttestationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAttestationPayload>
          }
          aggregate: {
            args: Prisma.ComplianceAttestationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplianceAttestation>
          }
          groupBy: {
            args: Prisma.ComplianceAttestationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplianceAttestationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplianceAttestationCountArgs<ExtArgs>
            result: $Utils.Optional<ComplianceAttestationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    issuer?: IssuerOmit
    merchant?: MerchantOmit
    merchantTerminal?: MerchantTerminalOmit
    vCreditDefinition?: VCreditDefinitionOmit
    liquidityPool?: LiquidityPoolOmit
    wallet?: WalletOmit
    balance?: BalanceOmit
    transaction?: TransactionOmit
    ledgerEntry?: LedgerEntryOmit
    policy?: PolicyOmit
    policyEvaluationLog?: PolicyEvaluationLogOmit
    complianceAttestation?: ComplianceAttestationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    wallets: number
    attestations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallets?: boolean | UserCountOutputTypeCountWalletsArgs
    attestations?: boolean | UserCountOutputTypeCountAttestationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWalletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttestationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceAttestationWhereInput
  }


  /**
   * Count Type IssuerCountOutputType
   */

  export type IssuerCountOutputType = {
    users: number
    creditDefs: number
    policies: number
  }

  export type IssuerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | IssuerCountOutputTypeCountUsersArgs
    creditDefs?: boolean | IssuerCountOutputTypeCountCreditDefsArgs
    policies?: boolean | IssuerCountOutputTypeCountPoliciesArgs
  }

  // Custom InputTypes
  /**
   * IssuerCountOutputType without action
   */
  export type IssuerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssuerCountOutputType
     */
    select?: IssuerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IssuerCountOutputType without action
   */
  export type IssuerCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * IssuerCountOutputType without action
   */
  export type IssuerCountOutputTypeCountCreditDefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VCreditDefinitionWhereInput
  }

  /**
   * IssuerCountOutputType without action
   */
  export type IssuerCountOutputTypeCountPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
  }


  /**
   * Count Type MerchantCountOutputType
   */

  export type MerchantCountOutputType = {
    users: number
    terminals: number
  }

  export type MerchantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | MerchantCountOutputTypeCountUsersArgs
    terminals?: boolean | MerchantCountOutputTypeCountTerminalsArgs
  }

  // Custom InputTypes
  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantCountOutputType
     */
    select?: MerchantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * MerchantCountOutputType without action
   */
  export type MerchantCountOutputTypeCountTerminalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantTerminalWhereInput
  }


  /**
   * Count Type VCreditDefinitionCountOutputType
   */

  export type VCreditDefinitionCountOutputType = {
    balances: number
    policies: number
  }

  export type VCreditDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balances?: boolean | VCreditDefinitionCountOutputTypeCountBalancesArgs
    policies?: boolean | VCreditDefinitionCountOutputTypeCountPoliciesArgs
  }

  // Custom InputTypes
  /**
   * VCreditDefinitionCountOutputType without action
   */
  export type VCreditDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinitionCountOutputType
     */
    select?: VCreditDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VCreditDefinitionCountOutputType without action
   */
  export type VCreditDefinitionCountOutputTypeCountBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
  }

  /**
   * VCreditDefinitionCountOutputType without action
   */
  export type VCreditDefinitionCountOutputTypeCountPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
  }


  /**
   * Count Type WalletCountOutputType
   */

  export type WalletCountOutputType = {
    balances: number
    transactions: number
  }

  export type WalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balances?: boolean | WalletCountOutputTypeCountBalancesArgs
    transactions?: boolean | WalletCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    ledgerEntries: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgerEntries?: boolean | TransactionCountOutputTypeCountLedgerEntriesArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }


  /**
   * Count Type PolicyEvaluationLogCountOutputType
   */

  export type PolicyEvaluationLogCountOutputType = {
    transactions: number
  }

  export type PolicyEvaluationLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | PolicyEvaluationLogCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * PolicyEvaluationLogCountOutputType without action
   */
  export type PolicyEvaluationLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLogCountOutputType
     */
    select?: PolicyEvaluationLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PolicyEvaluationLogCountOutputType without action
   */
  export type PolicyEvaluationLogCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    role: string | null
    status: string | null
    issuerId: string | null
    merchantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    role: string | null
    status: string | null
    issuerId: string | null
    merchantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    fullName: number
    role: number
    status: number
    issuerId: number
    merchantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    status?: true
    issuerId?: true
    merchantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    status?: true
    issuerId?: true
    merchantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    status?: true
    issuerId?: true
    merchantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    fullName: string | null
    role: string
    status: string
    issuerId: string | null
    merchantId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    status?: boolean
    issuerId?: boolean
    merchantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    issuer?: boolean | User$issuerArgs<ExtArgs>
    merchant?: boolean | User$merchantArgs<ExtArgs>
    wallets?: boolean | User$walletsArgs<ExtArgs>
    attestations?: boolean | User$attestationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    status?: boolean
    issuerId?: boolean
    merchantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    issuer?: boolean | User$issuerArgs<ExtArgs>
    merchant?: boolean | User$merchantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    status?: boolean
    issuerId?: boolean
    merchantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    issuer?: boolean | User$issuerArgs<ExtArgs>
    merchant?: boolean | User$merchantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    status?: boolean
    issuerId?: boolean
    merchantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "fullName" | "role" | "status" | "issuerId" | "merchantId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | User$issuerArgs<ExtArgs>
    merchant?: boolean | User$merchantArgs<ExtArgs>
    wallets?: boolean | User$walletsArgs<ExtArgs>
    attestations?: boolean | User$attestationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | User$issuerArgs<ExtArgs>
    merchant?: boolean | User$merchantArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | User$issuerArgs<ExtArgs>
    merchant?: boolean | User$merchantArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      issuer: Prisma.$IssuerPayload<ExtArgs> | null
      merchant: Prisma.$MerchantPayload<ExtArgs> | null
      wallets: Prisma.$WalletPayload<ExtArgs>[]
      attestations: Prisma.$ComplianceAttestationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      fullName: string | null
      role: string
      status: string
      issuerId: string | null
      merchantId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    issuer<T extends User$issuerArgs<ExtArgs> = {}>(args?: Subset<T, User$issuerArgs<ExtArgs>>): Prisma__IssuerClient<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    merchant<T extends User$merchantArgs<ExtArgs> = {}>(args?: Subset<T, User$merchantArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    wallets<T extends User$walletsArgs<ExtArgs> = {}>(args?: Subset<T, User$walletsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attestations<T extends User$attestationsArgs<ExtArgs> = {}>(args?: Subset<T, User$attestationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceAttestationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly issuerId: FieldRef<"User", 'String'>
    readonly merchantId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.issuer
   */
  export type User$issuerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssuerInclude<ExtArgs> | null
    where?: IssuerWhereInput
  }

  /**
   * User.merchant
   */
  export type User$merchantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    where?: MerchantWhereInput
  }

  /**
   * User.wallets
   */
  export type User$walletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    cursor?: WalletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * User.attestations
   */
  export type User$attestationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationInclude<ExtArgs> | null
    where?: ComplianceAttestationWhereInput
    orderBy?: ComplianceAttestationOrderByWithRelationInput | ComplianceAttestationOrderByWithRelationInput[]
    cursor?: ComplianceAttestationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceAttestationScalarFieldEnum | ComplianceAttestationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Issuer
   */

  export type AggregateIssuer = {
    _count: IssuerCountAggregateOutputType | null
    _min: IssuerMinAggregateOutputType | null
    _max: IssuerMaxAggregateOutputType | null
  }

  export type IssuerMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    apiKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IssuerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    apiKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IssuerCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    apiKey: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IssuerMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    apiKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IssuerMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    apiKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IssuerCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    apiKey?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IssuerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Issuer to aggregate.
     */
    where?: IssuerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issuers to fetch.
     */
    orderBy?: IssuerOrderByWithRelationInput | IssuerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IssuerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issuers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issuers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Issuers
    **/
    _count?: true | IssuerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IssuerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IssuerMaxAggregateInputType
  }

  export type GetIssuerAggregateType<T extends IssuerAggregateArgs> = {
        [P in keyof T & keyof AggregateIssuer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIssuer[P]>
      : GetScalarType<T[P], AggregateIssuer[P]>
  }




  export type IssuerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssuerWhereInput
    orderBy?: IssuerOrderByWithAggregationInput | IssuerOrderByWithAggregationInput[]
    by: IssuerScalarFieldEnum[] | IssuerScalarFieldEnum
    having?: IssuerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IssuerCountAggregateInputType | true
    _min?: IssuerMinAggregateInputType
    _max?: IssuerMaxAggregateInputType
  }

  export type IssuerGroupByOutputType = {
    id: string
    name: string
    slug: string
    apiKey: string
    createdAt: Date
    updatedAt: Date
    _count: IssuerCountAggregateOutputType | null
    _min: IssuerMinAggregateOutputType | null
    _max: IssuerMaxAggregateOutputType | null
  }

  type GetIssuerGroupByPayload<T extends IssuerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IssuerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IssuerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IssuerGroupByOutputType[P]>
            : GetScalarType<T[P], IssuerGroupByOutputType[P]>
        }
      >
    >


  export type IssuerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    apiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Issuer$usersArgs<ExtArgs>
    creditDefs?: boolean | Issuer$creditDefsArgs<ExtArgs>
    policies?: boolean | Issuer$policiesArgs<ExtArgs>
    _count?: boolean | IssuerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issuer"]>

  export type IssuerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    apiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["issuer"]>

  export type IssuerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    apiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["issuer"]>

  export type IssuerSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    apiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IssuerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "apiKey" | "createdAt" | "updatedAt", ExtArgs["result"]["issuer"]>
  export type IssuerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Issuer$usersArgs<ExtArgs>
    creditDefs?: boolean | Issuer$creditDefsArgs<ExtArgs>
    policies?: boolean | Issuer$policiesArgs<ExtArgs>
    _count?: boolean | IssuerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IssuerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type IssuerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IssuerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Issuer"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      creditDefs: Prisma.$VCreditDefinitionPayload<ExtArgs>[]
      policies: Prisma.$PolicyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      apiKey: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["issuer"]>
    composites: {}
  }

  type IssuerGetPayload<S extends boolean | null | undefined | IssuerDefaultArgs> = $Result.GetResult<Prisma.$IssuerPayload, S>

  type IssuerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IssuerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IssuerCountAggregateInputType | true
    }

  export interface IssuerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Issuer'], meta: { name: 'Issuer' } }
    /**
     * Find zero or one Issuer that matches the filter.
     * @param {IssuerFindUniqueArgs} args - Arguments to find a Issuer
     * @example
     * // Get one Issuer
     * const issuer = await prisma.issuer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IssuerFindUniqueArgs>(args: SelectSubset<T, IssuerFindUniqueArgs<ExtArgs>>): Prisma__IssuerClient<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Issuer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IssuerFindUniqueOrThrowArgs} args - Arguments to find a Issuer
     * @example
     * // Get one Issuer
     * const issuer = await prisma.issuer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IssuerFindUniqueOrThrowArgs>(args: SelectSubset<T, IssuerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IssuerClient<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Issuer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssuerFindFirstArgs} args - Arguments to find a Issuer
     * @example
     * // Get one Issuer
     * const issuer = await prisma.issuer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IssuerFindFirstArgs>(args?: SelectSubset<T, IssuerFindFirstArgs<ExtArgs>>): Prisma__IssuerClient<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Issuer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssuerFindFirstOrThrowArgs} args - Arguments to find a Issuer
     * @example
     * // Get one Issuer
     * const issuer = await prisma.issuer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IssuerFindFirstOrThrowArgs>(args?: SelectSubset<T, IssuerFindFirstOrThrowArgs<ExtArgs>>): Prisma__IssuerClient<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Issuers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssuerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Issuers
     * const issuers = await prisma.issuer.findMany()
     * 
     * // Get first 10 Issuers
     * const issuers = await prisma.issuer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const issuerWithIdOnly = await prisma.issuer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IssuerFindManyArgs>(args?: SelectSubset<T, IssuerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Issuer.
     * @param {IssuerCreateArgs} args - Arguments to create a Issuer.
     * @example
     * // Create one Issuer
     * const Issuer = await prisma.issuer.create({
     *   data: {
     *     // ... data to create a Issuer
     *   }
     * })
     * 
     */
    create<T extends IssuerCreateArgs>(args: SelectSubset<T, IssuerCreateArgs<ExtArgs>>): Prisma__IssuerClient<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Issuers.
     * @param {IssuerCreateManyArgs} args - Arguments to create many Issuers.
     * @example
     * // Create many Issuers
     * const issuer = await prisma.issuer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IssuerCreateManyArgs>(args?: SelectSubset<T, IssuerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Issuers and returns the data saved in the database.
     * @param {IssuerCreateManyAndReturnArgs} args - Arguments to create many Issuers.
     * @example
     * // Create many Issuers
     * const issuer = await prisma.issuer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Issuers and only return the `id`
     * const issuerWithIdOnly = await prisma.issuer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IssuerCreateManyAndReturnArgs>(args?: SelectSubset<T, IssuerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Issuer.
     * @param {IssuerDeleteArgs} args - Arguments to delete one Issuer.
     * @example
     * // Delete one Issuer
     * const Issuer = await prisma.issuer.delete({
     *   where: {
     *     // ... filter to delete one Issuer
     *   }
     * })
     * 
     */
    delete<T extends IssuerDeleteArgs>(args: SelectSubset<T, IssuerDeleteArgs<ExtArgs>>): Prisma__IssuerClient<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Issuer.
     * @param {IssuerUpdateArgs} args - Arguments to update one Issuer.
     * @example
     * // Update one Issuer
     * const issuer = await prisma.issuer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IssuerUpdateArgs>(args: SelectSubset<T, IssuerUpdateArgs<ExtArgs>>): Prisma__IssuerClient<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Issuers.
     * @param {IssuerDeleteManyArgs} args - Arguments to filter Issuers to delete.
     * @example
     * // Delete a few Issuers
     * const { count } = await prisma.issuer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IssuerDeleteManyArgs>(args?: SelectSubset<T, IssuerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Issuers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssuerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Issuers
     * const issuer = await prisma.issuer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IssuerUpdateManyArgs>(args: SelectSubset<T, IssuerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Issuers and returns the data updated in the database.
     * @param {IssuerUpdateManyAndReturnArgs} args - Arguments to update many Issuers.
     * @example
     * // Update many Issuers
     * const issuer = await prisma.issuer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Issuers and only return the `id`
     * const issuerWithIdOnly = await prisma.issuer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IssuerUpdateManyAndReturnArgs>(args: SelectSubset<T, IssuerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Issuer.
     * @param {IssuerUpsertArgs} args - Arguments to update or create a Issuer.
     * @example
     * // Update or create a Issuer
     * const issuer = await prisma.issuer.upsert({
     *   create: {
     *     // ... data to create a Issuer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Issuer we want to update
     *   }
     * })
     */
    upsert<T extends IssuerUpsertArgs>(args: SelectSubset<T, IssuerUpsertArgs<ExtArgs>>): Prisma__IssuerClient<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Issuers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssuerCountArgs} args - Arguments to filter Issuers to count.
     * @example
     * // Count the number of Issuers
     * const count = await prisma.issuer.count({
     *   where: {
     *     // ... the filter for the Issuers we want to count
     *   }
     * })
    **/
    count<T extends IssuerCountArgs>(
      args?: Subset<T, IssuerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IssuerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Issuer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssuerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IssuerAggregateArgs>(args: Subset<T, IssuerAggregateArgs>): Prisma.PrismaPromise<GetIssuerAggregateType<T>>

    /**
     * Group by Issuer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssuerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IssuerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IssuerGroupByArgs['orderBy'] }
        : { orderBy?: IssuerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IssuerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssuerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Issuer model
   */
  readonly fields: IssuerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Issuer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IssuerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Issuer$usersArgs<ExtArgs> = {}>(args?: Subset<T, Issuer$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditDefs<T extends Issuer$creditDefsArgs<ExtArgs> = {}>(args?: Subset<T, Issuer$creditDefsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    policies<T extends Issuer$policiesArgs<ExtArgs> = {}>(args?: Subset<T, Issuer$policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Issuer model
   */
  interface IssuerFieldRefs {
    readonly id: FieldRef<"Issuer", 'String'>
    readonly name: FieldRef<"Issuer", 'String'>
    readonly slug: FieldRef<"Issuer", 'String'>
    readonly apiKey: FieldRef<"Issuer", 'String'>
    readonly createdAt: FieldRef<"Issuer", 'DateTime'>
    readonly updatedAt: FieldRef<"Issuer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Issuer findUnique
   */
  export type IssuerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssuerInclude<ExtArgs> | null
    /**
     * Filter, which Issuer to fetch.
     */
    where: IssuerWhereUniqueInput
  }

  /**
   * Issuer findUniqueOrThrow
   */
  export type IssuerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssuerInclude<ExtArgs> | null
    /**
     * Filter, which Issuer to fetch.
     */
    where: IssuerWhereUniqueInput
  }

  /**
   * Issuer findFirst
   */
  export type IssuerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssuerInclude<ExtArgs> | null
    /**
     * Filter, which Issuer to fetch.
     */
    where?: IssuerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issuers to fetch.
     */
    orderBy?: IssuerOrderByWithRelationInput | IssuerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Issuers.
     */
    cursor?: IssuerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issuers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issuers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Issuers.
     */
    distinct?: IssuerScalarFieldEnum | IssuerScalarFieldEnum[]
  }

  /**
   * Issuer findFirstOrThrow
   */
  export type IssuerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssuerInclude<ExtArgs> | null
    /**
     * Filter, which Issuer to fetch.
     */
    where?: IssuerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issuers to fetch.
     */
    orderBy?: IssuerOrderByWithRelationInput | IssuerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Issuers.
     */
    cursor?: IssuerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issuers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issuers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Issuers.
     */
    distinct?: IssuerScalarFieldEnum | IssuerScalarFieldEnum[]
  }

  /**
   * Issuer findMany
   */
  export type IssuerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssuerInclude<ExtArgs> | null
    /**
     * Filter, which Issuers to fetch.
     */
    where?: IssuerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issuers to fetch.
     */
    orderBy?: IssuerOrderByWithRelationInput | IssuerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Issuers.
     */
    cursor?: IssuerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issuers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issuers.
     */
    skip?: number
    distinct?: IssuerScalarFieldEnum | IssuerScalarFieldEnum[]
  }

  /**
   * Issuer create
   */
  export type IssuerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssuerInclude<ExtArgs> | null
    /**
     * The data needed to create a Issuer.
     */
    data: XOR<IssuerCreateInput, IssuerUncheckedCreateInput>
  }

  /**
   * Issuer createMany
   */
  export type IssuerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Issuers.
     */
    data: IssuerCreateManyInput | IssuerCreateManyInput[]
  }

  /**
   * Issuer createManyAndReturn
   */
  export type IssuerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * The data used to create many Issuers.
     */
    data: IssuerCreateManyInput | IssuerCreateManyInput[]
  }

  /**
   * Issuer update
   */
  export type IssuerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssuerInclude<ExtArgs> | null
    /**
     * The data needed to update a Issuer.
     */
    data: XOR<IssuerUpdateInput, IssuerUncheckedUpdateInput>
    /**
     * Choose, which Issuer to update.
     */
    where: IssuerWhereUniqueInput
  }

  /**
   * Issuer updateMany
   */
  export type IssuerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Issuers.
     */
    data: XOR<IssuerUpdateManyMutationInput, IssuerUncheckedUpdateManyInput>
    /**
     * Filter which Issuers to update
     */
    where?: IssuerWhereInput
    /**
     * Limit how many Issuers to update.
     */
    limit?: number
  }

  /**
   * Issuer updateManyAndReturn
   */
  export type IssuerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * The data used to update Issuers.
     */
    data: XOR<IssuerUpdateManyMutationInput, IssuerUncheckedUpdateManyInput>
    /**
     * Filter which Issuers to update
     */
    where?: IssuerWhereInput
    /**
     * Limit how many Issuers to update.
     */
    limit?: number
  }

  /**
   * Issuer upsert
   */
  export type IssuerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssuerInclude<ExtArgs> | null
    /**
     * The filter to search for the Issuer to update in case it exists.
     */
    where: IssuerWhereUniqueInput
    /**
     * In case the Issuer found by the `where` argument doesn't exist, create a new Issuer with this data.
     */
    create: XOR<IssuerCreateInput, IssuerUncheckedCreateInput>
    /**
     * In case the Issuer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IssuerUpdateInput, IssuerUncheckedUpdateInput>
  }

  /**
   * Issuer delete
   */
  export type IssuerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssuerInclude<ExtArgs> | null
    /**
     * Filter which Issuer to delete.
     */
    where: IssuerWhereUniqueInput
  }

  /**
   * Issuer deleteMany
   */
  export type IssuerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Issuers to delete
     */
    where?: IssuerWhereInput
    /**
     * Limit how many Issuers to delete.
     */
    limit?: number
  }

  /**
   * Issuer.users
   */
  export type Issuer$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Issuer.creditDefs
   */
  export type Issuer$creditDefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionInclude<ExtArgs> | null
    where?: VCreditDefinitionWhereInput
    orderBy?: VCreditDefinitionOrderByWithRelationInput | VCreditDefinitionOrderByWithRelationInput[]
    cursor?: VCreditDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VCreditDefinitionScalarFieldEnum | VCreditDefinitionScalarFieldEnum[]
  }

  /**
   * Issuer.policies
   */
  export type Issuer$policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    cursor?: PolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Issuer without action
   */
  export type IssuerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssuerInclude<ExtArgs> | null
  }


  /**
   * Model Merchant
   */

  export type AggregateMerchant = {
    _count: MerchantCountAggregateOutputType | null
    _avg: MerchantAvgAggregateOutputType | null
    _sum: MerchantSumAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  export type MerchantAvgAggregateOutputType = {
    discountRate: Decimal | null
  }

  export type MerchantSumAggregateOutputType = {
    discountRate: Decimal | null
  }

  export type MerchantMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    discountRate: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MerchantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    discountRate: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MerchantCountAggregateOutputType = {
    id: number
    name: number
    category: number
    discountRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MerchantAvgAggregateInputType = {
    discountRate?: true
  }

  export type MerchantSumAggregateInputType = {
    discountRate?: true
  }

  export type MerchantMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    discountRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MerchantMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    discountRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MerchantCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    discountRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MerchantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merchant to aggregate.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Merchants
    **/
    _count?: true | MerchantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MerchantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MerchantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantMaxAggregateInputType
  }

  export type GetMerchantAggregateType<T extends MerchantAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchant[P]>
      : GetScalarType<T[P], AggregateMerchant[P]>
  }




  export type MerchantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantWhereInput
    orderBy?: MerchantOrderByWithAggregationInput | MerchantOrderByWithAggregationInput[]
    by: MerchantScalarFieldEnum[] | MerchantScalarFieldEnum
    having?: MerchantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantCountAggregateInputType | true
    _avg?: MerchantAvgAggregateInputType
    _sum?: MerchantSumAggregateInputType
    _min?: MerchantMinAggregateInputType
    _max?: MerchantMaxAggregateInputType
  }

  export type MerchantGroupByOutputType = {
    id: string
    name: string
    category: string
    discountRate: Decimal
    createdAt: Date
    updatedAt: Date
    _count: MerchantCountAggregateOutputType | null
    _avg: MerchantAvgAggregateOutputType | null
    _sum: MerchantSumAggregateOutputType | null
    _min: MerchantMinAggregateOutputType | null
    _max: MerchantMaxAggregateOutputType | null
  }

  type GetMerchantGroupByPayload<T extends MerchantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantGroupByOutputType[P]>
        }
      >
    >


  export type MerchantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    discountRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Merchant$usersArgs<ExtArgs>
    terminals?: boolean | Merchant$terminalsArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    discountRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    discountRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["merchant"]>

  export type MerchantSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    discountRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MerchantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "discountRate" | "createdAt" | "updatedAt", ExtArgs["result"]["merchant"]>
  export type MerchantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Merchant$usersArgs<ExtArgs>
    terminals?: boolean | Merchant$terminalsArgs<ExtArgs>
    _count?: boolean | MerchantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MerchantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MerchantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MerchantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Merchant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      terminals: Prisma.$MerchantTerminalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string
      discountRate: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["merchant"]>
    composites: {}
  }

  type MerchantGetPayload<S extends boolean | null | undefined | MerchantDefaultArgs> = $Result.GetResult<Prisma.$MerchantPayload, S>

  type MerchantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MerchantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MerchantCountAggregateInputType | true
    }

  export interface MerchantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Merchant'], meta: { name: 'Merchant' } }
    /**
     * Find zero or one Merchant that matches the filter.
     * @param {MerchantFindUniqueArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MerchantFindUniqueArgs>(args: SelectSubset<T, MerchantFindUniqueArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Merchant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MerchantFindUniqueOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MerchantFindUniqueOrThrowArgs>(args: SelectSubset<T, MerchantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MerchantFindFirstArgs>(args?: SelectSubset<T, MerchantFindFirstArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindFirstOrThrowArgs} args - Arguments to find a Merchant
     * @example
     * // Get one Merchant
     * const merchant = await prisma.merchant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MerchantFindFirstOrThrowArgs>(args?: SelectSubset<T, MerchantFindFirstOrThrowArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Merchants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Merchants
     * const merchants = await prisma.merchant.findMany()
     * 
     * // Get first 10 Merchants
     * const merchants = await prisma.merchant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantWithIdOnly = await prisma.merchant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MerchantFindManyArgs>(args?: SelectSubset<T, MerchantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Merchant.
     * @param {MerchantCreateArgs} args - Arguments to create a Merchant.
     * @example
     * // Create one Merchant
     * const Merchant = await prisma.merchant.create({
     *   data: {
     *     // ... data to create a Merchant
     *   }
     * })
     * 
     */
    create<T extends MerchantCreateArgs>(args: SelectSubset<T, MerchantCreateArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Merchants.
     * @param {MerchantCreateManyArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MerchantCreateManyArgs>(args?: SelectSubset<T, MerchantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Merchants and returns the data saved in the database.
     * @param {MerchantCreateManyAndReturnArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchant = await prisma.merchant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MerchantCreateManyAndReturnArgs>(args?: SelectSubset<T, MerchantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Merchant.
     * @param {MerchantDeleteArgs} args - Arguments to delete one Merchant.
     * @example
     * // Delete one Merchant
     * const Merchant = await prisma.merchant.delete({
     *   where: {
     *     // ... filter to delete one Merchant
     *   }
     * })
     * 
     */
    delete<T extends MerchantDeleteArgs>(args: SelectSubset<T, MerchantDeleteArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Merchant.
     * @param {MerchantUpdateArgs} args - Arguments to update one Merchant.
     * @example
     * // Update one Merchant
     * const merchant = await prisma.merchant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MerchantUpdateArgs>(args: SelectSubset<T, MerchantUpdateArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Merchants.
     * @param {MerchantDeleteManyArgs} args - Arguments to filter Merchants to delete.
     * @example
     * // Delete a few Merchants
     * const { count } = await prisma.merchant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MerchantDeleteManyArgs>(args?: SelectSubset<T, MerchantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MerchantUpdateManyArgs>(args: SelectSubset<T, MerchantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants and returns the data updated in the database.
     * @param {MerchantUpdateManyAndReturnArgs} args - Arguments to update many Merchants.
     * @example
     * // Update many Merchants
     * const merchant = await prisma.merchant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Merchants and only return the `id`
     * const merchantWithIdOnly = await prisma.merchant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MerchantUpdateManyAndReturnArgs>(args: SelectSubset<T, MerchantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Merchant.
     * @param {MerchantUpsertArgs} args - Arguments to update or create a Merchant.
     * @example
     * // Update or create a Merchant
     * const merchant = await prisma.merchant.upsert({
     *   create: {
     *     // ... data to create a Merchant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Merchant we want to update
     *   }
     * })
     */
    upsert<T extends MerchantUpsertArgs>(args: SelectSubset<T, MerchantUpsertArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantCountArgs} args - Arguments to filter Merchants to count.
     * @example
     * // Count the number of Merchants
     * const count = await prisma.merchant.count({
     *   where: {
     *     // ... the filter for the Merchants we want to count
     *   }
     * })
    **/
    count<T extends MerchantCountArgs>(
      args?: Subset<T, MerchantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantAggregateArgs>(args: Subset<T, MerchantAggregateArgs>): Prisma.PrismaPromise<GetMerchantAggregateType<T>>

    /**
     * Group by Merchant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerchantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerchantGroupByArgs['orderBy'] }
        : { orderBy?: MerchantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerchantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Merchant model
   */
  readonly fields: MerchantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Merchant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MerchantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Merchant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    terminals<T extends Merchant$terminalsArgs<ExtArgs> = {}>(args?: Subset<T, Merchant$terminalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantTerminalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Merchant model
   */
  interface MerchantFieldRefs {
    readonly id: FieldRef<"Merchant", 'String'>
    readonly name: FieldRef<"Merchant", 'String'>
    readonly category: FieldRef<"Merchant", 'String'>
    readonly discountRate: FieldRef<"Merchant", 'Decimal'>
    readonly createdAt: FieldRef<"Merchant", 'DateTime'>
    readonly updatedAt: FieldRef<"Merchant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Merchant findUnique
   */
  export type MerchantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant findUniqueOrThrow
   */
  export type MerchantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant findFirst
   */
  export type MerchantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant findFirstOrThrow
   */
  export type MerchantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchant to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merchants.
     */
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant findMany
   */
  export type MerchantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter, which Merchants to fetch.
     */
    where?: MerchantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merchants to fetch.
     */
    orderBy?: MerchantOrderByWithRelationInput | MerchantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Merchants.
     */
    cursor?: MerchantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merchants.
     */
    skip?: number
    distinct?: MerchantScalarFieldEnum | MerchantScalarFieldEnum[]
  }

  /**
   * Merchant create
   */
  export type MerchantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The data needed to create a Merchant.
     */
    data: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
  }

  /**
   * Merchant createMany
   */
  export type MerchantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Merchants.
     */
    data: MerchantCreateManyInput | MerchantCreateManyInput[]
  }

  /**
   * Merchant createManyAndReturn
   */
  export type MerchantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * The data used to create many Merchants.
     */
    data: MerchantCreateManyInput | MerchantCreateManyInput[]
  }

  /**
   * Merchant update
   */
  export type MerchantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The data needed to update a Merchant.
     */
    data: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
    /**
     * Choose, which Merchant to update.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant updateMany
   */
  export type MerchantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Merchants.
     */
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyInput>
    /**
     * Filter which Merchants to update
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to update.
     */
    limit?: number
  }

  /**
   * Merchant updateManyAndReturn
   */
  export type MerchantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * The data used to update Merchants.
     */
    data: XOR<MerchantUpdateManyMutationInput, MerchantUncheckedUpdateManyInput>
    /**
     * Filter which Merchants to update
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to update.
     */
    limit?: number
  }

  /**
   * Merchant upsert
   */
  export type MerchantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * The filter to search for the Merchant to update in case it exists.
     */
    where: MerchantWhereUniqueInput
    /**
     * In case the Merchant found by the `where` argument doesn't exist, create a new Merchant with this data.
     */
    create: XOR<MerchantCreateInput, MerchantUncheckedCreateInput>
    /**
     * In case the Merchant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MerchantUpdateInput, MerchantUncheckedUpdateInput>
  }

  /**
   * Merchant delete
   */
  export type MerchantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
    /**
     * Filter which Merchant to delete.
     */
    where: MerchantWhereUniqueInput
  }

  /**
   * Merchant deleteMany
   */
  export type MerchantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merchants to delete
     */
    where?: MerchantWhereInput
    /**
     * Limit how many Merchants to delete.
     */
    limit?: number
  }

  /**
   * Merchant.users
   */
  export type Merchant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Merchant.terminals
   */
  export type Merchant$terminalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalInclude<ExtArgs> | null
    where?: MerchantTerminalWhereInput
    orderBy?: MerchantTerminalOrderByWithRelationInput | MerchantTerminalOrderByWithRelationInput[]
    cursor?: MerchantTerminalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MerchantTerminalScalarFieldEnum | MerchantTerminalScalarFieldEnum[]
  }

  /**
   * Merchant without action
   */
  export type MerchantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merchant
     */
    select?: MerchantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Merchant
     */
    omit?: MerchantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantInclude<ExtArgs> | null
  }


  /**
   * Model MerchantTerminal
   */

  export type AggregateMerchantTerminal = {
    _count: MerchantTerminalCountAggregateOutputType | null
    _min: MerchantTerminalMinAggregateOutputType | null
    _max: MerchantTerminalMaxAggregateOutputType | null
  }

  export type MerchantTerminalMinAggregateOutputType = {
    id: string | null
    merchantId: string | null
    location: string | null
    secretKey: string | null
    createdAt: Date | null
  }

  export type MerchantTerminalMaxAggregateOutputType = {
    id: string | null
    merchantId: string | null
    location: string | null
    secretKey: string | null
    createdAt: Date | null
  }

  export type MerchantTerminalCountAggregateOutputType = {
    id: number
    merchantId: number
    location: number
    secretKey: number
    createdAt: number
    _all: number
  }


  export type MerchantTerminalMinAggregateInputType = {
    id?: true
    merchantId?: true
    location?: true
    secretKey?: true
    createdAt?: true
  }

  export type MerchantTerminalMaxAggregateInputType = {
    id?: true
    merchantId?: true
    location?: true
    secretKey?: true
    createdAt?: true
  }

  export type MerchantTerminalCountAggregateInputType = {
    id?: true
    merchantId?: true
    location?: true
    secretKey?: true
    createdAt?: true
    _all?: true
  }

  export type MerchantTerminalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MerchantTerminal to aggregate.
     */
    where?: MerchantTerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantTerminals to fetch.
     */
    orderBy?: MerchantTerminalOrderByWithRelationInput | MerchantTerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MerchantTerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantTerminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantTerminals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MerchantTerminals
    **/
    _count?: true | MerchantTerminalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantTerminalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantTerminalMaxAggregateInputType
  }

  export type GetMerchantTerminalAggregateType<T extends MerchantTerminalAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchantTerminal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchantTerminal[P]>
      : GetScalarType<T[P], AggregateMerchantTerminal[P]>
  }




  export type MerchantTerminalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MerchantTerminalWhereInput
    orderBy?: MerchantTerminalOrderByWithAggregationInput | MerchantTerminalOrderByWithAggregationInput[]
    by: MerchantTerminalScalarFieldEnum[] | MerchantTerminalScalarFieldEnum
    having?: MerchantTerminalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantTerminalCountAggregateInputType | true
    _min?: MerchantTerminalMinAggregateInputType
    _max?: MerchantTerminalMaxAggregateInputType
  }

  export type MerchantTerminalGroupByOutputType = {
    id: string
    merchantId: string
    location: string
    secretKey: string
    createdAt: Date
    _count: MerchantTerminalCountAggregateOutputType | null
    _min: MerchantTerminalMinAggregateOutputType | null
    _max: MerchantTerminalMaxAggregateOutputType | null
  }

  type GetMerchantTerminalGroupByPayload<T extends MerchantTerminalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantTerminalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantTerminalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantTerminalGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantTerminalGroupByOutputType[P]>
        }
      >
    >


  export type MerchantTerminalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    location?: boolean
    secretKey?: boolean
    createdAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchantTerminal"]>

  export type MerchantTerminalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    location?: boolean
    secretKey?: boolean
    createdAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchantTerminal"]>

  export type MerchantTerminalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    merchantId?: boolean
    location?: boolean
    secretKey?: boolean
    createdAt?: boolean
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchantTerminal"]>

  export type MerchantTerminalSelectScalar = {
    id?: boolean
    merchantId?: boolean
    location?: boolean
    secretKey?: boolean
    createdAt?: boolean
  }

  export type MerchantTerminalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "merchantId" | "location" | "secretKey" | "createdAt", ExtArgs["result"]["merchantTerminal"]>
  export type MerchantTerminalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }
  export type MerchantTerminalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }
  export type MerchantTerminalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    merchant?: boolean | MerchantDefaultArgs<ExtArgs>
  }

  export type $MerchantTerminalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MerchantTerminal"
    objects: {
      merchant: Prisma.$MerchantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      merchantId: string
      location: string
      secretKey: string
      createdAt: Date
    }, ExtArgs["result"]["merchantTerminal"]>
    composites: {}
  }

  type MerchantTerminalGetPayload<S extends boolean | null | undefined | MerchantTerminalDefaultArgs> = $Result.GetResult<Prisma.$MerchantTerminalPayload, S>

  type MerchantTerminalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MerchantTerminalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MerchantTerminalCountAggregateInputType | true
    }

  export interface MerchantTerminalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MerchantTerminal'], meta: { name: 'MerchantTerminal' } }
    /**
     * Find zero or one MerchantTerminal that matches the filter.
     * @param {MerchantTerminalFindUniqueArgs} args - Arguments to find a MerchantTerminal
     * @example
     * // Get one MerchantTerminal
     * const merchantTerminal = await prisma.merchantTerminal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MerchantTerminalFindUniqueArgs>(args: SelectSubset<T, MerchantTerminalFindUniqueArgs<ExtArgs>>): Prisma__MerchantTerminalClient<$Result.GetResult<Prisma.$MerchantTerminalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MerchantTerminal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MerchantTerminalFindUniqueOrThrowArgs} args - Arguments to find a MerchantTerminal
     * @example
     * // Get one MerchantTerminal
     * const merchantTerminal = await prisma.merchantTerminal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MerchantTerminalFindUniqueOrThrowArgs>(args: SelectSubset<T, MerchantTerminalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MerchantTerminalClient<$Result.GetResult<Prisma.$MerchantTerminalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MerchantTerminal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantTerminalFindFirstArgs} args - Arguments to find a MerchantTerminal
     * @example
     * // Get one MerchantTerminal
     * const merchantTerminal = await prisma.merchantTerminal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MerchantTerminalFindFirstArgs>(args?: SelectSubset<T, MerchantTerminalFindFirstArgs<ExtArgs>>): Prisma__MerchantTerminalClient<$Result.GetResult<Prisma.$MerchantTerminalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MerchantTerminal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantTerminalFindFirstOrThrowArgs} args - Arguments to find a MerchantTerminal
     * @example
     * // Get one MerchantTerminal
     * const merchantTerminal = await prisma.merchantTerminal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MerchantTerminalFindFirstOrThrowArgs>(args?: SelectSubset<T, MerchantTerminalFindFirstOrThrowArgs<ExtArgs>>): Prisma__MerchantTerminalClient<$Result.GetResult<Prisma.$MerchantTerminalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MerchantTerminals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantTerminalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MerchantTerminals
     * const merchantTerminals = await prisma.merchantTerminal.findMany()
     * 
     * // Get first 10 MerchantTerminals
     * const merchantTerminals = await prisma.merchantTerminal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantTerminalWithIdOnly = await prisma.merchantTerminal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MerchantTerminalFindManyArgs>(args?: SelectSubset<T, MerchantTerminalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantTerminalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MerchantTerminal.
     * @param {MerchantTerminalCreateArgs} args - Arguments to create a MerchantTerminal.
     * @example
     * // Create one MerchantTerminal
     * const MerchantTerminal = await prisma.merchantTerminal.create({
     *   data: {
     *     // ... data to create a MerchantTerminal
     *   }
     * })
     * 
     */
    create<T extends MerchantTerminalCreateArgs>(args: SelectSubset<T, MerchantTerminalCreateArgs<ExtArgs>>): Prisma__MerchantTerminalClient<$Result.GetResult<Prisma.$MerchantTerminalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MerchantTerminals.
     * @param {MerchantTerminalCreateManyArgs} args - Arguments to create many MerchantTerminals.
     * @example
     * // Create many MerchantTerminals
     * const merchantTerminal = await prisma.merchantTerminal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MerchantTerminalCreateManyArgs>(args?: SelectSubset<T, MerchantTerminalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MerchantTerminals and returns the data saved in the database.
     * @param {MerchantTerminalCreateManyAndReturnArgs} args - Arguments to create many MerchantTerminals.
     * @example
     * // Create many MerchantTerminals
     * const merchantTerminal = await prisma.merchantTerminal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MerchantTerminals and only return the `id`
     * const merchantTerminalWithIdOnly = await prisma.merchantTerminal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MerchantTerminalCreateManyAndReturnArgs>(args?: SelectSubset<T, MerchantTerminalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantTerminalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MerchantTerminal.
     * @param {MerchantTerminalDeleteArgs} args - Arguments to delete one MerchantTerminal.
     * @example
     * // Delete one MerchantTerminal
     * const MerchantTerminal = await prisma.merchantTerminal.delete({
     *   where: {
     *     // ... filter to delete one MerchantTerminal
     *   }
     * })
     * 
     */
    delete<T extends MerchantTerminalDeleteArgs>(args: SelectSubset<T, MerchantTerminalDeleteArgs<ExtArgs>>): Prisma__MerchantTerminalClient<$Result.GetResult<Prisma.$MerchantTerminalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MerchantTerminal.
     * @param {MerchantTerminalUpdateArgs} args - Arguments to update one MerchantTerminal.
     * @example
     * // Update one MerchantTerminal
     * const merchantTerminal = await prisma.merchantTerminal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MerchantTerminalUpdateArgs>(args: SelectSubset<T, MerchantTerminalUpdateArgs<ExtArgs>>): Prisma__MerchantTerminalClient<$Result.GetResult<Prisma.$MerchantTerminalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MerchantTerminals.
     * @param {MerchantTerminalDeleteManyArgs} args - Arguments to filter MerchantTerminals to delete.
     * @example
     * // Delete a few MerchantTerminals
     * const { count } = await prisma.merchantTerminal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MerchantTerminalDeleteManyArgs>(args?: SelectSubset<T, MerchantTerminalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MerchantTerminals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantTerminalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MerchantTerminals
     * const merchantTerminal = await prisma.merchantTerminal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MerchantTerminalUpdateManyArgs>(args: SelectSubset<T, MerchantTerminalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MerchantTerminals and returns the data updated in the database.
     * @param {MerchantTerminalUpdateManyAndReturnArgs} args - Arguments to update many MerchantTerminals.
     * @example
     * // Update many MerchantTerminals
     * const merchantTerminal = await prisma.merchantTerminal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MerchantTerminals and only return the `id`
     * const merchantTerminalWithIdOnly = await prisma.merchantTerminal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MerchantTerminalUpdateManyAndReturnArgs>(args: SelectSubset<T, MerchantTerminalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MerchantTerminalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MerchantTerminal.
     * @param {MerchantTerminalUpsertArgs} args - Arguments to update or create a MerchantTerminal.
     * @example
     * // Update or create a MerchantTerminal
     * const merchantTerminal = await prisma.merchantTerminal.upsert({
     *   create: {
     *     // ... data to create a MerchantTerminal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MerchantTerminal we want to update
     *   }
     * })
     */
    upsert<T extends MerchantTerminalUpsertArgs>(args: SelectSubset<T, MerchantTerminalUpsertArgs<ExtArgs>>): Prisma__MerchantTerminalClient<$Result.GetResult<Prisma.$MerchantTerminalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MerchantTerminals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantTerminalCountArgs} args - Arguments to filter MerchantTerminals to count.
     * @example
     * // Count the number of MerchantTerminals
     * const count = await prisma.merchantTerminal.count({
     *   where: {
     *     // ... the filter for the MerchantTerminals we want to count
     *   }
     * })
    **/
    count<T extends MerchantTerminalCountArgs>(
      args?: Subset<T, MerchantTerminalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantTerminalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MerchantTerminal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantTerminalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantTerminalAggregateArgs>(args: Subset<T, MerchantTerminalAggregateArgs>): Prisma.PrismaPromise<GetMerchantTerminalAggregateType<T>>

    /**
     * Group by MerchantTerminal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantTerminalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MerchantTerminalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MerchantTerminalGroupByArgs['orderBy'] }
        : { orderBy?: MerchantTerminalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MerchantTerminalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantTerminalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MerchantTerminal model
   */
  readonly fields: MerchantTerminalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MerchantTerminal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MerchantTerminalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    merchant<T extends MerchantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MerchantDefaultArgs<ExtArgs>>): Prisma__MerchantClient<$Result.GetResult<Prisma.$MerchantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MerchantTerminal model
   */
  interface MerchantTerminalFieldRefs {
    readonly id: FieldRef<"MerchantTerminal", 'String'>
    readonly merchantId: FieldRef<"MerchantTerminal", 'String'>
    readonly location: FieldRef<"MerchantTerminal", 'String'>
    readonly secretKey: FieldRef<"MerchantTerminal", 'String'>
    readonly createdAt: FieldRef<"MerchantTerminal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MerchantTerminal findUnique
   */
  export type MerchantTerminalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalInclude<ExtArgs> | null
    /**
     * Filter, which MerchantTerminal to fetch.
     */
    where: MerchantTerminalWhereUniqueInput
  }

  /**
   * MerchantTerminal findUniqueOrThrow
   */
  export type MerchantTerminalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalInclude<ExtArgs> | null
    /**
     * Filter, which MerchantTerminal to fetch.
     */
    where: MerchantTerminalWhereUniqueInput
  }

  /**
   * MerchantTerminal findFirst
   */
  export type MerchantTerminalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalInclude<ExtArgs> | null
    /**
     * Filter, which MerchantTerminal to fetch.
     */
    where?: MerchantTerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantTerminals to fetch.
     */
    orderBy?: MerchantTerminalOrderByWithRelationInput | MerchantTerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MerchantTerminals.
     */
    cursor?: MerchantTerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantTerminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantTerminals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MerchantTerminals.
     */
    distinct?: MerchantTerminalScalarFieldEnum | MerchantTerminalScalarFieldEnum[]
  }

  /**
   * MerchantTerminal findFirstOrThrow
   */
  export type MerchantTerminalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalInclude<ExtArgs> | null
    /**
     * Filter, which MerchantTerminal to fetch.
     */
    where?: MerchantTerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantTerminals to fetch.
     */
    orderBy?: MerchantTerminalOrderByWithRelationInput | MerchantTerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MerchantTerminals.
     */
    cursor?: MerchantTerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantTerminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantTerminals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MerchantTerminals.
     */
    distinct?: MerchantTerminalScalarFieldEnum | MerchantTerminalScalarFieldEnum[]
  }

  /**
   * MerchantTerminal findMany
   */
  export type MerchantTerminalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalInclude<ExtArgs> | null
    /**
     * Filter, which MerchantTerminals to fetch.
     */
    where?: MerchantTerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MerchantTerminals to fetch.
     */
    orderBy?: MerchantTerminalOrderByWithRelationInput | MerchantTerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MerchantTerminals.
     */
    cursor?: MerchantTerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MerchantTerminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MerchantTerminals.
     */
    skip?: number
    distinct?: MerchantTerminalScalarFieldEnum | MerchantTerminalScalarFieldEnum[]
  }

  /**
   * MerchantTerminal create
   */
  export type MerchantTerminalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalInclude<ExtArgs> | null
    /**
     * The data needed to create a MerchantTerminal.
     */
    data: XOR<MerchantTerminalCreateInput, MerchantTerminalUncheckedCreateInput>
  }

  /**
   * MerchantTerminal createMany
   */
  export type MerchantTerminalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MerchantTerminals.
     */
    data: MerchantTerminalCreateManyInput | MerchantTerminalCreateManyInput[]
  }

  /**
   * MerchantTerminal createManyAndReturn
   */
  export type MerchantTerminalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * The data used to create many MerchantTerminals.
     */
    data: MerchantTerminalCreateManyInput | MerchantTerminalCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MerchantTerminal update
   */
  export type MerchantTerminalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalInclude<ExtArgs> | null
    /**
     * The data needed to update a MerchantTerminal.
     */
    data: XOR<MerchantTerminalUpdateInput, MerchantTerminalUncheckedUpdateInput>
    /**
     * Choose, which MerchantTerminal to update.
     */
    where: MerchantTerminalWhereUniqueInput
  }

  /**
   * MerchantTerminal updateMany
   */
  export type MerchantTerminalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MerchantTerminals.
     */
    data: XOR<MerchantTerminalUpdateManyMutationInput, MerchantTerminalUncheckedUpdateManyInput>
    /**
     * Filter which MerchantTerminals to update
     */
    where?: MerchantTerminalWhereInput
    /**
     * Limit how many MerchantTerminals to update.
     */
    limit?: number
  }

  /**
   * MerchantTerminal updateManyAndReturn
   */
  export type MerchantTerminalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * The data used to update MerchantTerminals.
     */
    data: XOR<MerchantTerminalUpdateManyMutationInput, MerchantTerminalUncheckedUpdateManyInput>
    /**
     * Filter which MerchantTerminals to update
     */
    where?: MerchantTerminalWhereInput
    /**
     * Limit how many MerchantTerminals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MerchantTerminal upsert
   */
  export type MerchantTerminalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalInclude<ExtArgs> | null
    /**
     * The filter to search for the MerchantTerminal to update in case it exists.
     */
    where: MerchantTerminalWhereUniqueInput
    /**
     * In case the MerchantTerminal found by the `where` argument doesn't exist, create a new MerchantTerminal with this data.
     */
    create: XOR<MerchantTerminalCreateInput, MerchantTerminalUncheckedCreateInput>
    /**
     * In case the MerchantTerminal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MerchantTerminalUpdateInput, MerchantTerminalUncheckedUpdateInput>
  }

  /**
   * MerchantTerminal delete
   */
  export type MerchantTerminalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalInclude<ExtArgs> | null
    /**
     * Filter which MerchantTerminal to delete.
     */
    where: MerchantTerminalWhereUniqueInput
  }

  /**
   * MerchantTerminal deleteMany
   */
  export type MerchantTerminalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MerchantTerminals to delete
     */
    where?: MerchantTerminalWhereInput
    /**
     * Limit how many MerchantTerminals to delete.
     */
    limit?: number
  }

  /**
   * MerchantTerminal without action
   */
  export type MerchantTerminalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantTerminal
     */
    select?: MerchantTerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MerchantTerminal
     */
    omit?: MerchantTerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MerchantTerminalInclude<ExtArgs> | null
  }


  /**
   * Model VCreditDefinition
   */

  export type AggregateVCreditDefinition = {
    _count: VCreditDefinitionCountAggregateOutputType | null
    _avg: VCreditDefinitionAvgAggregateOutputType | null
    _sum: VCreditDefinitionSumAggregateOutputType | null
    _min: VCreditDefinitionMinAggregateOutputType | null
    _max: VCreditDefinitionMaxAggregateOutputType | null
  }

  export type VCreditDefinitionAvgAggregateOutputType = {
    decimals: number | null
    exchangeRateBaseUSD: Decimal | null
  }

  export type VCreditDefinitionSumAggregateOutputType = {
    decimals: number | null
    exchangeRateBaseUSD: Decimal | null
  }

  export type VCreditDefinitionMinAggregateOutputType = {
    id: string | null
    issuerId: string | null
    name: string | null
    symbol: string | null
    decimals: number | null
    type: string | null
    exchangeRateBaseUSD: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VCreditDefinitionMaxAggregateOutputType = {
    id: string | null
    issuerId: string | null
    name: string | null
    symbol: string | null
    decimals: number | null
    type: string | null
    exchangeRateBaseUSD: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VCreditDefinitionCountAggregateOutputType = {
    id: number
    issuerId: number
    name: number
    symbol: number
    decimals: number
    type: number
    exchangeRateBaseUSD: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VCreditDefinitionAvgAggregateInputType = {
    decimals?: true
    exchangeRateBaseUSD?: true
  }

  export type VCreditDefinitionSumAggregateInputType = {
    decimals?: true
    exchangeRateBaseUSD?: true
  }

  export type VCreditDefinitionMinAggregateInputType = {
    id?: true
    issuerId?: true
    name?: true
    symbol?: true
    decimals?: true
    type?: true
    exchangeRateBaseUSD?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VCreditDefinitionMaxAggregateInputType = {
    id?: true
    issuerId?: true
    name?: true
    symbol?: true
    decimals?: true
    type?: true
    exchangeRateBaseUSD?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VCreditDefinitionCountAggregateInputType = {
    id?: true
    issuerId?: true
    name?: true
    symbol?: true
    decimals?: true
    type?: true
    exchangeRateBaseUSD?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VCreditDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VCreditDefinition to aggregate.
     */
    where?: VCreditDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VCreditDefinitions to fetch.
     */
    orderBy?: VCreditDefinitionOrderByWithRelationInput | VCreditDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VCreditDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VCreditDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VCreditDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VCreditDefinitions
    **/
    _count?: true | VCreditDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VCreditDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VCreditDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VCreditDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VCreditDefinitionMaxAggregateInputType
  }

  export type GetVCreditDefinitionAggregateType<T extends VCreditDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateVCreditDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVCreditDefinition[P]>
      : GetScalarType<T[P], AggregateVCreditDefinition[P]>
  }




  export type VCreditDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VCreditDefinitionWhereInput
    orderBy?: VCreditDefinitionOrderByWithAggregationInput | VCreditDefinitionOrderByWithAggregationInput[]
    by: VCreditDefinitionScalarFieldEnum[] | VCreditDefinitionScalarFieldEnum
    having?: VCreditDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VCreditDefinitionCountAggregateInputType | true
    _avg?: VCreditDefinitionAvgAggregateInputType
    _sum?: VCreditDefinitionSumAggregateInputType
    _min?: VCreditDefinitionMinAggregateInputType
    _max?: VCreditDefinitionMaxAggregateInputType
  }

  export type VCreditDefinitionGroupByOutputType = {
    id: string
    issuerId: string
    name: string
    symbol: string
    decimals: number
    type: string
    exchangeRateBaseUSD: Decimal
    createdAt: Date
    updatedAt: Date
    _count: VCreditDefinitionCountAggregateOutputType | null
    _avg: VCreditDefinitionAvgAggregateOutputType | null
    _sum: VCreditDefinitionSumAggregateOutputType | null
    _min: VCreditDefinitionMinAggregateOutputType | null
    _max: VCreditDefinitionMaxAggregateOutputType | null
  }

  type GetVCreditDefinitionGroupByPayload<T extends VCreditDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VCreditDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VCreditDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VCreditDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], VCreditDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type VCreditDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issuerId?: boolean
    name?: boolean
    symbol?: boolean
    decimals?: boolean
    type?: boolean
    exchangeRateBaseUSD?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    issuer?: boolean | IssuerDefaultArgs<ExtArgs>
    balances?: boolean | VCreditDefinition$balancesArgs<ExtArgs>
    policies?: boolean | VCreditDefinition$policiesArgs<ExtArgs>
    liquidityPool?: boolean | VCreditDefinition$liquidityPoolArgs<ExtArgs>
    _count?: boolean | VCreditDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vCreditDefinition"]>

  export type VCreditDefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issuerId?: boolean
    name?: boolean
    symbol?: boolean
    decimals?: boolean
    type?: boolean
    exchangeRateBaseUSD?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    issuer?: boolean | IssuerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vCreditDefinition"]>

  export type VCreditDefinitionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issuerId?: boolean
    name?: boolean
    symbol?: boolean
    decimals?: boolean
    type?: boolean
    exchangeRateBaseUSD?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    issuer?: boolean | IssuerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vCreditDefinition"]>

  export type VCreditDefinitionSelectScalar = {
    id?: boolean
    issuerId?: boolean
    name?: boolean
    symbol?: boolean
    decimals?: boolean
    type?: boolean
    exchangeRateBaseUSD?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VCreditDefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "issuerId" | "name" | "symbol" | "decimals" | "type" | "exchangeRateBaseUSD" | "createdAt" | "updatedAt", ExtArgs["result"]["vCreditDefinition"]>
  export type VCreditDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | IssuerDefaultArgs<ExtArgs>
    balances?: boolean | VCreditDefinition$balancesArgs<ExtArgs>
    policies?: boolean | VCreditDefinition$policiesArgs<ExtArgs>
    liquidityPool?: boolean | VCreditDefinition$liquidityPoolArgs<ExtArgs>
    _count?: boolean | VCreditDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VCreditDefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | IssuerDefaultArgs<ExtArgs>
  }
  export type VCreditDefinitionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | IssuerDefaultArgs<ExtArgs>
  }

  export type $VCreditDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VCreditDefinition"
    objects: {
      issuer: Prisma.$IssuerPayload<ExtArgs>
      balances: Prisma.$BalancePayload<ExtArgs>[]
      policies: Prisma.$PolicyPayload<ExtArgs>[]
      liquidityPool: Prisma.$LiquidityPoolPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      issuerId: string
      name: string
      symbol: string
      decimals: number
      type: string
      exchangeRateBaseUSD: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vCreditDefinition"]>
    composites: {}
  }

  type VCreditDefinitionGetPayload<S extends boolean | null | undefined | VCreditDefinitionDefaultArgs> = $Result.GetResult<Prisma.$VCreditDefinitionPayload, S>

  type VCreditDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VCreditDefinitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VCreditDefinitionCountAggregateInputType | true
    }

  export interface VCreditDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VCreditDefinition'], meta: { name: 'VCreditDefinition' } }
    /**
     * Find zero or one VCreditDefinition that matches the filter.
     * @param {VCreditDefinitionFindUniqueArgs} args - Arguments to find a VCreditDefinition
     * @example
     * // Get one VCreditDefinition
     * const vCreditDefinition = await prisma.vCreditDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VCreditDefinitionFindUniqueArgs>(args: SelectSubset<T, VCreditDefinitionFindUniqueArgs<ExtArgs>>): Prisma__VCreditDefinitionClient<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VCreditDefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VCreditDefinitionFindUniqueOrThrowArgs} args - Arguments to find a VCreditDefinition
     * @example
     * // Get one VCreditDefinition
     * const vCreditDefinition = await prisma.vCreditDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VCreditDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, VCreditDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VCreditDefinitionClient<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VCreditDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VCreditDefinitionFindFirstArgs} args - Arguments to find a VCreditDefinition
     * @example
     * // Get one VCreditDefinition
     * const vCreditDefinition = await prisma.vCreditDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VCreditDefinitionFindFirstArgs>(args?: SelectSubset<T, VCreditDefinitionFindFirstArgs<ExtArgs>>): Prisma__VCreditDefinitionClient<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VCreditDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VCreditDefinitionFindFirstOrThrowArgs} args - Arguments to find a VCreditDefinition
     * @example
     * // Get one VCreditDefinition
     * const vCreditDefinition = await prisma.vCreditDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VCreditDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, VCreditDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VCreditDefinitionClient<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VCreditDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VCreditDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VCreditDefinitions
     * const vCreditDefinitions = await prisma.vCreditDefinition.findMany()
     * 
     * // Get first 10 VCreditDefinitions
     * const vCreditDefinitions = await prisma.vCreditDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vCreditDefinitionWithIdOnly = await prisma.vCreditDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VCreditDefinitionFindManyArgs>(args?: SelectSubset<T, VCreditDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VCreditDefinition.
     * @param {VCreditDefinitionCreateArgs} args - Arguments to create a VCreditDefinition.
     * @example
     * // Create one VCreditDefinition
     * const VCreditDefinition = await prisma.vCreditDefinition.create({
     *   data: {
     *     // ... data to create a VCreditDefinition
     *   }
     * })
     * 
     */
    create<T extends VCreditDefinitionCreateArgs>(args: SelectSubset<T, VCreditDefinitionCreateArgs<ExtArgs>>): Prisma__VCreditDefinitionClient<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VCreditDefinitions.
     * @param {VCreditDefinitionCreateManyArgs} args - Arguments to create many VCreditDefinitions.
     * @example
     * // Create many VCreditDefinitions
     * const vCreditDefinition = await prisma.vCreditDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VCreditDefinitionCreateManyArgs>(args?: SelectSubset<T, VCreditDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VCreditDefinitions and returns the data saved in the database.
     * @param {VCreditDefinitionCreateManyAndReturnArgs} args - Arguments to create many VCreditDefinitions.
     * @example
     * // Create many VCreditDefinitions
     * const vCreditDefinition = await prisma.vCreditDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VCreditDefinitions and only return the `id`
     * const vCreditDefinitionWithIdOnly = await prisma.vCreditDefinition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VCreditDefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, VCreditDefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VCreditDefinition.
     * @param {VCreditDefinitionDeleteArgs} args - Arguments to delete one VCreditDefinition.
     * @example
     * // Delete one VCreditDefinition
     * const VCreditDefinition = await prisma.vCreditDefinition.delete({
     *   where: {
     *     // ... filter to delete one VCreditDefinition
     *   }
     * })
     * 
     */
    delete<T extends VCreditDefinitionDeleteArgs>(args: SelectSubset<T, VCreditDefinitionDeleteArgs<ExtArgs>>): Prisma__VCreditDefinitionClient<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VCreditDefinition.
     * @param {VCreditDefinitionUpdateArgs} args - Arguments to update one VCreditDefinition.
     * @example
     * // Update one VCreditDefinition
     * const vCreditDefinition = await prisma.vCreditDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VCreditDefinitionUpdateArgs>(args: SelectSubset<T, VCreditDefinitionUpdateArgs<ExtArgs>>): Prisma__VCreditDefinitionClient<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VCreditDefinitions.
     * @param {VCreditDefinitionDeleteManyArgs} args - Arguments to filter VCreditDefinitions to delete.
     * @example
     * // Delete a few VCreditDefinitions
     * const { count } = await prisma.vCreditDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VCreditDefinitionDeleteManyArgs>(args?: SelectSubset<T, VCreditDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VCreditDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VCreditDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VCreditDefinitions
     * const vCreditDefinition = await prisma.vCreditDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VCreditDefinitionUpdateManyArgs>(args: SelectSubset<T, VCreditDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VCreditDefinitions and returns the data updated in the database.
     * @param {VCreditDefinitionUpdateManyAndReturnArgs} args - Arguments to update many VCreditDefinitions.
     * @example
     * // Update many VCreditDefinitions
     * const vCreditDefinition = await prisma.vCreditDefinition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VCreditDefinitions and only return the `id`
     * const vCreditDefinitionWithIdOnly = await prisma.vCreditDefinition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VCreditDefinitionUpdateManyAndReturnArgs>(args: SelectSubset<T, VCreditDefinitionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VCreditDefinition.
     * @param {VCreditDefinitionUpsertArgs} args - Arguments to update or create a VCreditDefinition.
     * @example
     * // Update or create a VCreditDefinition
     * const vCreditDefinition = await prisma.vCreditDefinition.upsert({
     *   create: {
     *     // ... data to create a VCreditDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VCreditDefinition we want to update
     *   }
     * })
     */
    upsert<T extends VCreditDefinitionUpsertArgs>(args: SelectSubset<T, VCreditDefinitionUpsertArgs<ExtArgs>>): Prisma__VCreditDefinitionClient<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VCreditDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VCreditDefinitionCountArgs} args - Arguments to filter VCreditDefinitions to count.
     * @example
     * // Count the number of VCreditDefinitions
     * const count = await prisma.vCreditDefinition.count({
     *   where: {
     *     // ... the filter for the VCreditDefinitions we want to count
     *   }
     * })
    **/
    count<T extends VCreditDefinitionCountArgs>(
      args?: Subset<T, VCreditDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VCreditDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VCreditDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VCreditDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VCreditDefinitionAggregateArgs>(args: Subset<T, VCreditDefinitionAggregateArgs>): Prisma.PrismaPromise<GetVCreditDefinitionAggregateType<T>>

    /**
     * Group by VCreditDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VCreditDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VCreditDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VCreditDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: VCreditDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VCreditDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVCreditDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VCreditDefinition model
   */
  readonly fields: VCreditDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VCreditDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VCreditDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    issuer<T extends IssuerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IssuerDefaultArgs<ExtArgs>>): Prisma__IssuerClient<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    balances<T extends VCreditDefinition$balancesArgs<ExtArgs> = {}>(args?: Subset<T, VCreditDefinition$balancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    policies<T extends VCreditDefinition$policiesArgs<ExtArgs> = {}>(args?: Subset<T, VCreditDefinition$policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    liquidityPool<T extends VCreditDefinition$liquidityPoolArgs<ExtArgs> = {}>(args?: Subset<T, VCreditDefinition$liquidityPoolArgs<ExtArgs>>): Prisma__LiquidityPoolClient<$Result.GetResult<Prisma.$LiquidityPoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VCreditDefinition model
   */
  interface VCreditDefinitionFieldRefs {
    readonly id: FieldRef<"VCreditDefinition", 'String'>
    readonly issuerId: FieldRef<"VCreditDefinition", 'String'>
    readonly name: FieldRef<"VCreditDefinition", 'String'>
    readonly symbol: FieldRef<"VCreditDefinition", 'String'>
    readonly decimals: FieldRef<"VCreditDefinition", 'Int'>
    readonly type: FieldRef<"VCreditDefinition", 'String'>
    readonly exchangeRateBaseUSD: FieldRef<"VCreditDefinition", 'Decimal'>
    readonly createdAt: FieldRef<"VCreditDefinition", 'DateTime'>
    readonly updatedAt: FieldRef<"VCreditDefinition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VCreditDefinition findUnique
   */
  export type VCreditDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which VCreditDefinition to fetch.
     */
    where: VCreditDefinitionWhereUniqueInput
  }

  /**
   * VCreditDefinition findUniqueOrThrow
   */
  export type VCreditDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which VCreditDefinition to fetch.
     */
    where: VCreditDefinitionWhereUniqueInput
  }

  /**
   * VCreditDefinition findFirst
   */
  export type VCreditDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which VCreditDefinition to fetch.
     */
    where?: VCreditDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VCreditDefinitions to fetch.
     */
    orderBy?: VCreditDefinitionOrderByWithRelationInput | VCreditDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VCreditDefinitions.
     */
    cursor?: VCreditDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VCreditDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VCreditDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VCreditDefinitions.
     */
    distinct?: VCreditDefinitionScalarFieldEnum | VCreditDefinitionScalarFieldEnum[]
  }

  /**
   * VCreditDefinition findFirstOrThrow
   */
  export type VCreditDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which VCreditDefinition to fetch.
     */
    where?: VCreditDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VCreditDefinitions to fetch.
     */
    orderBy?: VCreditDefinitionOrderByWithRelationInput | VCreditDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VCreditDefinitions.
     */
    cursor?: VCreditDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VCreditDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VCreditDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VCreditDefinitions.
     */
    distinct?: VCreditDefinitionScalarFieldEnum | VCreditDefinitionScalarFieldEnum[]
  }

  /**
   * VCreditDefinition findMany
   */
  export type VCreditDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which VCreditDefinitions to fetch.
     */
    where?: VCreditDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VCreditDefinitions to fetch.
     */
    orderBy?: VCreditDefinitionOrderByWithRelationInput | VCreditDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VCreditDefinitions.
     */
    cursor?: VCreditDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VCreditDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VCreditDefinitions.
     */
    skip?: number
    distinct?: VCreditDefinitionScalarFieldEnum | VCreditDefinitionScalarFieldEnum[]
  }

  /**
   * VCreditDefinition create
   */
  export type VCreditDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a VCreditDefinition.
     */
    data: XOR<VCreditDefinitionCreateInput, VCreditDefinitionUncheckedCreateInput>
  }

  /**
   * VCreditDefinition createMany
   */
  export type VCreditDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VCreditDefinitions.
     */
    data: VCreditDefinitionCreateManyInput | VCreditDefinitionCreateManyInput[]
  }

  /**
   * VCreditDefinition createManyAndReturn
   */
  export type VCreditDefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * The data used to create many VCreditDefinitions.
     */
    data: VCreditDefinitionCreateManyInput | VCreditDefinitionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VCreditDefinition update
   */
  export type VCreditDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a VCreditDefinition.
     */
    data: XOR<VCreditDefinitionUpdateInput, VCreditDefinitionUncheckedUpdateInput>
    /**
     * Choose, which VCreditDefinition to update.
     */
    where: VCreditDefinitionWhereUniqueInput
  }

  /**
   * VCreditDefinition updateMany
   */
  export type VCreditDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VCreditDefinitions.
     */
    data: XOR<VCreditDefinitionUpdateManyMutationInput, VCreditDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which VCreditDefinitions to update
     */
    where?: VCreditDefinitionWhereInput
    /**
     * Limit how many VCreditDefinitions to update.
     */
    limit?: number
  }

  /**
   * VCreditDefinition updateManyAndReturn
   */
  export type VCreditDefinitionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * The data used to update VCreditDefinitions.
     */
    data: XOR<VCreditDefinitionUpdateManyMutationInput, VCreditDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which VCreditDefinitions to update
     */
    where?: VCreditDefinitionWhereInput
    /**
     * Limit how many VCreditDefinitions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VCreditDefinition upsert
   */
  export type VCreditDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the VCreditDefinition to update in case it exists.
     */
    where: VCreditDefinitionWhereUniqueInput
    /**
     * In case the VCreditDefinition found by the `where` argument doesn't exist, create a new VCreditDefinition with this data.
     */
    create: XOR<VCreditDefinitionCreateInput, VCreditDefinitionUncheckedCreateInput>
    /**
     * In case the VCreditDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VCreditDefinitionUpdateInput, VCreditDefinitionUncheckedUpdateInput>
  }

  /**
   * VCreditDefinition delete
   */
  export type VCreditDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionInclude<ExtArgs> | null
    /**
     * Filter which VCreditDefinition to delete.
     */
    where: VCreditDefinitionWhereUniqueInput
  }

  /**
   * VCreditDefinition deleteMany
   */
  export type VCreditDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VCreditDefinitions to delete
     */
    where?: VCreditDefinitionWhereInput
    /**
     * Limit how many VCreditDefinitions to delete.
     */
    limit?: number
  }

  /**
   * VCreditDefinition.balances
   */
  export type VCreditDefinition$balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    cursor?: BalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * VCreditDefinition.policies
   */
  export type VCreditDefinition$policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    cursor?: PolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * VCreditDefinition.liquidityPool
   */
  export type VCreditDefinition$liquidityPoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolInclude<ExtArgs> | null
    where?: LiquidityPoolWhereInput
  }

  /**
   * VCreditDefinition without action
   */
  export type VCreditDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model LiquidityPool
   */

  export type AggregateLiquidityPool = {
    _count: LiquidityPoolCountAggregateOutputType | null
    _avg: LiquidityPoolAvgAggregateOutputType | null
    _sum: LiquidityPoolSumAggregateOutputType | null
    _min: LiquidityPoolMinAggregateOutputType | null
    _max: LiquidityPoolMaxAggregateOutputType | null
  }

  export type LiquidityPoolAvgAggregateOutputType = {
    balance: Decimal | null
  }

  export type LiquidityPoolSumAggregateOutputType = {
    balance: Decimal | null
  }

  export type LiquidityPoolMinAggregateOutputType = {
    id: string | null
    creditDefId: string | null
    balance: Decimal | null
    currency: string | null
    updatedAt: Date | null
  }

  export type LiquidityPoolMaxAggregateOutputType = {
    id: string | null
    creditDefId: string | null
    balance: Decimal | null
    currency: string | null
    updatedAt: Date | null
  }

  export type LiquidityPoolCountAggregateOutputType = {
    id: number
    creditDefId: number
    balance: number
    currency: number
    updatedAt: number
    _all: number
  }


  export type LiquidityPoolAvgAggregateInputType = {
    balance?: true
  }

  export type LiquidityPoolSumAggregateInputType = {
    balance?: true
  }

  export type LiquidityPoolMinAggregateInputType = {
    id?: true
    creditDefId?: true
    balance?: true
    currency?: true
    updatedAt?: true
  }

  export type LiquidityPoolMaxAggregateInputType = {
    id?: true
    creditDefId?: true
    balance?: true
    currency?: true
    updatedAt?: true
  }

  export type LiquidityPoolCountAggregateInputType = {
    id?: true
    creditDefId?: true
    balance?: true
    currency?: true
    updatedAt?: true
    _all?: true
  }

  export type LiquidityPoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiquidityPool to aggregate.
     */
    where?: LiquidityPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiquidityPools to fetch.
     */
    orderBy?: LiquidityPoolOrderByWithRelationInput | LiquidityPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiquidityPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiquidityPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiquidityPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiquidityPools
    **/
    _count?: true | LiquidityPoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiquidityPoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiquidityPoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiquidityPoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiquidityPoolMaxAggregateInputType
  }

  export type GetLiquidityPoolAggregateType<T extends LiquidityPoolAggregateArgs> = {
        [P in keyof T & keyof AggregateLiquidityPool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiquidityPool[P]>
      : GetScalarType<T[P], AggregateLiquidityPool[P]>
  }




  export type LiquidityPoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiquidityPoolWhereInput
    orderBy?: LiquidityPoolOrderByWithAggregationInput | LiquidityPoolOrderByWithAggregationInput[]
    by: LiquidityPoolScalarFieldEnum[] | LiquidityPoolScalarFieldEnum
    having?: LiquidityPoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiquidityPoolCountAggregateInputType | true
    _avg?: LiquidityPoolAvgAggregateInputType
    _sum?: LiquidityPoolSumAggregateInputType
    _min?: LiquidityPoolMinAggregateInputType
    _max?: LiquidityPoolMaxAggregateInputType
  }

  export type LiquidityPoolGroupByOutputType = {
    id: string
    creditDefId: string
    balance: Decimal
    currency: string
    updatedAt: Date
    _count: LiquidityPoolCountAggregateOutputType | null
    _avg: LiquidityPoolAvgAggregateOutputType | null
    _sum: LiquidityPoolSumAggregateOutputType | null
    _min: LiquidityPoolMinAggregateOutputType | null
    _max: LiquidityPoolMaxAggregateOutputType | null
  }

  type GetLiquidityPoolGroupByPayload<T extends LiquidityPoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiquidityPoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiquidityPoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiquidityPoolGroupByOutputType[P]>
            : GetScalarType<T[P], LiquidityPoolGroupByOutputType[P]>
        }
      >
    >


  export type LiquidityPoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditDefId?: boolean
    balance?: boolean
    currency?: boolean
    updatedAt?: boolean
    creditDef?: boolean | VCreditDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liquidityPool"]>

  export type LiquidityPoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditDefId?: boolean
    balance?: boolean
    currency?: boolean
    updatedAt?: boolean
    creditDef?: boolean | VCreditDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liquidityPool"]>

  export type LiquidityPoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditDefId?: boolean
    balance?: boolean
    currency?: boolean
    updatedAt?: boolean
    creditDef?: boolean | VCreditDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liquidityPool"]>

  export type LiquidityPoolSelectScalar = {
    id?: boolean
    creditDefId?: boolean
    balance?: boolean
    currency?: boolean
    updatedAt?: boolean
  }

  export type LiquidityPoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditDefId" | "balance" | "currency" | "updatedAt", ExtArgs["result"]["liquidityPool"]>
  export type LiquidityPoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditDef?: boolean | VCreditDefinitionDefaultArgs<ExtArgs>
  }
  export type LiquidityPoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditDef?: boolean | VCreditDefinitionDefaultArgs<ExtArgs>
  }
  export type LiquidityPoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditDef?: boolean | VCreditDefinitionDefaultArgs<ExtArgs>
  }

  export type $LiquidityPoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiquidityPool"
    objects: {
      creditDef: Prisma.$VCreditDefinitionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditDefId: string
      balance: Prisma.Decimal
      currency: string
      updatedAt: Date
    }, ExtArgs["result"]["liquidityPool"]>
    composites: {}
  }

  type LiquidityPoolGetPayload<S extends boolean | null | undefined | LiquidityPoolDefaultArgs> = $Result.GetResult<Prisma.$LiquidityPoolPayload, S>

  type LiquidityPoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiquidityPoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiquidityPoolCountAggregateInputType | true
    }

  export interface LiquidityPoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiquidityPool'], meta: { name: 'LiquidityPool' } }
    /**
     * Find zero or one LiquidityPool that matches the filter.
     * @param {LiquidityPoolFindUniqueArgs} args - Arguments to find a LiquidityPool
     * @example
     * // Get one LiquidityPool
     * const liquidityPool = await prisma.liquidityPool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiquidityPoolFindUniqueArgs>(args: SelectSubset<T, LiquidityPoolFindUniqueArgs<ExtArgs>>): Prisma__LiquidityPoolClient<$Result.GetResult<Prisma.$LiquidityPoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LiquidityPool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiquidityPoolFindUniqueOrThrowArgs} args - Arguments to find a LiquidityPool
     * @example
     * // Get one LiquidityPool
     * const liquidityPool = await prisma.liquidityPool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiquidityPoolFindUniqueOrThrowArgs>(args: SelectSubset<T, LiquidityPoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiquidityPoolClient<$Result.GetResult<Prisma.$LiquidityPoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LiquidityPool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidityPoolFindFirstArgs} args - Arguments to find a LiquidityPool
     * @example
     * // Get one LiquidityPool
     * const liquidityPool = await prisma.liquidityPool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiquidityPoolFindFirstArgs>(args?: SelectSubset<T, LiquidityPoolFindFirstArgs<ExtArgs>>): Prisma__LiquidityPoolClient<$Result.GetResult<Prisma.$LiquidityPoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LiquidityPool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidityPoolFindFirstOrThrowArgs} args - Arguments to find a LiquidityPool
     * @example
     * // Get one LiquidityPool
     * const liquidityPool = await prisma.liquidityPool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiquidityPoolFindFirstOrThrowArgs>(args?: SelectSubset<T, LiquidityPoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiquidityPoolClient<$Result.GetResult<Prisma.$LiquidityPoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LiquidityPools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidityPoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiquidityPools
     * const liquidityPools = await prisma.liquidityPool.findMany()
     * 
     * // Get first 10 LiquidityPools
     * const liquidityPools = await prisma.liquidityPool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liquidityPoolWithIdOnly = await prisma.liquidityPool.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiquidityPoolFindManyArgs>(args?: SelectSubset<T, LiquidityPoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiquidityPoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LiquidityPool.
     * @param {LiquidityPoolCreateArgs} args - Arguments to create a LiquidityPool.
     * @example
     * // Create one LiquidityPool
     * const LiquidityPool = await prisma.liquidityPool.create({
     *   data: {
     *     // ... data to create a LiquidityPool
     *   }
     * })
     * 
     */
    create<T extends LiquidityPoolCreateArgs>(args: SelectSubset<T, LiquidityPoolCreateArgs<ExtArgs>>): Prisma__LiquidityPoolClient<$Result.GetResult<Prisma.$LiquidityPoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LiquidityPools.
     * @param {LiquidityPoolCreateManyArgs} args - Arguments to create many LiquidityPools.
     * @example
     * // Create many LiquidityPools
     * const liquidityPool = await prisma.liquidityPool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiquidityPoolCreateManyArgs>(args?: SelectSubset<T, LiquidityPoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiquidityPools and returns the data saved in the database.
     * @param {LiquidityPoolCreateManyAndReturnArgs} args - Arguments to create many LiquidityPools.
     * @example
     * // Create many LiquidityPools
     * const liquidityPool = await prisma.liquidityPool.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiquidityPools and only return the `id`
     * const liquidityPoolWithIdOnly = await prisma.liquidityPool.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiquidityPoolCreateManyAndReturnArgs>(args?: SelectSubset<T, LiquidityPoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiquidityPoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LiquidityPool.
     * @param {LiquidityPoolDeleteArgs} args - Arguments to delete one LiquidityPool.
     * @example
     * // Delete one LiquidityPool
     * const LiquidityPool = await prisma.liquidityPool.delete({
     *   where: {
     *     // ... filter to delete one LiquidityPool
     *   }
     * })
     * 
     */
    delete<T extends LiquidityPoolDeleteArgs>(args: SelectSubset<T, LiquidityPoolDeleteArgs<ExtArgs>>): Prisma__LiquidityPoolClient<$Result.GetResult<Prisma.$LiquidityPoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LiquidityPool.
     * @param {LiquidityPoolUpdateArgs} args - Arguments to update one LiquidityPool.
     * @example
     * // Update one LiquidityPool
     * const liquidityPool = await prisma.liquidityPool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiquidityPoolUpdateArgs>(args: SelectSubset<T, LiquidityPoolUpdateArgs<ExtArgs>>): Prisma__LiquidityPoolClient<$Result.GetResult<Prisma.$LiquidityPoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LiquidityPools.
     * @param {LiquidityPoolDeleteManyArgs} args - Arguments to filter LiquidityPools to delete.
     * @example
     * // Delete a few LiquidityPools
     * const { count } = await prisma.liquidityPool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiquidityPoolDeleteManyArgs>(args?: SelectSubset<T, LiquidityPoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiquidityPools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidityPoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiquidityPools
     * const liquidityPool = await prisma.liquidityPool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiquidityPoolUpdateManyArgs>(args: SelectSubset<T, LiquidityPoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiquidityPools and returns the data updated in the database.
     * @param {LiquidityPoolUpdateManyAndReturnArgs} args - Arguments to update many LiquidityPools.
     * @example
     * // Update many LiquidityPools
     * const liquidityPool = await prisma.liquidityPool.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LiquidityPools and only return the `id`
     * const liquidityPoolWithIdOnly = await prisma.liquidityPool.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiquidityPoolUpdateManyAndReturnArgs>(args: SelectSubset<T, LiquidityPoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiquidityPoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LiquidityPool.
     * @param {LiquidityPoolUpsertArgs} args - Arguments to update or create a LiquidityPool.
     * @example
     * // Update or create a LiquidityPool
     * const liquidityPool = await prisma.liquidityPool.upsert({
     *   create: {
     *     // ... data to create a LiquidityPool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiquidityPool we want to update
     *   }
     * })
     */
    upsert<T extends LiquidityPoolUpsertArgs>(args: SelectSubset<T, LiquidityPoolUpsertArgs<ExtArgs>>): Prisma__LiquidityPoolClient<$Result.GetResult<Prisma.$LiquidityPoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LiquidityPools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidityPoolCountArgs} args - Arguments to filter LiquidityPools to count.
     * @example
     * // Count the number of LiquidityPools
     * const count = await prisma.liquidityPool.count({
     *   where: {
     *     // ... the filter for the LiquidityPools we want to count
     *   }
     * })
    **/
    count<T extends LiquidityPoolCountArgs>(
      args?: Subset<T, LiquidityPoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiquidityPoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiquidityPool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidityPoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiquidityPoolAggregateArgs>(args: Subset<T, LiquidityPoolAggregateArgs>): Prisma.PrismaPromise<GetLiquidityPoolAggregateType<T>>

    /**
     * Group by LiquidityPool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiquidityPoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiquidityPoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiquidityPoolGroupByArgs['orderBy'] }
        : { orderBy?: LiquidityPoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiquidityPoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiquidityPoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiquidityPool model
   */
  readonly fields: LiquidityPoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiquidityPool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiquidityPoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditDef<T extends VCreditDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VCreditDefinitionDefaultArgs<ExtArgs>>): Prisma__VCreditDefinitionClient<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiquidityPool model
   */
  interface LiquidityPoolFieldRefs {
    readonly id: FieldRef<"LiquidityPool", 'String'>
    readonly creditDefId: FieldRef<"LiquidityPool", 'String'>
    readonly balance: FieldRef<"LiquidityPool", 'Decimal'>
    readonly currency: FieldRef<"LiquidityPool", 'String'>
    readonly updatedAt: FieldRef<"LiquidityPool", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LiquidityPool findUnique
   */
  export type LiquidityPoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolInclude<ExtArgs> | null
    /**
     * Filter, which LiquidityPool to fetch.
     */
    where: LiquidityPoolWhereUniqueInput
  }

  /**
   * LiquidityPool findUniqueOrThrow
   */
  export type LiquidityPoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolInclude<ExtArgs> | null
    /**
     * Filter, which LiquidityPool to fetch.
     */
    where: LiquidityPoolWhereUniqueInput
  }

  /**
   * LiquidityPool findFirst
   */
  export type LiquidityPoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolInclude<ExtArgs> | null
    /**
     * Filter, which LiquidityPool to fetch.
     */
    where?: LiquidityPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiquidityPools to fetch.
     */
    orderBy?: LiquidityPoolOrderByWithRelationInput | LiquidityPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiquidityPools.
     */
    cursor?: LiquidityPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiquidityPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiquidityPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiquidityPools.
     */
    distinct?: LiquidityPoolScalarFieldEnum | LiquidityPoolScalarFieldEnum[]
  }

  /**
   * LiquidityPool findFirstOrThrow
   */
  export type LiquidityPoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolInclude<ExtArgs> | null
    /**
     * Filter, which LiquidityPool to fetch.
     */
    where?: LiquidityPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiquidityPools to fetch.
     */
    orderBy?: LiquidityPoolOrderByWithRelationInput | LiquidityPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiquidityPools.
     */
    cursor?: LiquidityPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiquidityPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiquidityPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiquidityPools.
     */
    distinct?: LiquidityPoolScalarFieldEnum | LiquidityPoolScalarFieldEnum[]
  }

  /**
   * LiquidityPool findMany
   */
  export type LiquidityPoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolInclude<ExtArgs> | null
    /**
     * Filter, which LiquidityPools to fetch.
     */
    where?: LiquidityPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiquidityPools to fetch.
     */
    orderBy?: LiquidityPoolOrderByWithRelationInput | LiquidityPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiquidityPools.
     */
    cursor?: LiquidityPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiquidityPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiquidityPools.
     */
    skip?: number
    distinct?: LiquidityPoolScalarFieldEnum | LiquidityPoolScalarFieldEnum[]
  }

  /**
   * LiquidityPool create
   */
  export type LiquidityPoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolInclude<ExtArgs> | null
    /**
     * The data needed to create a LiquidityPool.
     */
    data: XOR<LiquidityPoolCreateInput, LiquidityPoolUncheckedCreateInput>
  }

  /**
   * LiquidityPool createMany
   */
  export type LiquidityPoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiquidityPools.
     */
    data: LiquidityPoolCreateManyInput | LiquidityPoolCreateManyInput[]
  }

  /**
   * LiquidityPool createManyAndReturn
   */
  export type LiquidityPoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * The data used to create many LiquidityPools.
     */
    data: LiquidityPoolCreateManyInput | LiquidityPoolCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiquidityPool update
   */
  export type LiquidityPoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolInclude<ExtArgs> | null
    /**
     * The data needed to update a LiquidityPool.
     */
    data: XOR<LiquidityPoolUpdateInput, LiquidityPoolUncheckedUpdateInput>
    /**
     * Choose, which LiquidityPool to update.
     */
    where: LiquidityPoolWhereUniqueInput
  }

  /**
   * LiquidityPool updateMany
   */
  export type LiquidityPoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiquidityPools.
     */
    data: XOR<LiquidityPoolUpdateManyMutationInput, LiquidityPoolUncheckedUpdateManyInput>
    /**
     * Filter which LiquidityPools to update
     */
    where?: LiquidityPoolWhereInput
    /**
     * Limit how many LiquidityPools to update.
     */
    limit?: number
  }

  /**
   * LiquidityPool updateManyAndReturn
   */
  export type LiquidityPoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * The data used to update LiquidityPools.
     */
    data: XOR<LiquidityPoolUpdateManyMutationInput, LiquidityPoolUncheckedUpdateManyInput>
    /**
     * Filter which LiquidityPools to update
     */
    where?: LiquidityPoolWhereInput
    /**
     * Limit how many LiquidityPools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiquidityPool upsert
   */
  export type LiquidityPoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolInclude<ExtArgs> | null
    /**
     * The filter to search for the LiquidityPool to update in case it exists.
     */
    where: LiquidityPoolWhereUniqueInput
    /**
     * In case the LiquidityPool found by the `where` argument doesn't exist, create a new LiquidityPool with this data.
     */
    create: XOR<LiquidityPoolCreateInput, LiquidityPoolUncheckedCreateInput>
    /**
     * In case the LiquidityPool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiquidityPoolUpdateInput, LiquidityPoolUncheckedUpdateInput>
  }

  /**
   * LiquidityPool delete
   */
  export type LiquidityPoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolInclude<ExtArgs> | null
    /**
     * Filter which LiquidityPool to delete.
     */
    where: LiquidityPoolWhereUniqueInput
  }

  /**
   * LiquidityPool deleteMany
   */
  export type LiquidityPoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiquidityPools to delete
     */
    where?: LiquidityPoolWhereInput
    /**
     * Limit how many LiquidityPools to delete.
     */
    limit?: number
  }

  /**
   * LiquidityPool without action
   */
  export type LiquidityPoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiquidityPool
     */
    select?: LiquidityPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiquidityPool
     */
    omit?: LiquidityPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiquidityPoolInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    userId: string | null
    type: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: WalletCountAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Wallet$userArgs<ExtArgs>
    balances?: boolean | Wallet$balancesArgs<ExtArgs>
    transactions?: boolean | Wallet$transactionsArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Wallet$userArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Wallet$userArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["wallet"]>
  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Wallet$userArgs<ExtArgs>
    balances?: boolean | Wallet$balancesArgs<ExtArgs>
    transactions?: boolean | Wallet$transactionsArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Wallet$userArgs<ExtArgs>
  }
  export type WalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Wallet$userArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      balances: Prisma.$BalancePayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      type: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets and returns the data updated in the database.
     * @param {WalletUpdateManyAndReturnArgs} args - Arguments to update many Wallets.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Wallet$userArgs<ExtArgs> = {}>(args?: Subset<T, Wallet$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    balances<T extends Wallet$balancesArgs<ExtArgs> = {}>(args?: Subset<T, Wallet$balancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Wallet$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Wallet$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly userId: FieldRef<"Wallet", 'String'>
    readonly type: FieldRef<"Wallet", 'String'>
    readonly status: FieldRef<"Wallet", 'String'>
    readonly createdAt: FieldRef<"Wallet", 'DateTime'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallet updateManyAndReturn
   */
  export type WalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to delete.
     */
    limit?: number
  }

  /**
   * Wallet.user
   */
  export type Wallet$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Wallet.balances
   */
  export type Wallet$balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    cursor?: BalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Wallet.transactions
   */
  export type Wallet$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model Balance
   */

  export type AggregateBalance = {
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  export type BalanceAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type BalanceSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type BalanceMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    creditDefId: string | null
    amount: Decimal | null
    updatedAt: Date | null
  }

  export type BalanceMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    creditDefId: string | null
    amount: Decimal | null
    updatedAt: Date | null
  }

  export type BalanceCountAggregateOutputType = {
    id: number
    walletId: number
    creditDefId: number
    amount: number
    updatedAt: number
    _all: number
  }


  export type BalanceAvgAggregateInputType = {
    amount?: true
  }

  export type BalanceSumAggregateInputType = {
    amount?: true
  }

  export type BalanceMinAggregateInputType = {
    id?: true
    walletId?: true
    creditDefId?: true
    amount?: true
    updatedAt?: true
  }

  export type BalanceMaxAggregateInputType = {
    id?: true
    walletId?: true
    creditDefId?: true
    amount?: true
    updatedAt?: true
  }

  export type BalanceCountAggregateInputType = {
    id?: true
    walletId?: true
    creditDefId?: true
    amount?: true
    updatedAt?: true
    _all?: true
  }

  export type BalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balance to aggregate.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Balances
    **/
    _count?: true | BalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalanceMaxAggregateInputType
  }

  export type GetBalanceAggregateType<T extends BalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalance[P]>
      : GetScalarType<T[P], AggregateBalance[P]>
  }




  export type BalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithAggregationInput | BalanceOrderByWithAggregationInput[]
    by: BalanceScalarFieldEnum[] | BalanceScalarFieldEnum
    having?: BalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalanceCountAggregateInputType | true
    _avg?: BalanceAvgAggregateInputType
    _sum?: BalanceSumAggregateInputType
    _min?: BalanceMinAggregateInputType
    _max?: BalanceMaxAggregateInputType
  }

  export type BalanceGroupByOutputType = {
    id: string
    walletId: string
    creditDefId: string
    amount: Decimal
    updatedAt: Date
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  type GetBalanceGroupByPayload<T extends BalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalanceGroupByOutputType[P]>
            : GetScalarType<T[P], BalanceGroupByOutputType[P]>
        }
      >
    >


  export type BalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    creditDefId?: boolean
    amount?: boolean
    updatedAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    creditDef?: boolean | VCreditDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    creditDefId?: boolean
    amount?: boolean
    updatedAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    creditDef?: boolean | VCreditDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    creditDefId?: boolean
    amount?: boolean
    updatedAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    creditDef?: boolean | VCreditDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectScalar = {
    id?: boolean
    walletId?: boolean
    creditDefId?: boolean
    amount?: boolean
    updatedAt?: boolean
  }

  export type BalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletId" | "creditDefId" | "amount" | "updatedAt", ExtArgs["result"]["balance"]>
  export type BalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    creditDef?: boolean | VCreditDefinitionDefaultArgs<ExtArgs>
  }
  export type BalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    creditDef?: boolean | VCreditDefinitionDefaultArgs<ExtArgs>
  }
  export type BalanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    creditDef?: boolean | VCreditDefinitionDefaultArgs<ExtArgs>
  }

  export type $BalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Balance"
    objects: {
      wallet: Prisma.$WalletPayload<ExtArgs>
      creditDef: Prisma.$VCreditDefinitionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletId: string
      creditDefId: string
      amount: Prisma.Decimal
      updatedAt: Date
    }, ExtArgs["result"]["balance"]>
    composites: {}
  }

  type BalanceGetPayload<S extends boolean | null | undefined | BalanceDefaultArgs> = $Result.GetResult<Prisma.$BalancePayload, S>

  type BalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BalanceCountAggregateInputType | true
    }

  export interface BalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Balance'], meta: { name: 'Balance' } }
    /**
     * Find zero or one Balance that matches the filter.
     * @param {BalanceFindUniqueArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BalanceFindUniqueArgs>(args: SelectSubset<T, BalanceFindUniqueArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Balance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BalanceFindUniqueOrThrowArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, BalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BalanceFindFirstArgs>(args?: SelectSubset<T, BalanceFindFirstArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstOrThrowArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, BalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balances
     * const balances = await prisma.balance.findMany()
     * 
     * // Get first 10 Balances
     * const balances = await prisma.balance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balanceWithIdOnly = await prisma.balance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BalanceFindManyArgs>(args?: SelectSubset<T, BalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Balance.
     * @param {BalanceCreateArgs} args - Arguments to create a Balance.
     * @example
     * // Create one Balance
     * const Balance = await prisma.balance.create({
     *   data: {
     *     // ... data to create a Balance
     *   }
     * })
     * 
     */
    create<T extends BalanceCreateArgs>(args: SelectSubset<T, BalanceCreateArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Balances.
     * @param {BalanceCreateManyArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balance = await prisma.balance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BalanceCreateManyArgs>(args?: SelectSubset<T, BalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Balances and returns the data saved in the database.
     * @param {BalanceCreateManyAndReturnArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balance = await prisma.balance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Balances and only return the `id`
     * const balanceWithIdOnly = await prisma.balance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, BalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Balance.
     * @param {BalanceDeleteArgs} args - Arguments to delete one Balance.
     * @example
     * // Delete one Balance
     * const Balance = await prisma.balance.delete({
     *   where: {
     *     // ... filter to delete one Balance
     *   }
     * })
     * 
     */
    delete<T extends BalanceDeleteArgs>(args: SelectSubset<T, BalanceDeleteArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Balance.
     * @param {BalanceUpdateArgs} args - Arguments to update one Balance.
     * @example
     * // Update one Balance
     * const balance = await prisma.balance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BalanceUpdateArgs>(args: SelectSubset<T, BalanceUpdateArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Balances.
     * @param {BalanceDeleteManyArgs} args - Arguments to filter Balances to delete.
     * @example
     * // Delete a few Balances
     * const { count } = await prisma.balance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BalanceDeleteManyArgs>(args?: SelectSubset<T, BalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balances
     * const balance = await prisma.balance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BalanceUpdateManyArgs>(args: SelectSubset<T, BalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances and returns the data updated in the database.
     * @param {BalanceUpdateManyAndReturnArgs} args - Arguments to update many Balances.
     * @example
     * // Update many Balances
     * const balance = await prisma.balance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Balances and only return the `id`
     * const balanceWithIdOnly = await prisma.balance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BalanceUpdateManyAndReturnArgs>(args: SelectSubset<T, BalanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Balance.
     * @param {BalanceUpsertArgs} args - Arguments to update or create a Balance.
     * @example
     * // Update or create a Balance
     * const balance = await prisma.balance.upsert({
     *   create: {
     *     // ... data to create a Balance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balance we want to update
     *   }
     * })
     */
    upsert<T extends BalanceUpsertArgs>(args: SelectSubset<T, BalanceUpsertArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceCountArgs} args - Arguments to filter Balances to count.
     * @example
     * // Count the number of Balances
     * const count = await prisma.balance.count({
     *   where: {
     *     // ... the filter for the Balances we want to count
     *   }
     * })
    **/
    count<T extends BalanceCountArgs>(
      args?: Subset<T, BalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalanceAggregateArgs>(args: Subset<T, BalanceAggregateArgs>): Prisma.PrismaPromise<GetBalanceAggregateType<T>>

    /**
     * Group by Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalanceGroupByArgs['orderBy'] }
        : { orderBy?: BalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Balance model
   */
  readonly fields: BalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Balance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallet<T extends WalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletDefaultArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creditDef<T extends VCreditDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VCreditDefinitionDefaultArgs<ExtArgs>>): Prisma__VCreditDefinitionClient<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Balance model
   */
  interface BalanceFieldRefs {
    readonly id: FieldRef<"Balance", 'String'>
    readonly walletId: FieldRef<"Balance", 'String'>
    readonly creditDefId: FieldRef<"Balance", 'String'>
    readonly amount: FieldRef<"Balance", 'Decimal'>
    readonly updatedAt: FieldRef<"Balance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Balance findUnique
   */
  export type BalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance findUniqueOrThrow
   */
  export type BalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance findFirst
   */
  export type BalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance findFirstOrThrow
   */
  export type BalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance findMany
   */
  export type BalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance create
   */
  export type BalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Balance.
     */
    data: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
  }

  /**
   * Balance createMany
   */
  export type BalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Balances.
     */
    data: BalanceCreateManyInput | BalanceCreateManyInput[]
  }

  /**
   * Balance createManyAndReturn
   */
  export type BalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * The data used to create many Balances.
     */
    data: BalanceCreateManyInput | BalanceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Balance update
   */
  export type BalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Balance.
     */
    data: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
    /**
     * Choose, which Balance to update.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance updateMany
   */
  export type BalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Balances.
     */
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyInput>
    /**
     * Filter which Balances to update
     */
    where?: BalanceWhereInput
    /**
     * Limit how many Balances to update.
     */
    limit?: number
  }

  /**
   * Balance updateManyAndReturn
   */
  export type BalanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * The data used to update Balances.
     */
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyInput>
    /**
     * Filter which Balances to update
     */
    where?: BalanceWhereInput
    /**
     * Limit how many Balances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Balance upsert
   */
  export type BalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Balance to update in case it exists.
     */
    where: BalanceWhereUniqueInput
    /**
     * In case the Balance found by the `where` argument doesn't exist, create a new Balance with this data.
     */
    create: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
    /**
     * In case the Balance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
  }

  /**
   * Balance delete
   */
  export type BalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter which Balance to delete.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance deleteMany
   */
  export type BalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balances to delete
     */
    where?: BalanceWhereInput
    /**
     * Limit how many Balances to delete.
     */
    limit?: number
  }

  /**
   * Balance without action
   */
  export type BalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    referenceRef: string | null
    type: string | null
    status: string | null
    senderWalletId: string | null
    recipientWalletId: string | null
    metadata: string | null
    policyLogId: string | null
    createdAt: Date | null
    finalizedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    referenceRef: string | null
    type: string | null
    status: string | null
    senderWalletId: string | null
    recipientWalletId: string | null
    metadata: string | null
    policyLogId: string | null
    createdAt: Date | null
    finalizedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    referenceRef: number
    type: number
    status: number
    senderWalletId: number
    recipientWalletId: number
    metadata: number
    policyLogId: number
    createdAt: number
    finalizedAt: number
    _all: number
  }


  export type TransactionMinAggregateInputType = {
    id?: true
    referenceRef?: true
    type?: true
    status?: true
    senderWalletId?: true
    recipientWalletId?: true
    metadata?: true
    policyLogId?: true
    createdAt?: true
    finalizedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    referenceRef?: true
    type?: true
    status?: true
    senderWalletId?: true
    recipientWalletId?: true
    metadata?: true
    policyLogId?: true
    createdAt?: true
    finalizedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    referenceRef?: true
    type?: true
    status?: true
    senderWalletId?: true
    recipientWalletId?: true
    metadata?: true
    policyLogId?: true
    createdAt?: true
    finalizedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    referenceRef: string | null
    type: string
    status: string
    senderWalletId: string | null
    recipientWalletId: string | null
    metadata: string | null
    policyLogId: string | null
    createdAt: Date
    finalizedAt: Date | null
    _count: TransactionCountAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceRef?: boolean
    type?: boolean
    status?: boolean
    senderWalletId?: boolean
    recipientWalletId?: boolean
    metadata?: boolean
    policyLogId?: boolean
    createdAt?: boolean
    finalizedAt?: boolean
    senderWallet?: boolean | Transaction$senderWalletArgs<ExtArgs>
    policyLog?: boolean | Transaction$policyLogArgs<ExtArgs>
    ledgerEntries?: boolean | Transaction$ledgerEntriesArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceRef?: boolean
    type?: boolean
    status?: boolean
    senderWalletId?: boolean
    recipientWalletId?: boolean
    metadata?: boolean
    policyLogId?: boolean
    createdAt?: boolean
    finalizedAt?: boolean
    senderWallet?: boolean | Transaction$senderWalletArgs<ExtArgs>
    policyLog?: boolean | Transaction$policyLogArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceRef?: boolean
    type?: boolean
    status?: boolean
    senderWalletId?: boolean
    recipientWalletId?: boolean
    metadata?: boolean
    policyLogId?: boolean
    createdAt?: boolean
    finalizedAt?: boolean
    senderWallet?: boolean | Transaction$senderWalletArgs<ExtArgs>
    policyLog?: boolean | Transaction$policyLogArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    referenceRef?: boolean
    type?: boolean
    status?: boolean
    senderWalletId?: boolean
    recipientWalletId?: boolean
    metadata?: boolean
    policyLogId?: boolean
    createdAt?: boolean
    finalizedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referenceRef" | "type" | "status" | "senderWalletId" | "recipientWalletId" | "metadata" | "policyLogId" | "createdAt" | "finalizedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    senderWallet?: boolean | Transaction$senderWalletArgs<ExtArgs>
    policyLog?: boolean | Transaction$policyLogArgs<ExtArgs>
    ledgerEntries?: boolean | Transaction$ledgerEntriesArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    senderWallet?: boolean | Transaction$senderWalletArgs<ExtArgs>
    policyLog?: boolean | Transaction$policyLogArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    senderWallet?: boolean | Transaction$senderWalletArgs<ExtArgs>
    policyLog?: boolean | Transaction$policyLogArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      senderWallet: Prisma.$WalletPayload<ExtArgs> | null
      policyLog: Prisma.$PolicyEvaluationLogPayload<ExtArgs> | null
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referenceRef: string | null
      type: string
      status: string
      senderWalletId: string | null
      recipientWalletId: string | null
      metadata: string | null
      policyLogId: string | null
      createdAt: Date
      finalizedAt: Date | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    senderWallet<T extends Transaction$senderWalletArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$senderWalletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    policyLog<T extends Transaction$policyLogArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$policyLogArgs<ExtArgs>>): Prisma__PolicyEvaluationLogClient<$Result.GetResult<Prisma.$PolicyEvaluationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ledgerEntries<T extends Transaction$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly referenceRef: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly senderWalletId: FieldRef<"Transaction", 'String'>
    readonly recipientWalletId: FieldRef<"Transaction", 'String'>
    readonly metadata: FieldRef<"Transaction", 'String'>
    readonly policyLogId: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly finalizedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.senderWallet
   */
  export type Transaction$senderWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * Transaction.policyLog
   */
  export type Transaction$policyLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyEvaluationLogInclude<ExtArgs> | null
    where?: PolicyEvaluationLogWhereInput
  }

  /**
   * Transaction.ledgerEntries
   */
  export type Transaction$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model LedgerEntry
   */

  export type AggregateLedgerEntry = {
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  export type LedgerEntryAvgAggregateOutputType = {
    amount: Decimal | null
    balanceAfter: Decimal | null
  }

  export type LedgerEntrySumAggregateOutputType = {
    amount: Decimal | null
    balanceAfter: Decimal | null
  }

  export type LedgerEntryMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    walletId: string | null
    creditDefId: string | null
    direction: string | null
    amount: Decimal | null
    balanceAfter: Decimal | null
    createdAt: Date | null
  }

  export type LedgerEntryMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    walletId: string | null
    creditDefId: string | null
    direction: string | null
    amount: Decimal | null
    balanceAfter: Decimal | null
    createdAt: Date | null
  }

  export type LedgerEntryCountAggregateOutputType = {
    id: number
    transactionId: number
    walletId: number
    creditDefId: number
    direction: number
    amount: number
    balanceAfter: number
    createdAt: number
    _all: number
  }


  export type LedgerEntryAvgAggregateInputType = {
    amount?: true
    balanceAfter?: true
  }

  export type LedgerEntrySumAggregateInputType = {
    amount?: true
    balanceAfter?: true
  }

  export type LedgerEntryMinAggregateInputType = {
    id?: true
    transactionId?: true
    walletId?: true
    creditDefId?: true
    direction?: true
    amount?: true
    balanceAfter?: true
    createdAt?: true
  }

  export type LedgerEntryMaxAggregateInputType = {
    id?: true
    transactionId?: true
    walletId?: true
    creditDefId?: true
    direction?: true
    amount?: true
    balanceAfter?: true
    createdAt?: true
  }

  export type LedgerEntryCountAggregateInputType = {
    id?: true
    transactionId?: true
    walletId?: true
    creditDefId?: true
    direction?: true
    amount?: true
    balanceAfter?: true
    createdAt?: true
    _all?: true
  }

  export type LedgerEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntry to aggregate.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LedgerEntries
    **/
    _count?: true | LedgerEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type GetLedgerEntryAggregateType<T extends LedgerEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLedgerEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedgerEntry[P]>
      : GetScalarType<T[P], AggregateLedgerEntry[P]>
  }




  export type LedgerEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithAggregationInput | LedgerEntryOrderByWithAggregationInput[]
    by: LedgerEntryScalarFieldEnum[] | LedgerEntryScalarFieldEnum
    having?: LedgerEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerEntryCountAggregateInputType | true
    _avg?: LedgerEntryAvgAggregateInputType
    _sum?: LedgerEntrySumAggregateInputType
    _min?: LedgerEntryMinAggregateInputType
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type LedgerEntryGroupByOutputType = {
    id: string
    transactionId: string
    walletId: string
    creditDefId: string
    direction: string
    amount: Decimal
    balanceAfter: Decimal
    createdAt: Date
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  type GetLedgerEntryGroupByPayload<T extends LedgerEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
        }
      >
    >


  export type LedgerEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    walletId?: boolean
    creditDefId?: boolean
    direction?: boolean
    amount?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    walletId?: boolean
    creditDefId?: boolean
    direction?: boolean
    amount?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    walletId?: boolean
    creditDefId?: boolean
    direction?: boolean
    amount?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectScalar = {
    id?: boolean
    transactionId?: boolean
    walletId?: boolean
    creditDefId?: boolean
    direction?: boolean
    amount?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
  }

  export type LedgerEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "walletId" | "creditDefId" | "direction" | "amount" | "balanceAfter" | "createdAt", ExtArgs["result"]["ledgerEntry"]>
  export type LedgerEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type LedgerEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type LedgerEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $LedgerEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LedgerEntry"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      walletId: string
      creditDefId: string
      direction: string
      amount: Prisma.Decimal
      balanceAfter: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["ledgerEntry"]>
    composites: {}
  }

  type LedgerEntryGetPayload<S extends boolean | null | undefined | LedgerEntryDefaultArgs> = $Result.GetResult<Prisma.$LedgerEntryPayload, S>

  type LedgerEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LedgerEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LedgerEntryCountAggregateInputType | true
    }

  export interface LedgerEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LedgerEntry'], meta: { name: 'LedgerEntry' } }
    /**
     * Find zero or one LedgerEntry that matches the filter.
     * @param {LedgerEntryFindUniqueArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerEntryFindUniqueArgs>(args: SelectSubset<T, LedgerEntryFindUniqueArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LedgerEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LedgerEntryFindUniqueOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LedgerEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerEntryFindFirstArgs>(args?: SelectSubset<T, LedgerEntryFindFirstArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LedgerEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LedgerEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany()
     * 
     * // Get first 10 LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerEntryFindManyArgs>(args?: SelectSubset<T, LedgerEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LedgerEntry.
     * @param {LedgerEntryCreateArgs} args - Arguments to create a LedgerEntry.
     * @example
     * // Create one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.create({
     *   data: {
     *     // ... data to create a LedgerEntry
     *   }
     * })
     * 
     */
    create<T extends LedgerEntryCreateArgs>(args: SelectSubset<T, LedgerEntryCreateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LedgerEntries.
     * @param {LedgerEntryCreateManyArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerEntryCreateManyArgs>(args?: SelectSubset<T, LedgerEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LedgerEntries and returns the data saved in the database.
     * @param {LedgerEntryCreateManyAndReturnArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LedgerEntries and only return the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LedgerEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LedgerEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LedgerEntry.
     * @param {LedgerEntryDeleteArgs} args - Arguments to delete one LedgerEntry.
     * @example
     * // Delete one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.delete({
     *   where: {
     *     // ... filter to delete one LedgerEntry
     *   }
     * })
     * 
     */
    delete<T extends LedgerEntryDeleteArgs>(args: SelectSubset<T, LedgerEntryDeleteArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LedgerEntry.
     * @param {LedgerEntryUpdateArgs} args - Arguments to update one LedgerEntry.
     * @example
     * // Update one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerEntryUpdateArgs>(args: SelectSubset<T, LedgerEntryUpdateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LedgerEntries.
     * @param {LedgerEntryDeleteManyArgs} args - Arguments to filter LedgerEntries to delete.
     * @example
     * // Delete a few LedgerEntries
     * const { count } = await prisma.ledgerEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerEntryDeleteManyArgs>(args?: SelectSubset<T, LedgerEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerEntryUpdateManyArgs>(args: SelectSubset<T, LedgerEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerEntries and returns the data updated in the database.
     * @param {LedgerEntryUpdateManyAndReturnArgs} args - Arguments to update many LedgerEntries.
     * @example
     * // Update many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LedgerEntries and only return the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LedgerEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, LedgerEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LedgerEntry.
     * @param {LedgerEntryUpsertArgs} args - Arguments to update or create a LedgerEntry.
     * @example
     * // Update or create a LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.upsert({
     *   create: {
     *     // ... data to create a LedgerEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LedgerEntry we want to update
     *   }
     * })
     */
    upsert<T extends LedgerEntryUpsertArgs>(args: SelectSubset<T, LedgerEntryUpsertArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryCountArgs} args - Arguments to filter LedgerEntries to count.
     * @example
     * // Count the number of LedgerEntries
     * const count = await prisma.ledgerEntry.count({
     *   where: {
     *     // ... the filter for the LedgerEntries we want to count
     *   }
     * })
    **/
    count<T extends LedgerEntryCountArgs>(
      args?: Subset<T, LedgerEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerEntryAggregateArgs>(args: Subset<T, LedgerEntryAggregateArgs>): Prisma.PrismaPromise<GetLedgerEntryAggregateType<T>>

    /**
     * Group by LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerEntryGroupByArgs['orderBy'] }
        : { orderBy?: LedgerEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LedgerEntry model
   */
  readonly fields: LedgerEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LedgerEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LedgerEntry model
   */
  interface LedgerEntryFieldRefs {
    readonly id: FieldRef<"LedgerEntry", 'String'>
    readonly transactionId: FieldRef<"LedgerEntry", 'String'>
    readonly walletId: FieldRef<"LedgerEntry", 'String'>
    readonly creditDefId: FieldRef<"LedgerEntry", 'String'>
    readonly direction: FieldRef<"LedgerEntry", 'String'>
    readonly amount: FieldRef<"LedgerEntry", 'Decimal'>
    readonly balanceAfter: FieldRef<"LedgerEntry", 'Decimal'>
    readonly createdAt: FieldRef<"LedgerEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LedgerEntry findUnique
   */
  export type LedgerEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findUniqueOrThrow
   */
  export type LedgerEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findFirst
   */
  export type LedgerEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findFirstOrThrow
   */
  export type LedgerEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findMany
   */
  export type LedgerEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntries to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry create
   */
  export type LedgerEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LedgerEntry.
     */
    data: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
  }

  /**
   * LedgerEntry createMany
   */
  export type LedgerEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
  }

  /**
   * LedgerEntry createManyAndReturn
   */
  export type LedgerEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LedgerEntry update
   */
  export type LedgerEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LedgerEntry.
     */
    data: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
    /**
     * Choose, which LedgerEntry to update.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry updateMany
   */
  export type LedgerEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LedgerEntries.
     */
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which LedgerEntries to update
     */
    where?: LedgerEntryWhereInput
    /**
     * Limit how many LedgerEntries to update.
     */
    limit?: number
  }

  /**
   * LedgerEntry updateManyAndReturn
   */
  export type LedgerEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to update LedgerEntries.
     */
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which LedgerEntries to update
     */
    where?: LedgerEntryWhereInput
    /**
     * Limit how many LedgerEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LedgerEntry upsert
   */
  export type LedgerEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LedgerEntry to update in case it exists.
     */
    where: LedgerEntryWhereUniqueInput
    /**
     * In case the LedgerEntry found by the `where` argument doesn't exist, create a new LedgerEntry with this data.
     */
    create: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
    /**
     * In case the LedgerEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
  }

  /**
   * LedgerEntry delete
   */
  export type LedgerEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter which LedgerEntry to delete.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry deleteMany
   */
  export type LedgerEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntries to delete
     */
    where?: LedgerEntryWhereInput
    /**
     * Limit how many LedgerEntries to delete.
     */
    limit?: number
  }

  /**
   * LedgerEntry without action
   */
  export type LedgerEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
  }


  /**
   * Model Policy
   */

  export type AggregatePolicy = {
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  export type PolicyAvgAggregateOutputType = {
    priority: number | null
  }

  export type PolicySumAggregateOutputType = {
    priority: number | null
  }

  export type PolicyMinAggregateOutputType = {
    id: string | null
    issuerId: string | null
    creditDefId: string | null
    name: string | null
    description: string | null
    ruleType: string | null
    parameters: string | null
    isActive: boolean | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PolicyMaxAggregateOutputType = {
    id: string | null
    issuerId: string | null
    creditDefId: string | null
    name: string | null
    description: string | null
    ruleType: string | null
    parameters: string | null
    isActive: boolean | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PolicyCountAggregateOutputType = {
    id: number
    issuerId: number
    creditDefId: number
    name: number
    description: number
    ruleType: number
    parameters: number
    isActive: number
    priority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PolicyAvgAggregateInputType = {
    priority?: true
  }

  export type PolicySumAggregateInputType = {
    priority?: true
  }

  export type PolicyMinAggregateInputType = {
    id?: true
    issuerId?: true
    creditDefId?: true
    name?: true
    description?: true
    ruleType?: true
    parameters?: true
    isActive?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PolicyMaxAggregateInputType = {
    id?: true
    issuerId?: true
    creditDefId?: true
    name?: true
    description?: true
    ruleType?: true
    parameters?: true
    isActive?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PolicyCountAggregateInputType = {
    id?: true
    issuerId?: true
    creditDefId?: true
    name?: true
    description?: true
    ruleType?: true
    parameters?: true
    isActive?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policy to aggregate.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Policies
    **/
    _count?: true | PolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyMaxAggregateInputType
  }

  export type GetPolicyAggregateType<T extends PolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicy[P]>
      : GetScalarType<T[P], AggregatePolicy[P]>
  }




  export type PolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithAggregationInput | PolicyOrderByWithAggregationInput[]
    by: PolicyScalarFieldEnum[] | PolicyScalarFieldEnum
    having?: PolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyCountAggregateInputType | true
    _avg?: PolicyAvgAggregateInputType
    _sum?: PolicySumAggregateInputType
    _min?: PolicyMinAggregateInputType
    _max?: PolicyMaxAggregateInputType
  }

  export type PolicyGroupByOutputType = {
    id: string
    issuerId: string | null
    creditDefId: string | null
    name: string
    description: string | null
    ruleType: string
    parameters: string
    isActive: boolean
    priority: number
    createdAt: Date
    updatedAt: Date
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  type GetPolicyGroupByPayload<T extends PolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyGroupByOutputType[P]>
        }
      >
    >


  export type PolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issuerId?: boolean
    creditDefId?: boolean
    name?: boolean
    description?: boolean
    ruleType?: boolean
    parameters?: boolean
    isActive?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    issuer?: boolean | Policy$issuerArgs<ExtArgs>
    creditDef?: boolean | Policy$creditDefArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issuerId?: boolean
    creditDefId?: boolean
    name?: boolean
    description?: boolean
    ruleType?: boolean
    parameters?: boolean
    isActive?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    issuer?: boolean | Policy$issuerArgs<ExtArgs>
    creditDef?: boolean | Policy$creditDefArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issuerId?: boolean
    creditDefId?: boolean
    name?: boolean
    description?: boolean
    ruleType?: boolean
    parameters?: boolean
    isActive?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    issuer?: boolean | Policy$issuerArgs<ExtArgs>
    creditDef?: boolean | Policy$creditDefArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectScalar = {
    id?: boolean
    issuerId?: boolean
    creditDefId?: boolean
    name?: boolean
    description?: boolean
    ruleType?: boolean
    parameters?: boolean
    isActive?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "issuerId" | "creditDefId" | "name" | "description" | "ruleType" | "parameters" | "isActive" | "priority" | "createdAt" | "updatedAt", ExtArgs["result"]["policy"]>
  export type PolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | Policy$issuerArgs<ExtArgs>
    creditDef?: boolean | Policy$creditDefArgs<ExtArgs>
  }
  export type PolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | Policy$issuerArgs<ExtArgs>
    creditDef?: boolean | Policy$creditDefArgs<ExtArgs>
  }
  export type PolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | Policy$issuerArgs<ExtArgs>
    creditDef?: boolean | Policy$creditDefArgs<ExtArgs>
  }

  export type $PolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Policy"
    objects: {
      issuer: Prisma.$IssuerPayload<ExtArgs> | null
      creditDef: Prisma.$VCreditDefinitionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      issuerId: string | null
      creditDefId: string | null
      name: string
      description: string | null
      ruleType: string
      parameters: string
      isActive: boolean
      priority: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["policy"]>
    composites: {}
  }

  type PolicyGetPayload<S extends boolean | null | undefined | PolicyDefaultArgs> = $Result.GetResult<Prisma.$PolicyPayload, S>

  type PolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PolicyCountAggregateInputType | true
    }

  export interface PolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Policy'], meta: { name: 'Policy' } }
    /**
     * Find zero or one Policy that matches the filter.
     * @param {PolicyFindUniqueArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyFindUniqueArgs>(args: SelectSubset<T, PolicyFindUniqueArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Policy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PolicyFindUniqueOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Policy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyFindFirstArgs>(args?: SelectSubset<T, PolicyFindFirstArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Policy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policies
     * const policies = await prisma.policy.findMany()
     * 
     * // Get first 10 Policies
     * const policies = await prisma.policy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyWithIdOnly = await prisma.policy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PolicyFindManyArgs>(args?: SelectSubset<T, PolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Policy.
     * @param {PolicyCreateArgs} args - Arguments to create a Policy.
     * @example
     * // Create one Policy
     * const Policy = await prisma.policy.create({
     *   data: {
     *     // ... data to create a Policy
     *   }
     * })
     * 
     */
    create<T extends PolicyCreateArgs>(args: SelectSubset<T, PolicyCreateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Policies.
     * @param {PolicyCreateManyArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyCreateManyArgs>(args?: SelectSubset<T, PolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Policies and returns the data saved in the database.
     * @param {PolicyCreateManyAndReturnArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Policies and only return the `id`
     * const policyWithIdOnly = await prisma.policy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, PolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Policy.
     * @param {PolicyDeleteArgs} args - Arguments to delete one Policy.
     * @example
     * // Delete one Policy
     * const Policy = await prisma.policy.delete({
     *   where: {
     *     // ... filter to delete one Policy
     *   }
     * })
     * 
     */
    delete<T extends PolicyDeleteArgs>(args: SelectSubset<T, PolicyDeleteArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Policy.
     * @param {PolicyUpdateArgs} args - Arguments to update one Policy.
     * @example
     * // Update one Policy
     * const policy = await prisma.policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyUpdateArgs>(args: SelectSubset<T, PolicyUpdateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Policies.
     * @param {PolicyDeleteManyArgs} args - Arguments to filter Policies to delete.
     * @example
     * // Delete a few Policies
     * const { count } = await prisma.policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyDeleteManyArgs>(args?: SelectSubset<T, PolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyUpdateManyArgs>(args: SelectSubset<T, PolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies and returns the data updated in the database.
     * @param {PolicyUpdateManyAndReturnArgs} args - Arguments to update many Policies.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Policies and only return the `id`
     * const policyWithIdOnly = await prisma.policy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, PolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Policy.
     * @param {PolicyUpsertArgs} args - Arguments to update or create a Policy.
     * @example
     * // Update or create a Policy
     * const policy = await prisma.policy.upsert({
     *   create: {
     *     // ... data to create a Policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policy we want to update
     *   }
     * })
     */
    upsert<T extends PolicyUpsertArgs>(args: SelectSubset<T, PolicyUpsertArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyCountArgs} args - Arguments to filter Policies to count.
     * @example
     * // Count the number of Policies
     * const count = await prisma.policy.count({
     *   where: {
     *     // ... the filter for the Policies we want to count
     *   }
     * })
    **/
    count<T extends PolicyCountArgs>(
      args?: Subset<T, PolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyAggregateArgs>(args: Subset<T, PolicyAggregateArgs>): Prisma.PrismaPromise<GetPolicyAggregateType<T>>

    /**
     * Group by Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyGroupByArgs['orderBy'] }
        : { orderBy?: PolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Policy model
   */
  readonly fields: PolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    issuer<T extends Policy$issuerArgs<ExtArgs> = {}>(args?: Subset<T, Policy$issuerArgs<ExtArgs>>): Prisma__IssuerClient<$Result.GetResult<Prisma.$IssuerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creditDef<T extends Policy$creditDefArgs<ExtArgs> = {}>(args?: Subset<T, Policy$creditDefArgs<ExtArgs>>): Prisma__VCreditDefinitionClient<$Result.GetResult<Prisma.$VCreditDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Policy model
   */
  interface PolicyFieldRefs {
    readonly id: FieldRef<"Policy", 'String'>
    readonly issuerId: FieldRef<"Policy", 'String'>
    readonly creditDefId: FieldRef<"Policy", 'String'>
    readonly name: FieldRef<"Policy", 'String'>
    readonly description: FieldRef<"Policy", 'String'>
    readonly ruleType: FieldRef<"Policy", 'String'>
    readonly parameters: FieldRef<"Policy", 'String'>
    readonly isActive: FieldRef<"Policy", 'Boolean'>
    readonly priority: FieldRef<"Policy", 'Int'>
    readonly createdAt: FieldRef<"Policy", 'DateTime'>
    readonly updatedAt: FieldRef<"Policy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Policy findUnique
   */
  export type PolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findUniqueOrThrow
   */
  export type PolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findFirst
   */
  export type PolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findFirstOrThrow
   */
  export type PolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findMany
   */
  export type PolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policies to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy create
   */
  export type PolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a Policy.
     */
    data: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
  }

  /**
   * Policy createMany
   */
  export type PolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
  }

  /**
   * Policy createManyAndReturn
   */
  export type PolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Policy update
   */
  export type PolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a Policy.
     */
    data: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
    /**
     * Choose, which Policy to update.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy updateMany
   */
  export type PolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Policies.
     */
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     */
    where?: PolicyWhereInput
    /**
     * Limit how many Policies to update.
     */
    limit?: number
  }

  /**
   * Policy updateManyAndReturn
   */
  export type PolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * The data used to update Policies.
     */
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     */
    where?: PolicyWhereInput
    /**
     * Limit how many Policies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Policy upsert
   */
  export type PolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the Policy to update in case it exists.
     */
    where: PolicyWhereUniqueInput
    /**
     * In case the Policy found by the `where` argument doesn't exist, create a new Policy with this data.
     */
    create: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
    /**
     * In case the Policy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
  }

  /**
   * Policy delete
   */
  export type PolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter which Policy to delete.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy deleteMany
   */
  export type PolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policies to delete
     */
    where?: PolicyWhereInput
    /**
     * Limit how many Policies to delete.
     */
    limit?: number
  }

  /**
   * Policy.issuer
   */
  export type Policy$issuerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issuer
     */
    select?: IssuerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issuer
     */
    omit?: IssuerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssuerInclude<ExtArgs> | null
    where?: IssuerWhereInput
  }

  /**
   * Policy.creditDef
   */
  export type Policy$creditDefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VCreditDefinition
     */
    select?: VCreditDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VCreditDefinition
     */
    omit?: VCreditDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VCreditDefinitionInclude<ExtArgs> | null
    where?: VCreditDefinitionWhereInput
  }

  /**
   * Policy without action
   */
  export type PolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Policy
     */
    omit?: PolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
  }


  /**
   * Model PolicyEvaluationLog
   */

  export type AggregatePolicyEvaluationLog = {
    _count: PolicyEvaluationLogCountAggregateOutputType | null
    _min: PolicyEvaluationLogMinAggregateOutputType | null
    _max: PolicyEvaluationLogMaxAggregateOutputType | null
  }

  export type PolicyEvaluationLogMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    decision: string | null
    results: string | null
    createdAt: Date | null
  }

  export type PolicyEvaluationLogMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    decision: string | null
    results: string | null
    createdAt: Date | null
  }

  export type PolicyEvaluationLogCountAggregateOutputType = {
    id: number
    transactionId: number
    decision: number
    results: number
    createdAt: number
    _all: number
  }


  export type PolicyEvaluationLogMinAggregateInputType = {
    id?: true
    transactionId?: true
    decision?: true
    results?: true
    createdAt?: true
  }

  export type PolicyEvaluationLogMaxAggregateInputType = {
    id?: true
    transactionId?: true
    decision?: true
    results?: true
    createdAt?: true
  }

  export type PolicyEvaluationLogCountAggregateInputType = {
    id?: true
    transactionId?: true
    decision?: true
    results?: true
    createdAt?: true
    _all?: true
  }

  export type PolicyEvaluationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PolicyEvaluationLog to aggregate.
     */
    where?: PolicyEvaluationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyEvaluationLogs to fetch.
     */
    orderBy?: PolicyEvaluationLogOrderByWithRelationInput | PolicyEvaluationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyEvaluationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyEvaluationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyEvaluationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PolicyEvaluationLogs
    **/
    _count?: true | PolicyEvaluationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyEvaluationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyEvaluationLogMaxAggregateInputType
  }

  export type GetPolicyEvaluationLogAggregateType<T extends PolicyEvaluationLogAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicyEvaluationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicyEvaluationLog[P]>
      : GetScalarType<T[P], AggregatePolicyEvaluationLog[P]>
  }




  export type PolicyEvaluationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyEvaluationLogWhereInput
    orderBy?: PolicyEvaluationLogOrderByWithAggregationInput | PolicyEvaluationLogOrderByWithAggregationInput[]
    by: PolicyEvaluationLogScalarFieldEnum[] | PolicyEvaluationLogScalarFieldEnum
    having?: PolicyEvaluationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyEvaluationLogCountAggregateInputType | true
    _min?: PolicyEvaluationLogMinAggregateInputType
    _max?: PolicyEvaluationLogMaxAggregateInputType
  }

  export type PolicyEvaluationLogGroupByOutputType = {
    id: string
    transactionId: string | null
    decision: string
    results: string
    createdAt: Date
    _count: PolicyEvaluationLogCountAggregateOutputType | null
    _min: PolicyEvaluationLogMinAggregateOutputType | null
    _max: PolicyEvaluationLogMaxAggregateOutputType | null
  }

  type GetPolicyEvaluationLogGroupByPayload<T extends PolicyEvaluationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyEvaluationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyEvaluationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyEvaluationLogGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyEvaluationLogGroupByOutputType[P]>
        }
      >
    >


  export type PolicyEvaluationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    decision?: boolean
    results?: boolean
    createdAt?: boolean
    transactions?: boolean | PolicyEvaluationLog$transactionsArgs<ExtArgs>
    _count?: boolean | PolicyEvaluationLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policyEvaluationLog"]>

  export type PolicyEvaluationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    decision?: boolean
    results?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["policyEvaluationLog"]>

  export type PolicyEvaluationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    decision?: boolean
    results?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["policyEvaluationLog"]>

  export type PolicyEvaluationLogSelectScalar = {
    id?: boolean
    transactionId?: boolean
    decision?: boolean
    results?: boolean
    createdAt?: boolean
  }

  export type PolicyEvaluationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "decision" | "results" | "createdAt", ExtArgs["result"]["policyEvaluationLog"]>
  export type PolicyEvaluationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | PolicyEvaluationLog$transactionsArgs<ExtArgs>
    _count?: boolean | PolicyEvaluationLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PolicyEvaluationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PolicyEvaluationLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PolicyEvaluationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PolicyEvaluationLog"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string | null
      decision: string
      results: string
      createdAt: Date
    }, ExtArgs["result"]["policyEvaluationLog"]>
    composites: {}
  }

  type PolicyEvaluationLogGetPayload<S extends boolean | null | undefined | PolicyEvaluationLogDefaultArgs> = $Result.GetResult<Prisma.$PolicyEvaluationLogPayload, S>

  type PolicyEvaluationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PolicyEvaluationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PolicyEvaluationLogCountAggregateInputType | true
    }

  export interface PolicyEvaluationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PolicyEvaluationLog'], meta: { name: 'PolicyEvaluationLog' } }
    /**
     * Find zero or one PolicyEvaluationLog that matches the filter.
     * @param {PolicyEvaluationLogFindUniqueArgs} args - Arguments to find a PolicyEvaluationLog
     * @example
     * // Get one PolicyEvaluationLog
     * const policyEvaluationLog = await prisma.policyEvaluationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyEvaluationLogFindUniqueArgs>(args: SelectSubset<T, PolicyEvaluationLogFindUniqueArgs<ExtArgs>>): Prisma__PolicyEvaluationLogClient<$Result.GetResult<Prisma.$PolicyEvaluationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PolicyEvaluationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PolicyEvaluationLogFindUniqueOrThrowArgs} args - Arguments to find a PolicyEvaluationLog
     * @example
     * // Get one PolicyEvaluationLog
     * const policyEvaluationLog = await prisma.policyEvaluationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyEvaluationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyEvaluationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyEvaluationLogClient<$Result.GetResult<Prisma.$PolicyEvaluationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PolicyEvaluationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyEvaluationLogFindFirstArgs} args - Arguments to find a PolicyEvaluationLog
     * @example
     * // Get one PolicyEvaluationLog
     * const policyEvaluationLog = await prisma.policyEvaluationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyEvaluationLogFindFirstArgs>(args?: SelectSubset<T, PolicyEvaluationLogFindFirstArgs<ExtArgs>>): Prisma__PolicyEvaluationLogClient<$Result.GetResult<Prisma.$PolicyEvaluationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PolicyEvaluationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyEvaluationLogFindFirstOrThrowArgs} args - Arguments to find a PolicyEvaluationLog
     * @example
     * // Get one PolicyEvaluationLog
     * const policyEvaluationLog = await prisma.policyEvaluationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyEvaluationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyEvaluationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyEvaluationLogClient<$Result.GetResult<Prisma.$PolicyEvaluationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PolicyEvaluationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyEvaluationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PolicyEvaluationLogs
     * const policyEvaluationLogs = await prisma.policyEvaluationLog.findMany()
     * 
     * // Get first 10 PolicyEvaluationLogs
     * const policyEvaluationLogs = await prisma.policyEvaluationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyEvaluationLogWithIdOnly = await prisma.policyEvaluationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PolicyEvaluationLogFindManyArgs>(args?: SelectSubset<T, PolicyEvaluationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyEvaluationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PolicyEvaluationLog.
     * @param {PolicyEvaluationLogCreateArgs} args - Arguments to create a PolicyEvaluationLog.
     * @example
     * // Create one PolicyEvaluationLog
     * const PolicyEvaluationLog = await prisma.policyEvaluationLog.create({
     *   data: {
     *     // ... data to create a PolicyEvaluationLog
     *   }
     * })
     * 
     */
    create<T extends PolicyEvaluationLogCreateArgs>(args: SelectSubset<T, PolicyEvaluationLogCreateArgs<ExtArgs>>): Prisma__PolicyEvaluationLogClient<$Result.GetResult<Prisma.$PolicyEvaluationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PolicyEvaluationLogs.
     * @param {PolicyEvaluationLogCreateManyArgs} args - Arguments to create many PolicyEvaluationLogs.
     * @example
     * // Create many PolicyEvaluationLogs
     * const policyEvaluationLog = await prisma.policyEvaluationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyEvaluationLogCreateManyArgs>(args?: SelectSubset<T, PolicyEvaluationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PolicyEvaluationLogs and returns the data saved in the database.
     * @param {PolicyEvaluationLogCreateManyAndReturnArgs} args - Arguments to create many PolicyEvaluationLogs.
     * @example
     * // Create many PolicyEvaluationLogs
     * const policyEvaluationLog = await prisma.policyEvaluationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PolicyEvaluationLogs and only return the `id`
     * const policyEvaluationLogWithIdOnly = await prisma.policyEvaluationLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolicyEvaluationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, PolicyEvaluationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyEvaluationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PolicyEvaluationLog.
     * @param {PolicyEvaluationLogDeleteArgs} args - Arguments to delete one PolicyEvaluationLog.
     * @example
     * // Delete one PolicyEvaluationLog
     * const PolicyEvaluationLog = await prisma.policyEvaluationLog.delete({
     *   where: {
     *     // ... filter to delete one PolicyEvaluationLog
     *   }
     * })
     * 
     */
    delete<T extends PolicyEvaluationLogDeleteArgs>(args: SelectSubset<T, PolicyEvaluationLogDeleteArgs<ExtArgs>>): Prisma__PolicyEvaluationLogClient<$Result.GetResult<Prisma.$PolicyEvaluationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PolicyEvaluationLog.
     * @param {PolicyEvaluationLogUpdateArgs} args - Arguments to update one PolicyEvaluationLog.
     * @example
     * // Update one PolicyEvaluationLog
     * const policyEvaluationLog = await prisma.policyEvaluationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyEvaluationLogUpdateArgs>(args: SelectSubset<T, PolicyEvaluationLogUpdateArgs<ExtArgs>>): Prisma__PolicyEvaluationLogClient<$Result.GetResult<Prisma.$PolicyEvaluationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PolicyEvaluationLogs.
     * @param {PolicyEvaluationLogDeleteManyArgs} args - Arguments to filter PolicyEvaluationLogs to delete.
     * @example
     * // Delete a few PolicyEvaluationLogs
     * const { count } = await prisma.policyEvaluationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyEvaluationLogDeleteManyArgs>(args?: SelectSubset<T, PolicyEvaluationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PolicyEvaluationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyEvaluationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PolicyEvaluationLogs
     * const policyEvaluationLog = await prisma.policyEvaluationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyEvaluationLogUpdateManyArgs>(args: SelectSubset<T, PolicyEvaluationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PolicyEvaluationLogs and returns the data updated in the database.
     * @param {PolicyEvaluationLogUpdateManyAndReturnArgs} args - Arguments to update many PolicyEvaluationLogs.
     * @example
     * // Update many PolicyEvaluationLogs
     * const policyEvaluationLog = await prisma.policyEvaluationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PolicyEvaluationLogs and only return the `id`
     * const policyEvaluationLogWithIdOnly = await prisma.policyEvaluationLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PolicyEvaluationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, PolicyEvaluationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyEvaluationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PolicyEvaluationLog.
     * @param {PolicyEvaluationLogUpsertArgs} args - Arguments to update or create a PolicyEvaluationLog.
     * @example
     * // Update or create a PolicyEvaluationLog
     * const policyEvaluationLog = await prisma.policyEvaluationLog.upsert({
     *   create: {
     *     // ... data to create a PolicyEvaluationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PolicyEvaluationLog we want to update
     *   }
     * })
     */
    upsert<T extends PolicyEvaluationLogUpsertArgs>(args: SelectSubset<T, PolicyEvaluationLogUpsertArgs<ExtArgs>>): Prisma__PolicyEvaluationLogClient<$Result.GetResult<Prisma.$PolicyEvaluationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PolicyEvaluationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyEvaluationLogCountArgs} args - Arguments to filter PolicyEvaluationLogs to count.
     * @example
     * // Count the number of PolicyEvaluationLogs
     * const count = await prisma.policyEvaluationLog.count({
     *   where: {
     *     // ... the filter for the PolicyEvaluationLogs we want to count
     *   }
     * })
    **/
    count<T extends PolicyEvaluationLogCountArgs>(
      args?: Subset<T, PolicyEvaluationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyEvaluationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PolicyEvaluationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyEvaluationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyEvaluationLogAggregateArgs>(args: Subset<T, PolicyEvaluationLogAggregateArgs>): Prisma.PrismaPromise<GetPolicyEvaluationLogAggregateType<T>>

    /**
     * Group by PolicyEvaluationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyEvaluationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyEvaluationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyEvaluationLogGroupByArgs['orderBy'] }
        : { orderBy?: PolicyEvaluationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyEvaluationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyEvaluationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PolicyEvaluationLog model
   */
  readonly fields: PolicyEvaluationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PolicyEvaluationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyEvaluationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends PolicyEvaluationLog$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, PolicyEvaluationLog$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PolicyEvaluationLog model
   */
  interface PolicyEvaluationLogFieldRefs {
    readonly id: FieldRef<"PolicyEvaluationLog", 'String'>
    readonly transactionId: FieldRef<"PolicyEvaluationLog", 'String'>
    readonly decision: FieldRef<"PolicyEvaluationLog", 'String'>
    readonly results: FieldRef<"PolicyEvaluationLog", 'String'>
    readonly createdAt: FieldRef<"PolicyEvaluationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PolicyEvaluationLog findUnique
   */
  export type PolicyEvaluationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyEvaluationLogInclude<ExtArgs> | null
    /**
     * Filter, which PolicyEvaluationLog to fetch.
     */
    where: PolicyEvaluationLogWhereUniqueInput
  }

  /**
   * PolicyEvaluationLog findUniqueOrThrow
   */
  export type PolicyEvaluationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyEvaluationLogInclude<ExtArgs> | null
    /**
     * Filter, which PolicyEvaluationLog to fetch.
     */
    where: PolicyEvaluationLogWhereUniqueInput
  }

  /**
   * PolicyEvaluationLog findFirst
   */
  export type PolicyEvaluationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyEvaluationLogInclude<ExtArgs> | null
    /**
     * Filter, which PolicyEvaluationLog to fetch.
     */
    where?: PolicyEvaluationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyEvaluationLogs to fetch.
     */
    orderBy?: PolicyEvaluationLogOrderByWithRelationInput | PolicyEvaluationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolicyEvaluationLogs.
     */
    cursor?: PolicyEvaluationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyEvaluationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyEvaluationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolicyEvaluationLogs.
     */
    distinct?: PolicyEvaluationLogScalarFieldEnum | PolicyEvaluationLogScalarFieldEnum[]
  }

  /**
   * PolicyEvaluationLog findFirstOrThrow
   */
  export type PolicyEvaluationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyEvaluationLogInclude<ExtArgs> | null
    /**
     * Filter, which PolicyEvaluationLog to fetch.
     */
    where?: PolicyEvaluationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyEvaluationLogs to fetch.
     */
    orderBy?: PolicyEvaluationLogOrderByWithRelationInput | PolicyEvaluationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolicyEvaluationLogs.
     */
    cursor?: PolicyEvaluationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyEvaluationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyEvaluationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolicyEvaluationLogs.
     */
    distinct?: PolicyEvaluationLogScalarFieldEnum | PolicyEvaluationLogScalarFieldEnum[]
  }

  /**
   * PolicyEvaluationLog findMany
   */
  export type PolicyEvaluationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyEvaluationLogInclude<ExtArgs> | null
    /**
     * Filter, which PolicyEvaluationLogs to fetch.
     */
    where?: PolicyEvaluationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyEvaluationLogs to fetch.
     */
    orderBy?: PolicyEvaluationLogOrderByWithRelationInput | PolicyEvaluationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PolicyEvaluationLogs.
     */
    cursor?: PolicyEvaluationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyEvaluationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyEvaluationLogs.
     */
    skip?: number
    distinct?: PolicyEvaluationLogScalarFieldEnum | PolicyEvaluationLogScalarFieldEnum[]
  }

  /**
   * PolicyEvaluationLog create
   */
  export type PolicyEvaluationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyEvaluationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a PolicyEvaluationLog.
     */
    data: XOR<PolicyEvaluationLogCreateInput, PolicyEvaluationLogUncheckedCreateInput>
  }

  /**
   * PolicyEvaluationLog createMany
   */
  export type PolicyEvaluationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PolicyEvaluationLogs.
     */
    data: PolicyEvaluationLogCreateManyInput | PolicyEvaluationLogCreateManyInput[]
  }

  /**
   * PolicyEvaluationLog createManyAndReturn
   */
  export type PolicyEvaluationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * The data used to create many PolicyEvaluationLogs.
     */
    data: PolicyEvaluationLogCreateManyInput | PolicyEvaluationLogCreateManyInput[]
  }

  /**
   * PolicyEvaluationLog update
   */
  export type PolicyEvaluationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyEvaluationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a PolicyEvaluationLog.
     */
    data: XOR<PolicyEvaluationLogUpdateInput, PolicyEvaluationLogUncheckedUpdateInput>
    /**
     * Choose, which PolicyEvaluationLog to update.
     */
    where: PolicyEvaluationLogWhereUniqueInput
  }

  /**
   * PolicyEvaluationLog updateMany
   */
  export type PolicyEvaluationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PolicyEvaluationLogs.
     */
    data: XOR<PolicyEvaluationLogUpdateManyMutationInput, PolicyEvaluationLogUncheckedUpdateManyInput>
    /**
     * Filter which PolicyEvaluationLogs to update
     */
    where?: PolicyEvaluationLogWhereInput
    /**
     * Limit how many PolicyEvaluationLogs to update.
     */
    limit?: number
  }

  /**
   * PolicyEvaluationLog updateManyAndReturn
   */
  export type PolicyEvaluationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * The data used to update PolicyEvaluationLogs.
     */
    data: XOR<PolicyEvaluationLogUpdateManyMutationInput, PolicyEvaluationLogUncheckedUpdateManyInput>
    /**
     * Filter which PolicyEvaluationLogs to update
     */
    where?: PolicyEvaluationLogWhereInput
    /**
     * Limit how many PolicyEvaluationLogs to update.
     */
    limit?: number
  }

  /**
   * PolicyEvaluationLog upsert
   */
  export type PolicyEvaluationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyEvaluationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the PolicyEvaluationLog to update in case it exists.
     */
    where: PolicyEvaluationLogWhereUniqueInput
    /**
     * In case the PolicyEvaluationLog found by the `where` argument doesn't exist, create a new PolicyEvaluationLog with this data.
     */
    create: XOR<PolicyEvaluationLogCreateInput, PolicyEvaluationLogUncheckedCreateInput>
    /**
     * In case the PolicyEvaluationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyEvaluationLogUpdateInput, PolicyEvaluationLogUncheckedUpdateInput>
  }

  /**
   * PolicyEvaluationLog delete
   */
  export type PolicyEvaluationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyEvaluationLogInclude<ExtArgs> | null
    /**
     * Filter which PolicyEvaluationLog to delete.
     */
    where: PolicyEvaluationLogWhereUniqueInput
  }

  /**
   * PolicyEvaluationLog deleteMany
   */
  export type PolicyEvaluationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PolicyEvaluationLogs to delete
     */
    where?: PolicyEvaluationLogWhereInput
    /**
     * Limit how many PolicyEvaluationLogs to delete.
     */
    limit?: number
  }

  /**
   * PolicyEvaluationLog.transactions
   */
  export type PolicyEvaluationLog$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * PolicyEvaluationLog without action
   */
  export type PolicyEvaluationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyEvaluationLog
     */
    select?: PolicyEvaluationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PolicyEvaluationLog
     */
    omit?: PolicyEvaluationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyEvaluationLogInclude<ExtArgs> | null
  }


  /**
   * Model ComplianceAttestation
   */

  export type AggregateComplianceAttestation = {
    _count: ComplianceAttestationCountAggregateOutputType | null
    _min: ComplianceAttestationMinAggregateOutputType | null
    _max: ComplianceAttestationMaxAggregateOutputType | null
  }

  export type ComplianceAttestationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    status: string | null
    validUntil: Date | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceAttestationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    status: string | null
    validUntil: Date | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceAttestationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    status: number
    validUntil: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplianceAttestationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    status?: true
    validUntil?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceAttestationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    status?: true
    validUntil?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceAttestationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    status?: true
    validUntil?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplianceAttestationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceAttestation to aggregate.
     */
    where?: ComplianceAttestationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceAttestations to fetch.
     */
    orderBy?: ComplianceAttestationOrderByWithRelationInput | ComplianceAttestationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplianceAttestationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceAttestations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceAttestations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplianceAttestations
    **/
    _count?: true | ComplianceAttestationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplianceAttestationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplianceAttestationMaxAggregateInputType
  }

  export type GetComplianceAttestationAggregateType<T extends ComplianceAttestationAggregateArgs> = {
        [P in keyof T & keyof AggregateComplianceAttestation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplianceAttestation[P]>
      : GetScalarType<T[P], AggregateComplianceAttestation[P]>
  }




  export type ComplianceAttestationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceAttestationWhereInput
    orderBy?: ComplianceAttestationOrderByWithAggregationInput | ComplianceAttestationOrderByWithAggregationInput[]
    by: ComplianceAttestationScalarFieldEnum[] | ComplianceAttestationScalarFieldEnum
    having?: ComplianceAttestationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplianceAttestationCountAggregateInputType | true
    _min?: ComplianceAttestationMinAggregateInputType
    _max?: ComplianceAttestationMaxAggregateInputType
  }

  export type ComplianceAttestationGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    status: string
    validUntil: Date | null
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: ComplianceAttestationCountAggregateOutputType | null
    _min: ComplianceAttestationMinAggregateOutputType | null
    _max: ComplianceAttestationMaxAggregateOutputType | null
  }

  type GetComplianceAttestationGroupByPayload<T extends ComplianceAttestationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplianceAttestationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplianceAttestationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplianceAttestationGroupByOutputType[P]>
            : GetScalarType<T[P], ComplianceAttestationGroupByOutputType[P]>
        }
      >
    >


  export type ComplianceAttestationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    status?: boolean
    validUntil?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceAttestation"]>

  export type ComplianceAttestationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    status?: boolean
    validUntil?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceAttestation"]>

  export type ComplianceAttestationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    status?: boolean
    validUntil?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceAttestation"]>

  export type ComplianceAttestationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    status?: boolean
    validUntil?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplianceAttestationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "status" | "validUntil" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["complianceAttestation"]>
  export type ComplianceAttestationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ComplianceAttestationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ComplianceAttestationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ComplianceAttestationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplianceAttestation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      status: string
      validUntil: Date | null
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complianceAttestation"]>
    composites: {}
  }

  type ComplianceAttestationGetPayload<S extends boolean | null | undefined | ComplianceAttestationDefaultArgs> = $Result.GetResult<Prisma.$ComplianceAttestationPayload, S>

  type ComplianceAttestationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplianceAttestationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplianceAttestationCountAggregateInputType | true
    }

  export interface ComplianceAttestationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplianceAttestation'], meta: { name: 'ComplianceAttestation' } }
    /**
     * Find zero or one ComplianceAttestation that matches the filter.
     * @param {ComplianceAttestationFindUniqueArgs} args - Arguments to find a ComplianceAttestation
     * @example
     * // Get one ComplianceAttestation
     * const complianceAttestation = await prisma.complianceAttestation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplianceAttestationFindUniqueArgs>(args: SelectSubset<T, ComplianceAttestationFindUniqueArgs<ExtArgs>>): Prisma__ComplianceAttestationClient<$Result.GetResult<Prisma.$ComplianceAttestationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComplianceAttestation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplianceAttestationFindUniqueOrThrowArgs} args - Arguments to find a ComplianceAttestation
     * @example
     * // Get one ComplianceAttestation
     * const complianceAttestation = await prisma.complianceAttestation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplianceAttestationFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplianceAttestationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplianceAttestationClient<$Result.GetResult<Prisma.$ComplianceAttestationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplianceAttestation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAttestationFindFirstArgs} args - Arguments to find a ComplianceAttestation
     * @example
     * // Get one ComplianceAttestation
     * const complianceAttestation = await prisma.complianceAttestation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplianceAttestationFindFirstArgs>(args?: SelectSubset<T, ComplianceAttestationFindFirstArgs<ExtArgs>>): Prisma__ComplianceAttestationClient<$Result.GetResult<Prisma.$ComplianceAttestationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplianceAttestation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAttestationFindFirstOrThrowArgs} args - Arguments to find a ComplianceAttestation
     * @example
     * // Get one ComplianceAttestation
     * const complianceAttestation = await prisma.complianceAttestation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplianceAttestationFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplianceAttestationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplianceAttestationClient<$Result.GetResult<Prisma.$ComplianceAttestationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComplianceAttestations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAttestationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplianceAttestations
     * const complianceAttestations = await prisma.complianceAttestation.findMany()
     * 
     * // Get first 10 ComplianceAttestations
     * const complianceAttestations = await prisma.complianceAttestation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complianceAttestationWithIdOnly = await prisma.complianceAttestation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplianceAttestationFindManyArgs>(args?: SelectSubset<T, ComplianceAttestationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceAttestationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComplianceAttestation.
     * @param {ComplianceAttestationCreateArgs} args - Arguments to create a ComplianceAttestation.
     * @example
     * // Create one ComplianceAttestation
     * const ComplianceAttestation = await prisma.complianceAttestation.create({
     *   data: {
     *     // ... data to create a ComplianceAttestation
     *   }
     * })
     * 
     */
    create<T extends ComplianceAttestationCreateArgs>(args: SelectSubset<T, ComplianceAttestationCreateArgs<ExtArgs>>): Prisma__ComplianceAttestationClient<$Result.GetResult<Prisma.$ComplianceAttestationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComplianceAttestations.
     * @param {ComplianceAttestationCreateManyArgs} args - Arguments to create many ComplianceAttestations.
     * @example
     * // Create many ComplianceAttestations
     * const complianceAttestation = await prisma.complianceAttestation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplianceAttestationCreateManyArgs>(args?: SelectSubset<T, ComplianceAttestationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplianceAttestations and returns the data saved in the database.
     * @param {ComplianceAttestationCreateManyAndReturnArgs} args - Arguments to create many ComplianceAttestations.
     * @example
     * // Create many ComplianceAttestations
     * const complianceAttestation = await prisma.complianceAttestation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplianceAttestations and only return the `id`
     * const complianceAttestationWithIdOnly = await prisma.complianceAttestation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplianceAttestationCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplianceAttestationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceAttestationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComplianceAttestation.
     * @param {ComplianceAttestationDeleteArgs} args - Arguments to delete one ComplianceAttestation.
     * @example
     * // Delete one ComplianceAttestation
     * const ComplianceAttestation = await prisma.complianceAttestation.delete({
     *   where: {
     *     // ... filter to delete one ComplianceAttestation
     *   }
     * })
     * 
     */
    delete<T extends ComplianceAttestationDeleteArgs>(args: SelectSubset<T, ComplianceAttestationDeleteArgs<ExtArgs>>): Prisma__ComplianceAttestationClient<$Result.GetResult<Prisma.$ComplianceAttestationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComplianceAttestation.
     * @param {ComplianceAttestationUpdateArgs} args - Arguments to update one ComplianceAttestation.
     * @example
     * // Update one ComplianceAttestation
     * const complianceAttestation = await prisma.complianceAttestation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplianceAttestationUpdateArgs>(args: SelectSubset<T, ComplianceAttestationUpdateArgs<ExtArgs>>): Prisma__ComplianceAttestationClient<$Result.GetResult<Prisma.$ComplianceAttestationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComplianceAttestations.
     * @param {ComplianceAttestationDeleteManyArgs} args - Arguments to filter ComplianceAttestations to delete.
     * @example
     * // Delete a few ComplianceAttestations
     * const { count } = await prisma.complianceAttestation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplianceAttestationDeleteManyArgs>(args?: SelectSubset<T, ComplianceAttestationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceAttestations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAttestationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplianceAttestations
     * const complianceAttestation = await prisma.complianceAttestation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplianceAttestationUpdateManyArgs>(args: SelectSubset<T, ComplianceAttestationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceAttestations and returns the data updated in the database.
     * @param {ComplianceAttestationUpdateManyAndReturnArgs} args - Arguments to update many ComplianceAttestations.
     * @example
     * // Update many ComplianceAttestations
     * const complianceAttestation = await prisma.complianceAttestation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComplianceAttestations and only return the `id`
     * const complianceAttestationWithIdOnly = await prisma.complianceAttestation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComplianceAttestationUpdateManyAndReturnArgs>(args: SelectSubset<T, ComplianceAttestationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceAttestationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComplianceAttestation.
     * @param {ComplianceAttestationUpsertArgs} args - Arguments to update or create a ComplianceAttestation.
     * @example
     * // Update or create a ComplianceAttestation
     * const complianceAttestation = await prisma.complianceAttestation.upsert({
     *   create: {
     *     // ... data to create a ComplianceAttestation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplianceAttestation we want to update
     *   }
     * })
     */
    upsert<T extends ComplianceAttestationUpsertArgs>(args: SelectSubset<T, ComplianceAttestationUpsertArgs<ExtArgs>>): Prisma__ComplianceAttestationClient<$Result.GetResult<Prisma.$ComplianceAttestationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComplianceAttestations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAttestationCountArgs} args - Arguments to filter ComplianceAttestations to count.
     * @example
     * // Count the number of ComplianceAttestations
     * const count = await prisma.complianceAttestation.count({
     *   where: {
     *     // ... the filter for the ComplianceAttestations we want to count
     *   }
     * })
    **/
    count<T extends ComplianceAttestationCountArgs>(
      args?: Subset<T, ComplianceAttestationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplianceAttestationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplianceAttestation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAttestationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplianceAttestationAggregateArgs>(args: Subset<T, ComplianceAttestationAggregateArgs>): Prisma.PrismaPromise<GetComplianceAttestationAggregateType<T>>

    /**
     * Group by ComplianceAttestation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAttestationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplianceAttestationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplianceAttestationGroupByArgs['orderBy'] }
        : { orderBy?: ComplianceAttestationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplianceAttestationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplianceAttestationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplianceAttestation model
   */
  readonly fields: ComplianceAttestationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplianceAttestation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplianceAttestationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplianceAttestation model
   */
  interface ComplianceAttestationFieldRefs {
    readonly id: FieldRef<"ComplianceAttestation", 'String'>
    readonly userId: FieldRef<"ComplianceAttestation", 'String'>
    readonly type: FieldRef<"ComplianceAttestation", 'String'>
    readonly provider: FieldRef<"ComplianceAttestation", 'String'>
    readonly status: FieldRef<"ComplianceAttestation", 'String'>
    readonly validUntil: FieldRef<"ComplianceAttestation", 'DateTime'>
    readonly metadata: FieldRef<"ComplianceAttestation", 'String'>
    readonly createdAt: FieldRef<"ComplianceAttestation", 'DateTime'>
    readonly updatedAt: FieldRef<"ComplianceAttestation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplianceAttestation findUnique
   */
  export type ComplianceAttestationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceAttestation to fetch.
     */
    where: ComplianceAttestationWhereUniqueInput
  }

  /**
   * ComplianceAttestation findUniqueOrThrow
   */
  export type ComplianceAttestationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceAttestation to fetch.
     */
    where: ComplianceAttestationWhereUniqueInput
  }

  /**
   * ComplianceAttestation findFirst
   */
  export type ComplianceAttestationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceAttestation to fetch.
     */
    where?: ComplianceAttestationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceAttestations to fetch.
     */
    orderBy?: ComplianceAttestationOrderByWithRelationInput | ComplianceAttestationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceAttestations.
     */
    cursor?: ComplianceAttestationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceAttestations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceAttestations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceAttestations.
     */
    distinct?: ComplianceAttestationScalarFieldEnum | ComplianceAttestationScalarFieldEnum[]
  }

  /**
   * ComplianceAttestation findFirstOrThrow
   */
  export type ComplianceAttestationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceAttestation to fetch.
     */
    where?: ComplianceAttestationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceAttestations to fetch.
     */
    orderBy?: ComplianceAttestationOrderByWithRelationInput | ComplianceAttestationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceAttestations.
     */
    cursor?: ComplianceAttestationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceAttestations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceAttestations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceAttestations.
     */
    distinct?: ComplianceAttestationScalarFieldEnum | ComplianceAttestationScalarFieldEnum[]
  }

  /**
   * ComplianceAttestation findMany
   */
  export type ComplianceAttestationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceAttestations to fetch.
     */
    where?: ComplianceAttestationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceAttestations to fetch.
     */
    orderBy?: ComplianceAttestationOrderByWithRelationInput | ComplianceAttestationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplianceAttestations.
     */
    cursor?: ComplianceAttestationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceAttestations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceAttestations.
     */
    skip?: number
    distinct?: ComplianceAttestationScalarFieldEnum | ComplianceAttestationScalarFieldEnum[]
  }

  /**
   * ComplianceAttestation create
   */
  export type ComplianceAttestationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplianceAttestation.
     */
    data: XOR<ComplianceAttestationCreateInput, ComplianceAttestationUncheckedCreateInput>
  }

  /**
   * ComplianceAttestation createMany
   */
  export type ComplianceAttestationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplianceAttestations.
     */
    data: ComplianceAttestationCreateManyInput | ComplianceAttestationCreateManyInput[]
  }

  /**
   * ComplianceAttestation createManyAndReturn
   */
  export type ComplianceAttestationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * The data used to create many ComplianceAttestations.
     */
    data: ComplianceAttestationCreateManyInput | ComplianceAttestationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplianceAttestation update
   */
  export type ComplianceAttestationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplianceAttestation.
     */
    data: XOR<ComplianceAttestationUpdateInput, ComplianceAttestationUncheckedUpdateInput>
    /**
     * Choose, which ComplianceAttestation to update.
     */
    where: ComplianceAttestationWhereUniqueInput
  }

  /**
   * ComplianceAttestation updateMany
   */
  export type ComplianceAttestationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplianceAttestations.
     */
    data: XOR<ComplianceAttestationUpdateManyMutationInput, ComplianceAttestationUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceAttestations to update
     */
    where?: ComplianceAttestationWhereInput
    /**
     * Limit how many ComplianceAttestations to update.
     */
    limit?: number
  }

  /**
   * ComplianceAttestation updateManyAndReturn
   */
  export type ComplianceAttestationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * The data used to update ComplianceAttestations.
     */
    data: XOR<ComplianceAttestationUpdateManyMutationInput, ComplianceAttestationUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceAttestations to update
     */
    where?: ComplianceAttestationWhereInput
    /**
     * Limit how many ComplianceAttestations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplianceAttestation upsert
   */
  export type ComplianceAttestationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplianceAttestation to update in case it exists.
     */
    where: ComplianceAttestationWhereUniqueInput
    /**
     * In case the ComplianceAttestation found by the `where` argument doesn't exist, create a new ComplianceAttestation with this data.
     */
    create: XOR<ComplianceAttestationCreateInput, ComplianceAttestationUncheckedCreateInput>
    /**
     * In case the ComplianceAttestation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplianceAttestationUpdateInput, ComplianceAttestationUncheckedUpdateInput>
  }

  /**
   * ComplianceAttestation delete
   */
  export type ComplianceAttestationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationInclude<ExtArgs> | null
    /**
     * Filter which ComplianceAttestation to delete.
     */
    where: ComplianceAttestationWhereUniqueInput
  }

  /**
   * ComplianceAttestation deleteMany
   */
  export type ComplianceAttestationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceAttestations to delete
     */
    where?: ComplianceAttestationWhereInput
    /**
     * Limit how many ComplianceAttestations to delete.
     */
    limit?: number
  }

  /**
   * ComplianceAttestation without action
   */
  export type ComplianceAttestationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAttestation
     */
    select?: ComplianceAttestationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAttestation
     */
    omit?: ComplianceAttestationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAttestationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    fullName: 'fullName',
    role: 'role',
    status: 'status',
    issuerId: 'issuerId',
    merchantId: 'merchantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const IssuerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    apiKey: 'apiKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IssuerScalarFieldEnum = (typeof IssuerScalarFieldEnum)[keyof typeof IssuerScalarFieldEnum]


  export const MerchantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    discountRate: 'discountRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MerchantScalarFieldEnum = (typeof MerchantScalarFieldEnum)[keyof typeof MerchantScalarFieldEnum]


  export const MerchantTerminalScalarFieldEnum: {
    id: 'id',
    merchantId: 'merchantId',
    location: 'location',
    secretKey: 'secretKey',
    createdAt: 'createdAt'
  };

  export type MerchantTerminalScalarFieldEnum = (typeof MerchantTerminalScalarFieldEnum)[keyof typeof MerchantTerminalScalarFieldEnum]


  export const VCreditDefinitionScalarFieldEnum: {
    id: 'id',
    issuerId: 'issuerId',
    name: 'name',
    symbol: 'symbol',
    decimals: 'decimals',
    type: 'type',
    exchangeRateBaseUSD: 'exchangeRateBaseUSD',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VCreditDefinitionScalarFieldEnum = (typeof VCreditDefinitionScalarFieldEnum)[keyof typeof VCreditDefinitionScalarFieldEnum]


  export const LiquidityPoolScalarFieldEnum: {
    id: 'id',
    creditDefId: 'creditDefId',
    balance: 'balance',
    currency: 'currency',
    updatedAt: 'updatedAt'
  };

  export type LiquidityPoolScalarFieldEnum = (typeof LiquidityPoolScalarFieldEnum)[keyof typeof LiquidityPoolScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const BalanceScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    creditDefId: 'creditDefId',
    amount: 'amount',
    updatedAt: 'updatedAt'
  };

  export type BalanceScalarFieldEnum = (typeof BalanceScalarFieldEnum)[keyof typeof BalanceScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    referenceRef: 'referenceRef',
    type: 'type',
    status: 'status',
    senderWalletId: 'senderWalletId',
    recipientWalletId: 'recipientWalletId',
    metadata: 'metadata',
    policyLogId: 'policyLogId',
    createdAt: 'createdAt',
    finalizedAt: 'finalizedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const LedgerEntryScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    walletId: 'walletId',
    creditDefId: 'creditDefId',
    direction: 'direction',
    amount: 'amount',
    balanceAfter: 'balanceAfter',
    createdAt: 'createdAt'
  };

  export type LedgerEntryScalarFieldEnum = (typeof LedgerEntryScalarFieldEnum)[keyof typeof LedgerEntryScalarFieldEnum]


  export const PolicyScalarFieldEnum: {
    id: 'id',
    issuerId: 'issuerId',
    creditDefId: 'creditDefId',
    name: 'name',
    description: 'description',
    ruleType: 'ruleType',
    parameters: 'parameters',
    isActive: 'isActive',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PolicyScalarFieldEnum = (typeof PolicyScalarFieldEnum)[keyof typeof PolicyScalarFieldEnum]


  export const PolicyEvaluationLogScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    decision: 'decision',
    results: 'results',
    createdAt: 'createdAt'
  };

  export type PolicyEvaluationLogScalarFieldEnum = (typeof PolicyEvaluationLogScalarFieldEnum)[keyof typeof PolicyEvaluationLogScalarFieldEnum]


  export const ComplianceAttestationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    status: 'status',
    validUntil: 'validUntil',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplianceAttestationScalarFieldEnum = (typeof ComplianceAttestationScalarFieldEnum)[keyof typeof ComplianceAttestationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    issuerId?: StringNullableFilter<"User"> | string | null
    merchantId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    issuer?: XOR<IssuerNullableScalarRelationFilter, IssuerWhereInput> | null
    merchant?: XOR<MerchantNullableScalarRelationFilter, MerchantWhereInput> | null
    wallets?: WalletListRelationFilter
    attestations?: ComplianceAttestationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    issuerId?: SortOrderInput | SortOrder
    merchantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    issuer?: IssuerOrderByWithRelationInput
    merchant?: MerchantOrderByWithRelationInput
    wallets?: WalletOrderByRelationAggregateInput
    attestations?: ComplianceAttestationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    issuerId?: StringNullableFilter<"User"> | string | null
    merchantId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    issuer?: XOR<IssuerNullableScalarRelationFilter, IssuerWhereInput> | null
    merchant?: XOR<MerchantNullableScalarRelationFilter, MerchantWhereInput> | null
    wallets?: WalletListRelationFilter
    attestations?: ComplianceAttestationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    issuerId?: SortOrderInput | SortOrder
    merchantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    status?: StringWithAggregatesFilter<"User"> | string
    issuerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    merchantId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type IssuerWhereInput = {
    AND?: IssuerWhereInput | IssuerWhereInput[]
    OR?: IssuerWhereInput[]
    NOT?: IssuerWhereInput | IssuerWhereInput[]
    id?: StringFilter<"Issuer"> | string
    name?: StringFilter<"Issuer"> | string
    slug?: StringFilter<"Issuer"> | string
    apiKey?: StringFilter<"Issuer"> | string
    createdAt?: DateTimeFilter<"Issuer"> | Date | string
    updatedAt?: DateTimeFilter<"Issuer"> | Date | string
    users?: UserListRelationFilter
    creditDefs?: VCreditDefinitionListRelationFilter
    policies?: PolicyListRelationFilter
  }

  export type IssuerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    creditDefs?: VCreditDefinitionOrderByRelationAggregateInput
    policies?: PolicyOrderByRelationAggregateInput
  }

  export type IssuerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    apiKey?: string
    AND?: IssuerWhereInput | IssuerWhereInput[]
    OR?: IssuerWhereInput[]
    NOT?: IssuerWhereInput | IssuerWhereInput[]
    createdAt?: DateTimeFilter<"Issuer"> | Date | string
    updatedAt?: DateTimeFilter<"Issuer"> | Date | string
    users?: UserListRelationFilter
    creditDefs?: VCreditDefinitionListRelationFilter
    policies?: PolicyListRelationFilter
  }, "id" | "name" | "slug" | "apiKey">

  export type IssuerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IssuerCountOrderByAggregateInput
    _max?: IssuerMaxOrderByAggregateInput
    _min?: IssuerMinOrderByAggregateInput
  }

  export type IssuerScalarWhereWithAggregatesInput = {
    AND?: IssuerScalarWhereWithAggregatesInput | IssuerScalarWhereWithAggregatesInput[]
    OR?: IssuerScalarWhereWithAggregatesInput[]
    NOT?: IssuerScalarWhereWithAggregatesInput | IssuerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Issuer"> | string
    name?: StringWithAggregatesFilter<"Issuer"> | string
    slug?: StringWithAggregatesFilter<"Issuer"> | string
    apiKey?: StringWithAggregatesFilter<"Issuer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Issuer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Issuer"> | Date | string
  }

  export type MerchantWhereInput = {
    AND?: MerchantWhereInput | MerchantWhereInput[]
    OR?: MerchantWhereInput[]
    NOT?: MerchantWhereInput | MerchantWhereInput[]
    id?: StringFilter<"Merchant"> | string
    name?: StringFilter<"Merchant"> | string
    category?: StringFilter<"Merchant"> | string
    discountRate?: DecimalFilter<"Merchant"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Merchant"> | Date | string
    updatedAt?: DateTimeFilter<"Merchant"> | Date | string
    users?: UserListRelationFilter
    terminals?: MerchantTerminalListRelationFilter
  }

  export type MerchantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    discountRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    terminals?: MerchantTerminalOrderByRelationAggregateInput
  }

  export type MerchantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MerchantWhereInput | MerchantWhereInput[]
    OR?: MerchantWhereInput[]
    NOT?: MerchantWhereInput | MerchantWhereInput[]
    category?: StringFilter<"Merchant"> | string
    discountRate?: DecimalFilter<"Merchant"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Merchant"> | Date | string
    updatedAt?: DateTimeFilter<"Merchant"> | Date | string
    users?: UserListRelationFilter
    terminals?: MerchantTerminalListRelationFilter
  }, "id" | "name">

  export type MerchantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    discountRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MerchantCountOrderByAggregateInput
    _avg?: MerchantAvgOrderByAggregateInput
    _max?: MerchantMaxOrderByAggregateInput
    _min?: MerchantMinOrderByAggregateInput
    _sum?: MerchantSumOrderByAggregateInput
  }

  export type MerchantScalarWhereWithAggregatesInput = {
    AND?: MerchantScalarWhereWithAggregatesInput | MerchantScalarWhereWithAggregatesInput[]
    OR?: MerchantScalarWhereWithAggregatesInput[]
    NOT?: MerchantScalarWhereWithAggregatesInput | MerchantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Merchant"> | string
    name?: StringWithAggregatesFilter<"Merchant"> | string
    category?: StringWithAggregatesFilter<"Merchant"> | string
    discountRate?: DecimalWithAggregatesFilter<"Merchant"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Merchant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Merchant"> | Date | string
  }

  export type MerchantTerminalWhereInput = {
    AND?: MerchantTerminalWhereInput | MerchantTerminalWhereInput[]
    OR?: MerchantTerminalWhereInput[]
    NOT?: MerchantTerminalWhereInput | MerchantTerminalWhereInput[]
    id?: StringFilter<"MerchantTerminal"> | string
    merchantId?: StringFilter<"MerchantTerminal"> | string
    location?: StringFilter<"MerchantTerminal"> | string
    secretKey?: StringFilter<"MerchantTerminal"> | string
    createdAt?: DateTimeFilter<"MerchantTerminal"> | Date | string
    merchant?: XOR<MerchantScalarRelationFilter, MerchantWhereInput>
  }

  export type MerchantTerminalOrderByWithRelationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    location?: SortOrder
    secretKey?: SortOrder
    createdAt?: SortOrder
    merchant?: MerchantOrderByWithRelationInput
  }

  export type MerchantTerminalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MerchantTerminalWhereInput | MerchantTerminalWhereInput[]
    OR?: MerchantTerminalWhereInput[]
    NOT?: MerchantTerminalWhereInput | MerchantTerminalWhereInput[]
    merchantId?: StringFilter<"MerchantTerminal"> | string
    location?: StringFilter<"MerchantTerminal"> | string
    secretKey?: StringFilter<"MerchantTerminal"> | string
    createdAt?: DateTimeFilter<"MerchantTerminal"> | Date | string
    merchant?: XOR<MerchantScalarRelationFilter, MerchantWhereInput>
  }, "id">

  export type MerchantTerminalOrderByWithAggregationInput = {
    id?: SortOrder
    merchantId?: SortOrder
    location?: SortOrder
    secretKey?: SortOrder
    createdAt?: SortOrder
    _count?: MerchantTerminalCountOrderByAggregateInput
    _max?: MerchantTerminalMaxOrderByAggregateInput
    _min?: MerchantTerminalMinOrderByAggregateInput
  }

  export type MerchantTerminalScalarWhereWithAggregatesInput = {
    AND?: MerchantTerminalScalarWhereWithAggregatesInput | MerchantTerminalScalarWhereWithAggregatesInput[]
    OR?: MerchantTerminalScalarWhereWithAggregatesInput[]
    NOT?: MerchantTerminalScalarWhereWithAggregatesInput | MerchantTerminalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MerchantTerminal"> | string
    merchantId?: StringWithAggregatesFilter<"MerchantTerminal"> | string
    location?: StringWithAggregatesFilter<"MerchantTerminal"> | string
    secretKey?: StringWithAggregatesFilter<"MerchantTerminal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MerchantTerminal"> | Date | string
  }

  export type VCreditDefinitionWhereInput = {
    AND?: VCreditDefinitionWhereInput | VCreditDefinitionWhereInput[]
    OR?: VCreditDefinitionWhereInput[]
    NOT?: VCreditDefinitionWhereInput | VCreditDefinitionWhereInput[]
    id?: StringFilter<"VCreditDefinition"> | string
    issuerId?: StringFilter<"VCreditDefinition"> | string
    name?: StringFilter<"VCreditDefinition"> | string
    symbol?: StringFilter<"VCreditDefinition"> | string
    decimals?: IntFilter<"VCreditDefinition"> | number
    type?: StringFilter<"VCreditDefinition"> | string
    exchangeRateBaseUSD?: DecimalFilter<"VCreditDefinition"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"VCreditDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"VCreditDefinition"> | Date | string
    issuer?: XOR<IssuerScalarRelationFilter, IssuerWhereInput>
    balances?: BalanceListRelationFilter
    policies?: PolicyListRelationFilter
    liquidityPool?: XOR<LiquidityPoolNullableScalarRelationFilter, LiquidityPoolWhereInput> | null
  }

  export type VCreditDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    issuerId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    type?: SortOrder
    exchangeRateBaseUSD?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    issuer?: IssuerOrderByWithRelationInput
    balances?: BalanceOrderByRelationAggregateInput
    policies?: PolicyOrderByRelationAggregateInput
    liquidityPool?: LiquidityPoolOrderByWithRelationInput
  }

  export type VCreditDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VCreditDefinitionWhereInput | VCreditDefinitionWhereInput[]
    OR?: VCreditDefinitionWhereInput[]
    NOT?: VCreditDefinitionWhereInput | VCreditDefinitionWhereInput[]
    issuerId?: StringFilter<"VCreditDefinition"> | string
    name?: StringFilter<"VCreditDefinition"> | string
    symbol?: StringFilter<"VCreditDefinition"> | string
    decimals?: IntFilter<"VCreditDefinition"> | number
    type?: StringFilter<"VCreditDefinition"> | string
    exchangeRateBaseUSD?: DecimalFilter<"VCreditDefinition"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"VCreditDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"VCreditDefinition"> | Date | string
    issuer?: XOR<IssuerScalarRelationFilter, IssuerWhereInput>
    balances?: BalanceListRelationFilter
    policies?: PolicyListRelationFilter
    liquidityPool?: XOR<LiquidityPoolNullableScalarRelationFilter, LiquidityPoolWhereInput> | null
  }, "id">

  export type VCreditDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    issuerId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    type?: SortOrder
    exchangeRateBaseUSD?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VCreditDefinitionCountOrderByAggregateInput
    _avg?: VCreditDefinitionAvgOrderByAggregateInput
    _max?: VCreditDefinitionMaxOrderByAggregateInput
    _min?: VCreditDefinitionMinOrderByAggregateInput
    _sum?: VCreditDefinitionSumOrderByAggregateInput
  }

  export type VCreditDefinitionScalarWhereWithAggregatesInput = {
    AND?: VCreditDefinitionScalarWhereWithAggregatesInput | VCreditDefinitionScalarWhereWithAggregatesInput[]
    OR?: VCreditDefinitionScalarWhereWithAggregatesInput[]
    NOT?: VCreditDefinitionScalarWhereWithAggregatesInput | VCreditDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VCreditDefinition"> | string
    issuerId?: StringWithAggregatesFilter<"VCreditDefinition"> | string
    name?: StringWithAggregatesFilter<"VCreditDefinition"> | string
    symbol?: StringWithAggregatesFilter<"VCreditDefinition"> | string
    decimals?: IntWithAggregatesFilter<"VCreditDefinition"> | number
    type?: StringWithAggregatesFilter<"VCreditDefinition"> | string
    exchangeRateBaseUSD?: DecimalWithAggregatesFilter<"VCreditDefinition"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"VCreditDefinition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VCreditDefinition"> | Date | string
  }

  export type LiquidityPoolWhereInput = {
    AND?: LiquidityPoolWhereInput | LiquidityPoolWhereInput[]
    OR?: LiquidityPoolWhereInput[]
    NOT?: LiquidityPoolWhereInput | LiquidityPoolWhereInput[]
    id?: StringFilter<"LiquidityPool"> | string
    creditDefId?: StringFilter<"LiquidityPool"> | string
    balance?: DecimalFilter<"LiquidityPool"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"LiquidityPool"> | string
    updatedAt?: DateTimeFilter<"LiquidityPool"> | Date | string
    creditDef?: XOR<VCreditDefinitionScalarRelationFilter, VCreditDefinitionWhereInput>
  }

  export type LiquidityPoolOrderByWithRelationInput = {
    id?: SortOrder
    creditDefId?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    updatedAt?: SortOrder
    creditDef?: VCreditDefinitionOrderByWithRelationInput
  }

  export type LiquidityPoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creditDefId?: string
    AND?: LiquidityPoolWhereInput | LiquidityPoolWhereInput[]
    OR?: LiquidityPoolWhereInput[]
    NOT?: LiquidityPoolWhereInput | LiquidityPoolWhereInput[]
    balance?: DecimalFilter<"LiquidityPool"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"LiquidityPool"> | string
    updatedAt?: DateTimeFilter<"LiquidityPool"> | Date | string
    creditDef?: XOR<VCreditDefinitionScalarRelationFilter, VCreditDefinitionWhereInput>
  }, "id" | "creditDefId">

  export type LiquidityPoolOrderByWithAggregationInput = {
    id?: SortOrder
    creditDefId?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    updatedAt?: SortOrder
    _count?: LiquidityPoolCountOrderByAggregateInput
    _avg?: LiquidityPoolAvgOrderByAggregateInput
    _max?: LiquidityPoolMaxOrderByAggregateInput
    _min?: LiquidityPoolMinOrderByAggregateInput
    _sum?: LiquidityPoolSumOrderByAggregateInput
  }

  export type LiquidityPoolScalarWhereWithAggregatesInput = {
    AND?: LiquidityPoolScalarWhereWithAggregatesInput | LiquidityPoolScalarWhereWithAggregatesInput[]
    OR?: LiquidityPoolScalarWhereWithAggregatesInput[]
    NOT?: LiquidityPoolScalarWhereWithAggregatesInput | LiquidityPoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LiquidityPool"> | string
    creditDefId?: StringWithAggregatesFilter<"LiquidityPool"> | string
    balance?: DecimalWithAggregatesFilter<"LiquidityPool"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"LiquidityPool"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"LiquidityPool"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringNullableFilter<"Wallet"> | string | null
    type?: StringFilter<"Wallet"> | string
    status?: StringFilter<"Wallet"> | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    balances?: BalanceListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    balances?: BalanceOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    userId?: StringNullableFilter<"Wallet"> | string | null
    type?: StringFilter<"Wallet"> | string
    status?: StringFilter<"Wallet"> | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    balances?: BalanceListRelationFilter
    transactions?: TransactionListRelationFilter
  }, "id">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    userId?: StringNullableWithAggregatesFilter<"Wallet"> | string | null
    type?: StringWithAggregatesFilter<"Wallet"> | string
    status?: StringWithAggregatesFilter<"Wallet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type BalanceWhereInput = {
    AND?: BalanceWhereInput | BalanceWhereInput[]
    OR?: BalanceWhereInput[]
    NOT?: BalanceWhereInput | BalanceWhereInput[]
    id?: StringFilter<"Balance"> | string
    walletId?: StringFilter<"Balance"> | string
    creditDefId?: StringFilter<"Balance"> | string
    amount?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"Balance"> | Date | string
    wallet?: XOR<WalletScalarRelationFilter, WalletWhereInput>
    creditDef?: XOR<VCreditDefinitionScalarRelationFilter, VCreditDefinitionWhereInput>
  }

  export type BalanceOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    creditDefId?: SortOrder
    amount?: SortOrder
    updatedAt?: SortOrder
    wallet?: WalletOrderByWithRelationInput
    creditDef?: VCreditDefinitionOrderByWithRelationInput
  }

  export type BalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    walletId_creditDefId?: BalanceWalletIdCreditDefIdCompoundUniqueInput
    AND?: BalanceWhereInput | BalanceWhereInput[]
    OR?: BalanceWhereInput[]
    NOT?: BalanceWhereInput | BalanceWhereInput[]
    walletId?: StringFilter<"Balance"> | string
    creditDefId?: StringFilter<"Balance"> | string
    amount?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"Balance"> | Date | string
    wallet?: XOR<WalletScalarRelationFilter, WalletWhereInput>
    creditDef?: XOR<VCreditDefinitionScalarRelationFilter, VCreditDefinitionWhereInput>
  }, "id" | "walletId_creditDefId">

  export type BalanceOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    creditDefId?: SortOrder
    amount?: SortOrder
    updatedAt?: SortOrder
    _count?: BalanceCountOrderByAggregateInput
    _avg?: BalanceAvgOrderByAggregateInput
    _max?: BalanceMaxOrderByAggregateInput
    _min?: BalanceMinOrderByAggregateInput
    _sum?: BalanceSumOrderByAggregateInput
  }

  export type BalanceScalarWhereWithAggregatesInput = {
    AND?: BalanceScalarWhereWithAggregatesInput | BalanceScalarWhereWithAggregatesInput[]
    OR?: BalanceScalarWhereWithAggregatesInput[]
    NOT?: BalanceScalarWhereWithAggregatesInput | BalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Balance"> | string
    walletId?: StringWithAggregatesFilter<"Balance"> | string
    creditDefId?: StringWithAggregatesFilter<"Balance"> | string
    amount?: DecimalWithAggregatesFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeWithAggregatesFilter<"Balance"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    referenceRef?: StringNullableFilter<"Transaction"> | string | null
    type?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    senderWalletId?: StringNullableFilter<"Transaction"> | string | null
    recipientWalletId?: StringNullableFilter<"Transaction"> | string | null
    metadata?: StringNullableFilter<"Transaction"> | string | null
    policyLogId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    finalizedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    senderWallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    policyLog?: XOR<PolicyEvaluationLogNullableScalarRelationFilter, PolicyEvaluationLogWhereInput> | null
    ledgerEntries?: LedgerEntryListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    referenceRef?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    senderWalletId?: SortOrderInput | SortOrder
    recipientWalletId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    policyLogId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    finalizedAt?: SortOrderInput | SortOrder
    senderWallet?: WalletOrderByWithRelationInput
    policyLog?: PolicyEvaluationLogOrderByWithRelationInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referenceRef?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    type?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    senderWalletId?: StringNullableFilter<"Transaction"> | string | null
    recipientWalletId?: StringNullableFilter<"Transaction"> | string | null
    metadata?: StringNullableFilter<"Transaction"> | string | null
    policyLogId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    finalizedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    senderWallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    policyLog?: XOR<PolicyEvaluationLogNullableScalarRelationFilter, PolicyEvaluationLogWhereInput> | null
    ledgerEntries?: LedgerEntryListRelationFilter
  }, "id" | "referenceRef">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    referenceRef?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    senderWalletId?: SortOrderInput | SortOrder
    recipientWalletId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    policyLogId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    finalizedAt?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    referenceRef?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    type?: StringWithAggregatesFilter<"Transaction"> | string
    status?: StringWithAggregatesFilter<"Transaction"> | string
    senderWalletId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    recipientWalletId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    policyLogId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    finalizedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
  }

  export type LedgerEntryWhereInput = {
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    id?: StringFilter<"LedgerEntry"> | string
    transactionId?: StringFilter<"LedgerEntry"> | string
    walletId?: StringFilter<"LedgerEntry"> | string
    creditDefId?: StringFilter<"LedgerEntry"> | string
    direction?: StringFilter<"LedgerEntry"> | string
    amount?: DecimalFilter<"LedgerEntry"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFilter<"LedgerEntry"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type LedgerEntryOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    walletId?: SortOrder
    creditDefId?: SortOrder
    direction?: SortOrder
    amount?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
  }

  export type LedgerEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    transactionId?: StringFilter<"LedgerEntry"> | string
    walletId?: StringFilter<"LedgerEntry"> | string
    creditDefId?: StringFilter<"LedgerEntry"> | string
    direction?: StringFilter<"LedgerEntry"> | string
    amount?: DecimalFilter<"LedgerEntry"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFilter<"LedgerEntry"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "id">

  export type LedgerEntryOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    walletId?: SortOrder
    creditDefId?: SortOrder
    direction?: SortOrder
    amount?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
    _count?: LedgerEntryCountOrderByAggregateInput
    _avg?: LedgerEntryAvgOrderByAggregateInput
    _max?: LedgerEntryMaxOrderByAggregateInput
    _min?: LedgerEntryMinOrderByAggregateInput
    _sum?: LedgerEntrySumOrderByAggregateInput
  }

  export type LedgerEntryScalarWhereWithAggregatesInput = {
    AND?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    OR?: LedgerEntryScalarWhereWithAggregatesInput[]
    NOT?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LedgerEntry"> | string
    transactionId?: StringWithAggregatesFilter<"LedgerEntry"> | string
    walletId?: StringWithAggregatesFilter<"LedgerEntry"> | string
    creditDefId?: StringWithAggregatesFilter<"LedgerEntry"> | string
    direction?: StringWithAggregatesFilter<"LedgerEntry"> | string
    amount?: DecimalWithAggregatesFilter<"LedgerEntry"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalWithAggregatesFilter<"LedgerEntry"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"LedgerEntry"> | Date | string
  }

  export type PolicyWhereInput = {
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    id?: StringFilter<"Policy"> | string
    issuerId?: StringNullableFilter<"Policy"> | string | null
    creditDefId?: StringNullableFilter<"Policy"> | string | null
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    ruleType?: StringFilter<"Policy"> | string
    parameters?: StringFilter<"Policy"> | string
    isActive?: BoolFilter<"Policy"> | boolean
    priority?: IntFilter<"Policy"> | number
    createdAt?: DateTimeFilter<"Policy"> | Date | string
    updatedAt?: DateTimeFilter<"Policy"> | Date | string
    issuer?: XOR<IssuerNullableScalarRelationFilter, IssuerWhereInput> | null
    creditDef?: XOR<VCreditDefinitionNullableScalarRelationFilter, VCreditDefinitionWhereInput> | null
  }

  export type PolicyOrderByWithRelationInput = {
    id?: SortOrder
    issuerId?: SortOrderInput | SortOrder
    creditDefId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ruleType?: SortOrder
    parameters?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    issuer?: IssuerOrderByWithRelationInput
    creditDef?: VCreditDefinitionOrderByWithRelationInput
  }

  export type PolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    issuerId?: StringNullableFilter<"Policy"> | string | null
    creditDefId?: StringNullableFilter<"Policy"> | string | null
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    ruleType?: StringFilter<"Policy"> | string
    parameters?: StringFilter<"Policy"> | string
    isActive?: BoolFilter<"Policy"> | boolean
    priority?: IntFilter<"Policy"> | number
    createdAt?: DateTimeFilter<"Policy"> | Date | string
    updatedAt?: DateTimeFilter<"Policy"> | Date | string
    issuer?: XOR<IssuerNullableScalarRelationFilter, IssuerWhereInput> | null
    creditDef?: XOR<VCreditDefinitionNullableScalarRelationFilter, VCreditDefinitionWhereInput> | null
  }, "id">

  export type PolicyOrderByWithAggregationInput = {
    id?: SortOrder
    issuerId?: SortOrderInput | SortOrder
    creditDefId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ruleType?: SortOrder
    parameters?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PolicyCountOrderByAggregateInput
    _avg?: PolicyAvgOrderByAggregateInput
    _max?: PolicyMaxOrderByAggregateInput
    _min?: PolicyMinOrderByAggregateInput
    _sum?: PolicySumOrderByAggregateInput
  }

  export type PolicyScalarWhereWithAggregatesInput = {
    AND?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    OR?: PolicyScalarWhereWithAggregatesInput[]
    NOT?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Policy"> | string
    issuerId?: StringNullableWithAggregatesFilter<"Policy"> | string | null
    creditDefId?: StringNullableWithAggregatesFilter<"Policy"> | string | null
    name?: StringWithAggregatesFilter<"Policy"> | string
    description?: StringNullableWithAggregatesFilter<"Policy"> | string | null
    ruleType?: StringWithAggregatesFilter<"Policy"> | string
    parameters?: StringWithAggregatesFilter<"Policy"> | string
    isActive?: BoolWithAggregatesFilter<"Policy"> | boolean
    priority?: IntWithAggregatesFilter<"Policy"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Policy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Policy"> | Date | string
  }

  export type PolicyEvaluationLogWhereInput = {
    AND?: PolicyEvaluationLogWhereInput | PolicyEvaluationLogWhereInput[]
    OR?: PolicyEvaluationLogWhereInput[]
    NOT?: PolicyEvaluationLogWhereInput | PolicyEvaluationLogWhereInput[]
    id?: StringFilter<"PolicyEvaluationLog"> | string
    transactionId?: StringNullableFilter<"PolicyEvaluationLog"> | string | null
    decision?: StringFilter<"PolicyEvaluationLog"> | string
    results?: StringFilter<"PolicyEvaluationLog"> | string
    createdAt?: DateTimeFilter<"PolicyEvaluationLog"> | Date | string
    transactions?: TransactionListRelationFilter
  }

  export type PolicyEvaluationLogOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    decision?: SortOrder
    results?: SortOrder
    createdAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type PolicyEvaluationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PolicyEvaluationLogWhereInput | PolicyEvaluationLogWhereInput[]
    OR?: PolicyEvaluationLogWhereInput[]
    NOT?: PolicyEvaluationLogWhereInput | PolicyEvaluationLogWhereInput[]
    transactionId?: StringNullableFilter<"PolicyEvaluationLog"> | string | null
    decision?: StringFilter<"PolicyEvaluationLog"> | string
    results?: StringFilter<"PolicyEvaluationLog"> | string
    createdAt?: DateTimeFilter<"PolicyEvaluationLog"> | Date | string
    transactions?: TransactionListRelationFilter
  }, "id">

  export type PolicyEvaluationLogOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    decision?: SortOrder
    results?: SortOrder
    createdAt?: SortOrder
    _count?: PolicyEvaluationLogCountOrderByAggregateInput
    _max?: PolicyEvaluationLogMaxOrderByAggregateInput
    _min?: PolicyEvaluationLogMinOrderByAggregateInput
  }

  export type PolicyEvaluationLogScalarWhereWithAggregatesInput = {
    AND?: PolicyEvaluationLogScalarWhereWithAggregatesInput | PolicyEvaluationLogScalarWhereWithAggregatesInput[]
    OR?: PolicyEvaluationLogScalarWhereWithAggregatesInput[]
    NOT?: PolicyEvaluationLogScalarWhereWithAggregatesInput | PolicyEvaluationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PolicyEvaluationLog"> | string
    transactionId?: StringNullableWithAggregatesFilter<"PolicyEvaluationLog"> | string | null
    decision?: StringWithAggregatesFilter<"PolicyEvaluationLog"> | string
    results?: StringWithAggregatesFilter<"PolicyEvaluationLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PolicyEvaluationLog"> | Date | string
  }

  export type ComplianceAttestationWhereInput = {
    AND?: ComplianceAttestationWhereInput | ComplianceAttestationWhereInput[]
    OR?: ComplianceAttestationWhereInput[]
    NOT?: ComplianceAttestationWhereInput | ComplianceAttestationWhereInput[]
    id?: StringFilter<"ComplianceAttestation"> | string
    userId?: StringFilter<"ComplianceAttestation"> | string
    type?: StringFilter<"ComplianceAttestation"> | string
    provider?: StringFilter<"ComplianceAttestation"> | string
    status?: StringFilter<"ComplianceAttestation"> | string
    validUntil?: DateTimeNullableFilter<"ComplianceAttestation"> | Date | string | null
    metadata?: StringNullableFilter<"ComplianceAttestation"> | string | null
    createdAt?: DateTimeFilter<"ComplianceAttestation"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceAttestation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ComplianceAttestationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ComplianceAttestationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComplianceAttestationWhereInput | ComplianceAttestationWhereInput[]
    OR?: ComplianceAttestationWhereInput[]
    NOT?: ComplianceAttestationWhereInput | ComplianceAttestationWhereInput[]
    userId?: StringFilter<"ComplianceAttestation"> | string
    type?: StringFilter<"ComplianceAttestation"> | string
    provider?: StringFilter<"ComplianceAttestation"> | string
    status?: StringFilter<"ComplianceAttestation"> | string
    validUntil?: DateTimeNullableFilter<"ComplianceAttestation"> | Date | string | null
    metadata?: StringNullableFilter<"ComplianceAttestation"> | string | null
    createdAt?: DateTimeFilter<"ComplianceAttestation"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceAttestation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ComplianceAttestationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplianceAttestationCountOrderByAggregateInput
    _max?: ComplianceAttestationMaxOrderByAggregateInput
    _min?: ComplianceAttestationMinOrderByAggregateInput
  }

  export type ComplianceAttestationScalarWhereWithAggregatesInput = {
    AND?: ComplianceAttestationScalarWhereWithAggregatesInput | ComplianceAttestationScalarWhereWithAggregatesInput[]
    OR?: ComplianceAttestationScalarWhereWithAggregatesInput[]
    NOT?: ComplianceAttestationScalarWhereWithAggregatesInput | ComplianceAttestationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComplianceAttestation"> | string
    userId?: StringWithAggregatesFilter<"ComplianceAttestation"> | string
    type?: StringWithAggregatesFilter<"ComplianceAttestation"> | string
    provider?: StringWithAggregatesFilter<"ComplianceAttestation"> | string
    status?: StringWithAggregatesFilter<"ComplianceAttestation"> | string
    validUntil?: DateTimeNullableWithAggregatesFilter<"ComplianceAttestation"> | Date | string | null
    metadata?: StringNullableWithAggregatesFilter<"ComplianceAttestation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ComplianceAttestation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComplianceAttestation"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer?: IssuerCreateNestedOneWithoutUsersInput
    merchant?: MerchantCreateNestedOneWithoutUsersInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    attestations?: ComplianceAttestationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    issuerId?: string | null
    merchantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    attestations?: ComplianceAttestationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IssuerUpdateOneWithoutUsersNestedInput
    merchant?: MerchantUpdateOneWithoutUsersNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    attestations?: ComplianceAttestationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuerId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    attestations?: ComplianceAttestationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    issuerId?: string | null
    merchantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuerId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssuerCreateInput = {
    id?: string
    name: string
    slug: string
    apiKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutIssuerInput
    creditDefs?: VCreditDefinitionCreateNestedManyWithoutIssuerInput
    policies?: PolicyCreateNestedManyWithoutIssuerInput
  }

  export type IssuerUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    apiKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutIssuerInput
    creditDefs?: VCreditDefinitionUncheckedCreateNestedManyWithoutIssuerInput
    policies?: PolicyUncheckedCreateNestedManyWithoutIssuerInput
  }

  export type IssuerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutIssuerNestedInput
    creditDefs?: VCreditDefinitionUpdateManyWithoutIssuerNestedInput
    policies?: PolicyUpdateManyWithoutIssuerNestedInput
  }

  export type IssuerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutIssuerNestedInput
    creditDefs?: VCreditDefinitionUncheckedUpdateManyWithoutIssuerNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutIssuerNestedInput
  }

  export type IssuerCreateManyInput = {
    id?: string
    name: string
    slug: string
    apiKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IssuerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssuerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantCreateInput = {
    id?: string
    name: string
    category: string
    discountRate?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutMerchantInput
    terminals?: MerchantTerminalCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateInput = {
    id?: string
    name: string
    category: string
    discountRate?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutMerchantInput
    terminals?: MerchantTerminalUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutMerchantNestedInput
    terminals?: MerchantTerminalUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutMerchantNestedInput
    terminals?: MerchantTerminalUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantCreateManyInput = {
    id?: string
    name: string
    category: string
    discountRate?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MerchantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantTerminalCreateInput = {
    id?: string
    location: string
    secretKey: string
    createdAt?: Date | string
    merchant: MerchantCreateNestedOneWithoutTerminalsInput
  }

  export type MerchantTerminalUncheckedCreateInput = {
    id?: string
    merchantId: string
    location: string
    secretKey: string
    createdAt?: Date | string
  }

  export type MerchantTerminalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneRequiredWithoutTerminalsNestedInput
  }

  export type MerchantTerminalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantTerminalCreateManyInput = {
    id?: string
    merchantId: string
    location: string
    secretKey: string
    createdAt?: Date | string
  }

  export type MerchantTerminalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantTerminalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    merchantId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VCreditDefinitionCreateInput = {
    id?: string
    name: string
    symbol: string
    decimals?: number
    type: string
    exchangeRateBaseUSD?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: IssuerCreateNestedOneWithoutCreditDefsInput
    balances?: BalanceCreateNestedManyWithoutCreditDefInput
    policies?: PolicyCreateNestedManyWithoutCreditDefInput
    liquidityPool?: LiquidityPoolCreateNestedOneWithoutCreditDefInput
  }

  export type VCreditDefinitionUncheckedCreateInput = {
    id?: string
    issuerId: string
    name: string
    symbol: string
    decimals?: number
    type: string
    exchangeRateBaseUSD?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutCreditDefInput
    policies?: PolicyUncheckedCreateNestedManyWithoutCreditDefInput
    liquidityPool?: LiquidityPoolUncheckedCreateNestedOneWithoutCreditDefInput
  }

  export type VCreditDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IssuerUpdateOneRequiredWithoutCreditDefsNestedInput
    balances?: BalanceUpdateManyWithoutCreditDefNestedInput
    policies?: PolicyUpdateManyWithoutCreditDefNestedInput
    liquidityPool?: LiquidityPoolUpdateOneWithoutCreditDefNestedInput
  }

  export type VCreditDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutCreditDefNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutCreditDefNestedInput
    liquidityPool?: LiquidityPoolUncheckedUpdateOneWithoutCreditDefNestedInput
  }

  export type VCreditDefinitionCreateManyInput = {
    id?: string
    issuerId: string
    name: string
    symbol: string
    decimals?: number
    type: string
    exchangeRateBaseUSD?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VCreditDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VCreditDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiquidityPoolCreateInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    currency?: string
    updatedAt?: Date | string
    creditDef: VCreditDefinitionCreateNestedOneWithoutLiquidityPoolInput
  }

  export type LiquidityPoolUncheckedCreateInput = {
    id?: string
    creditDefId: string
    balance?: Decimal | DecimalJsLike | number | string
    currency?: string
    updatedAt?: Date | string
  }

  export type LiquidityPoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditDef?: VCreditDefinitionUpdateOneRequiredWithoutLiquidityPoolNestedInput
  }

  export type LiquidityPoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiquidityPoolCreateManyInput = {
    id?: string
    creditDefId: string
    balance?: Decimal | DecimalJsLike | number | string
    currency?: string
    updatedAt?: Date | string
  }

  export type LiquidityPoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiquidityPoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    type?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWalletsInput
    balances?: BalanceCreateNestedManyWithoutWalletInput
    transactions?: TransactionCreateNestedManyWithoutSenderWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    userId?: string | null
    type?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutWalletInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSenderWalletInput
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWalletsNestedInput
    balances?: BalanceUpdateManyWithoutWalletNestedInput
    transactions?: TransactionUpdateManyWithoutSenderWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutWalletNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSenderWalletNestedInput
  }

  export type WalletCreateManyInput = {
    id?: string
    userId?: string | null
    type?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceCreateInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    wallet: WalletCreateNestedOneWithoutBalancesInput
    creditDef: VCreditDefinitionCreateNestedOneWithoutBalancesInput
  }

  export type BalanceUncheckedCreateInput = {
    id?: string
    walletId: string
    creditDefId: string
    amount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type BalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletUpdateOneRequiredWithoutBalancesNestedInput
    creditDef?: VCreditDefinitionUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type BalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceCreateManyInput = {
    id?: string
    walletId: string
    creditDefId: string
    amount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type BalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    referenceRef?: string | null
    type: string
    status?: string
    recipientWalletId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    finalizedAt?: Date | string | null
    senderWallet?: WalletCreateNestedOneWithoutTransactionsInput
    policyLog?: PolicyEvaluationLogCreateNestedOneWithoutTransactionsInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    referenceRef?: string | null
    type: string
    status?: string
    senderWalletId?: string | null
    recipientWalletId?: string | null
    metadata?: string | null
    policyLogId?: string | null
    createdAt?: Date | string
    finalizedAt?: Date | string | null
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipientWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderWallet?: WalletUpdateOneWithoutTransactionsNestedInput
    policyLog?: PolicyEvaluationLogUpdateOneWithoutTransactionsNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    senderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    policyLogId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    referenceRef?: string | null
    type: string
    status?: string
    senderWalletId?: string | null
    recipientWalletId?: string | null
    metadata?: string | null
    policyLogId?: string | null
    createdAt?: Date | string
    finalizedAt?: Date | string | null
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipientWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    senderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    policyLogId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LedgerEntryCreateInput = {
    id?: string
    walletId: string
    creditDefId: string
    direction: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateInput = {
    id?: string
    transactionId: string
    walletId: string
    creditDefId: string
    direction: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateManyInput = {
    id?: string
    transactionId: string
    walletId: string
    creditDefId: string
    direction: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyCreateInput = {
    id?: string
    name: string
    description?: string | null
    ruleType: string
    parameters: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer?: IssuerCreateNestedOneWithoutPoliciesInput
    creditDef?: VCreditDefinitionCreateNestedOneWithoutPoliciesInput
  }

  export type PolicyUncheckedCreateInput = {
    id?: string
    issuerId?: string | null
    creditDefId?: string | null
    name: string
    description?: string | null
    ruleType: string
    parameters: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IssuerUpdateOneWithoutPoliciesNestedInput
    creditDef?: VCreditDefinitionUpdateOneWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuerId?: NullableStringFieldUpdateOperationsInput | string | null
    creditDefId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyCreateManyInput = {
    id?: string
    issuerId?: string | null
    creditDefId?: string | null
    name: string
    description?: string | null
    ruleType: string
    parameters: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuerId?: NullableStringFieldUpdateOperationsInput | string | null
    creditDefId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyEvaluationLogCreateInput = {
    id?: string
    transactionId?: string | null
    decision: string
    results: string
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutPolicyLogInput
  }

  export type PolicyEvaluationLogUncheckedCreateInput = {
    id?: string
    transactionId?: string | null
    decision: string
    results: string
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutPolicyLogInput
  }

  export type PolicyEvaluationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: StringFieldUpdateOperationsInput | string
    results?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutPolicyLogNestedInput
  }

  export type PolicyEvaluationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: StringFieldUpdateOperationsInput | string
    results?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutPolicyLogNestedInput
  }

  export type PolicyEvaluationLogCreateManyInput = {
    id?: string
    transactionId?: string | null
    decision: string
    results: string
    createdAt?: Date | string
  }

  export type PolicyEvaluationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: StringFieldUpdateOperationsInput | string
    results?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyEvaluationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: StringFieldUpdateOperationsInput | string
    results?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceAttestationCreateInput = {
    id?: string
    type: string
    provider: string
    status: string
    validUntil?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttestationsInput
  }

  export type ComplianceAttestationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    status: string
    validUntil?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceAttestationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttestationsNestedInput
  }

  export type ComplianceAttestationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceAttestationCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    status: string
    validUntil?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceAttestationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceAttestationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IssuerNullableScalarRelationFilter = {
    is?: IssuerWhereInput | null
    isNot?: IssuerWhereInput | null
  }

  export type MerchantNullableScalarRelationFilter = {
    is?: MerchantWhereInput | null
    isNot?: MerchantWhereInput | null
  }

  export type WalletListRelationFilter = {
    every?: WalletWhereInput
    some?: WalletWhereInput
    none?: WalletWhereInput
  }

  export type ComplianceAttestationListRelationFilter = {
    every?: ComplianceAttestationWhereInput
    some?: ComplianceAttestationWhereInput
    none?: ComplianceAttestationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type WalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplianceAttestationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    issuerId?: SortOrder
    merchantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    issuerId?: SortOrder
    merchantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    issuerId?: SortOrder
    merchantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type VCreditDefinitionListRelationFilter = {
    every?: VCreditDefinitionWhereInput
    some?: VCreditDefinitionWhereInput
    none?: VCreditDefinitionWhereInput
  }

  export type PolicyListRelationFilter = {
    every?: PolicyWhereInput
    some?: PolicyWhereInput
    none?: PolicyWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VCreditDefinitionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IssuerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IssuerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IssuerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type MerchantTerminalListRelationFilter = {
    every?: MerchantTerminalWhereInput
    some?: MerchantTerminalWhereInput
    none?: MerchantTerminalWhereInput
  }

  export type MerchantTerminalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MerchantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    discountRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantAvgOrderByAggregateInput = {
    discountRate?: SortOrder
  }

  export type MerchantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    discountRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    discountRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MerchantSumOrderByAggregateInput = {
    discountRate?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type MerchantScalarRelationFilter = {
    is?: MerchantWhereInput
    isNot?: MerchantWhereInput
  }

  export type MerchantTerminalCountOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    location?: SortOrder
    secretKey?: SortOrder
    createdAt?: SortOrder
  }

  export type MerchantTerminalMaxOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    location?: SortOrder
    secretKey?: SortOrder
    createdAt?: SortOrder
  }

  export type MerchantTerminalMinOrderByAggregateInput = {
    id?: SortOrder
    merchantId?: SortOrder
    location?: SortOrder
    secretKey?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IssuerScalarRelationFilter = {
    is?: IssuerWhereInput
    isNot?: IssuerWhereInput
  }

  export type BalanceListRelationFilter = {
    every?: BalanceWhereInput
    some?: BalanceWhereInput
    none?: BalanceWhereInput
  }

  export type LiquidityPoolNullableScalarRelationFilter = {
    is?: LiquidityPoolWhereInput | null
    isNot?: LiquidityPoolWhereInput | null
  }

  export type BalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VCreditDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    issuerId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    type?: SortOrder
    exchangeRateBaseUSD?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VCreditDefinitionAvgOrderByAggregateInput = {
    decimals?: SortOrder
    exchangeRateBaseUSD?: SortOrder
  }

  export type VCreditDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    issuerId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    type?: SortOrder
    exchangeRateBaseUSD?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VCreditDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    issuerId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    type?: SortOrder
    exchangeRateBaseUSD?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VCreditDefinitionSumOrderByAggregateInput = {
    decimals?: SortOrder
    exchangeRateBaseUSD?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type VCreditDefinitionScalarRelationFilter = {
    is?: VCreditDefinitionWhereInput
    isNot?: VCreditDefinitionWhereInput
  }

  export type LiquidityPoolCountOrderByAggregateInput = {
    id?: SortOrder
    creditDefId?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiquidityPoolAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type LiquidityPoolMaxOrderByAggregateInput = {
    id?: SortOrder
    creditDefId?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiquidityPoolMinOrderByAggregateInput = {
    id?: SortOrder
    creditDefId?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiquidityPoolSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletScalarRelationFilter = {
    is?: WalletWhereInput
    isNot?: WalletWhereInput
  }

  export type BalanceWalletIdCreditDefIdCompoundUniqueInput = {
    walletId: string
    creditDefId: string
  }

  export type BalanceCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    creditDefId?: SortOrder
    amount?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalanceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    creditDefId?: SortOrder
    amount?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalanceMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    creditDefId?: SortOrder
    amount?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalanceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type WalletNullableScalarRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type PolicyEvaluationLogNullableScalarRelationFilter = {
    is?: PolicyEvaluationLogWhereInput | null
    isNot?: PolicyEvaluationLogWhereInput | null
  }

  export type LedgerEntryListRelationFilter = {
    every?: LedgerEntryWhereInput
    some?: LedgerEntryWhereInput
    none?: LedgerEntryWhereInput
  }

  export type LedgerEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    referenceRef?: SortOrder
    type?: SortOrder
    status?: SortOrder
    senderWalletId?: SortOrder
    recipientWalletId?: SortOrder
    metadata?: SortOrder
    policyLogId?: SortOrder
    createdAt?: SortOrder
    finalizedAt?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    referenceRef?: SortOrder
    type?: SortOrder
    status?: SortOrder
    senderWalletId?: SortOrder
    recipientWalletId?: SortOrder
    metadata?: SortOrder
    policyLogId?: SortOrder
    createdAt?: SortOrder
    finalizedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    referenceRef?: SortOrder
    type?: SortOrder
    status?: SortOrder
    senderWalletId?: SortOrder
    recipientWalletId?: SortOrder
    metadata?: SortOrder
    policyLogId?: SortOrder
    createdAt?: SortOrder
    finalizedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type LedgerEntryCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    walletId?: SortOrder
    creditDefId?: SortOrder
    direction?: SortOrder
    amount?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntryAvgOrderByAggregateInput = {
    amount?: SortOrder
    balanceAfter?: SortOrder
  }

  export type LedgerEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    walletId?: SortOrder
    creditDefId?: SortOrder
    direction?: SortOrder
    amount?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntryMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    walletId?: SortOrder
    creditDefId?: SortOrder
    direction?: SortOrder
    amount?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntrySumOrderByAggregateInput = {
    amount?: SortOrder
    balanceAfter?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type VCreditDefinitionNullableScalarRelationFilter = {
    is?: VCreditDefinitionWhereInput | null
    isNot?: VCreditDefinitionWhereInput | null
  }

  export type PolicyCountOrderByAggregateInput = {
    id?: SortOrder
    issuerId?: SortOrder
    creditDefId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ruleType?: SortOrder
    parameters?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type PolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    issuerId?: SortOrder
    creditDefId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ruleType?: SortOrder
    parameters?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyMinOrderByAggregateInput = {
    id?: SortOrder
    issuerId?: SortOrder
    creditDefId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ruleType?: SortOrder
    parameters?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicySumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PolicyEvaluationLogCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    decision?: SortOrder
    results?: SortOrder
    createdAt?: SortOrder
  }

  export type PolicyEvaluationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    decision?: SortOrder
    results?: SortOrder
    createdAt?: SortOrder
  }

  export type PolicyEvaluationLogMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    decision?: SortOrder
    results?: SortOrder
    createdAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ComplianceAttestationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceAttestationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceAttestationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IssuerCreateNestedOneWithoutUsersInput = {
    create?: XOR<IssuerCreateWithoutUsersInput, IssuerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: IssuerCreateOrConnectWithoutUsersInput
    connect?: IssuerWhereUniqueInput
  }

  export type MerchantCreateNestedOneWithoutUsersInput = {
    create?: XOR<MerchantCreateWithoutUsersInput, MerchantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutUsersInput
    connect?: MerchantWhereUniqueInput
  }

  export type WalletCreateNestedManyWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput> | WalletCreateWithoutUserInput[] | WalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput | WalletCreateOrConnectWithoutUserInput[]
    createMany?: WalletCreateManyUserInputEnvelope
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
  }

  export type ComplianceAttestationCreateNestedManyWithoutUserInput = {
    create?: XOR<ComplianceAttestationCreateWithoutUserInput, ComplianceAttestationUncheckedCreateWithoutUserInput> | ComplianceAttestationCreateWithoutUserInput[] | ComplianceAttestationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplianceAttestationCreateOrConnectWithoutUserInput | ComplianceAttestationCreateOrConnectWithoutUserInput[]
    createMany?: ComplianceAttestationCreateManyUserInputEnvelope
    connect?: ComplianceAttestationWhereUniqueInput | ComplianceAttestationWhereUniqueInput[]
  }

  export type WalletUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput> | WalletCreateWithoutUserInput[] | WalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput | WalletCreateOrConnectWithoutUserInput[]
    createMany?: WalletCreateManyUserInputEnvelope
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
  }

  export type ComplianceAttestationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ComplianceAttestationCreateWithoutUserInput, ComplianceAttestationUncheckedCreateWithoutUserInput> | ComplianceAttestationCreateWithoutUserInput[] | ComplianceAttestationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplianceAttestationCreateOrConnectWithoutUserInput | ComplianceAttestationCreateOrConnectWithoutUserInput[]
    createMany?: ComplianceAttestationCreateManyUserInputEnvelope
    connect?: ComplianceAttestationWhereUniqueInput | ComplianceAttestationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IssuerUpdateOneWithoutUsersNestedInput = {
    create?: XOR<IssuerCreateWithoutUsersInput, IssuerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: IssuerCreateOrConnectWithoutUsersInput
    upsert?: IssuerUpsertWithoutUsersInput
    disconnect?: IssuerWhereInput | boolean
    delete?: IssuerWhereInput | boolean
    connect?: IssuerWhereUniqueInput
    update?: XOR<XOR<IssuerUpdateToOneWithWhereWithoutUsersInput, IssuerUpdateWithoutUsersInput>, IssuerUncheckedUpdateWithoutUsersInput>
  }

  export type MerchantUpdateOneWithoutUsersNestedInput = {
    create?: XOR<MerchantCreateWithoutUsersInput, MerchantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutUsersInput
    upsert?: MerchantUpsertWithoutUsersInput
    disconnect?: MerchantWhereInput | boolean
    delete?: MerchantWhereInput | boolean
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutUsersInput, MerchantUpdateWithoutUsersInput>, MerchantUncheckedUpdateWithoutUsersInput>
  }

  export type WalletUpdateManyWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput> | WalletCreateWithoutUserInput[] | WalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput | WalletCreateOrConnectWithoutUserInput[]
    upsert?: WalletUpsertWithWhereUniqueWithoutUserInput | WalletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WalletCreateManyUserInputEnvelope
    set?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    disconnect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    delete?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    update?: WalletUpdateWithWhereUniqueWithoutUserInput | WalletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WalletUpdateManyWithWhereWithoutUserInput | WalletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WalletScalarWhereInput | WalletScalarWhereInput[]
  }

  export type ComplianceAttestationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComplianceAttestationCreateWithoutUserInput, ComplianceAttestationUncheckedCreateWithoutUserInput> | ComplianceAttestationCreateWithoutUserInput[] | ComplianceAttestationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplianceAttestationCreateOrConnectWithoutUserInput | ComplianceAttestationCreateOrConnectWithoutUserInput[]
    upsert?: ComplianceAttestationUpsertWithWhereUniqueWithoutUserInput | ComplianceAttestationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComplianceAttestationCreateManyUserInputEnvelope
    set?: ComplianceAttestationWhereUniqueInput | ComplianceAttestationWhereUniqueInput[]
    disconnect?: ComplianceAttestationWhereUniqueInput | ComplianceAttestationWhereUniqueInput[]
    delete?: ComplianceAttestationWhereUniqueInput | ComplianceAttestationWhereUniqueInput[]
    connect?: ComplianceAttestationWhereUniqueInput | ComplianceAttestationWhereUniqueInput[]
    update?: ComplianceAttestationUpdateWithWhereUniqueWithoutUserInput | ComplianceAttestationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComplianceAttestationUpdateManyWithWhereWithoutUserInput | ComplianceAttestationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComplianceAttestationScalarWhereInput | ComplianceAttestationScalarWhereInput[]
  }

  export type WalletUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput> | WalletCreateWithoutUserInput[] | WalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput | WalletCreateOrConnectWithoutUserInput[]
    upsert?: WalletUpsertWithWhereUniqueWithoutUserInput | WalletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WalletCreateManyUserInputEnvelope
    set?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    disconnect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    delete?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    update?: WalletUpdateWithWhereUniqueWithoutUserInput | WalletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WalletUpdateManyWithWhereWithoutUserInput | WalletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WalletScalarWhereInput | WalletScalarWhereInput[]
  }

  export type ComplianceAttestationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComplianceAttestationCreateWithoutUserInput, ComplianceAttestationUncheckedCreateWithoutUserInput> | ComplianceAttestationCreateWithoutUserInput[] | ComplianceAttestationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplianceAttestationCreateOrConnectWithoutUserInput | ComplianceAttestationCreateOrConnectWithoutUserInput[]
    upsert?: ComplianceAttestationUpsertWithWhereUniqueWithoutUserInput | ComplianceAttestationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComplianceAttestationCreateManyUserInputEnvelope
    set?: ComplianceAttestationWhereUniqueInput | ComplianceAttestationWhereUniqueInput[]
    disconnect?: ComplianceAttestationWhereUniqueInput | ComplianceAttestationWhereUniqueInput[]
    delete?: ComplianceAttestationWhereUniqueInput | ComplianceAttestationWhereUniqueInput[]
    connect?: ComplianceAttestationWhereUniqueInput | ComplianceAttestationWhereUniqueInput[]
    update?: ComplianceAttestationUpdateWithWhereUniqueWithoutUserInput | ComplianceAttestationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComplianceAttestationUpdateManyWithWhereWithoutUserInput | ComplianceAttestationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComplianceAttestationScalarWhereInput | ComplianceAttestationScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutIssuerInput = {
    create?: XOR<UserCreateWithoutIssuerInput, UserUncheckedCreateWithoutIssuerInput> | UserCreateWithoutIssuerInput[] | UserUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutIssuerInput | UserCreateOrConnectWithoutIssuerInput[]
    createMany?: UserCreateManyIssuerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VCreditDefinitionCreateNestedManyWithoutIssuerInput = {
    create?: XOR<VCreditDefinitionCreateWithoutIssuerInput, VCreditDefinitionUncheckedCreateWithoutIssuerInput> | VCreditDefinitionCreateWithoutIssuerInput[] | VCreditDefinitionUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: VCreditDefinitionCreateOrConnectWithoutIssuerInput | VCreditDefinitionCreateOrConnectWithoutIssuerInput[]
    createMany?: VCreditDefinitionCreateManyIssuerInputEnvelope
    connect?: VCreditDefinitionWhereUniqueInput | VCreditDefinitionWhereUniqueInput[]
  }

  export type PolicyCreateNestedManyWithoutIssuerInput = {
    create?: XOR<PolicyCreateWithoutIssuerInput, PolicyUncheckedCreateWithoutIssuerInput> | PolicyCreateWithoutIssuerInput[] | PolicyUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutIssuerInput | PolicyCreateOrConnectWithoutIssuerInput[]
    createMany?: PolicyCreateManyIssuerInputEnvelope
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutIssuerInput = {
    create?: XOR<UserCreateWithoutIssuerInput, UserUncheckedCreateWithoutIssuerInput> | UserCreateWithoutIssuerInput[] | UserUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutIssuerInput | UserCreateOrConnectWithoutIssuerInput[]
    createMany?: UserCreateManyIssuerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VCreditDefinitionUncheckedCreateNestedManyWithoutIssuerInput = {
    create?: XOR<VCreditDefinitionCreateWithoutIssuerInput, VCreditDefinitionUncheckedCreateWithoutIssuerInput> | VCreditDefinitionCreateWithoutIssuerInput[] | VCreditDefinitionUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: VCreditDefinitionCreateOrConnectWithoutIssuerInput | VCreditDefinitionCreateOrConnectWithoutIssuerInput[]
    createMany?: VCreditDefinitionCreateManyIssuerInputEnvelope
    connect?: VCreditDefinitionWhereUniqueInput | VCreditDefinitionWhereUniqueInput[]
  }

  export type PolicyUncheckedCreateNestedManyWithoutIssuerInput = {
    create?: XOR<PolicyCreateWithoutIssuerInput, PolicyUncheckedCreateWithoutIssuerInput> | PolicyCreateWithoutIssuerInput[] | PolicyUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutIssuerInput | PolicyCreateOrConnectWithoutIssuerInput[]
    createMany?: PolicyCreateManyIssuerInputEnvelope
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutIssuerNestedInput = {
    create?: XOR<UserCreateWithoutIssuerInput, UserUncheckedCreateWithoutIssuerInput> | UserCreateWithoutIssuerInput[] | UserUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutIssuerInput | UserCreateOrConnectWithoutIssuerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutIssuerInput | UserUpsertWithWhereUniqueWithoutIssuerInput[]
    createMany?: UserCreateManyIssuerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutIssuerInput | UserUpdateWithWhereUniqueWithoutIssuerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutIssuerInput | UserUpdateManyWithWhereWithoutIssuerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VCreditDefinitionUpdateManyWithoutIssuerNestedInput = {
    create?: XOR<VCreditDefinitionCreateWithoutIssuerInput, VCreditDefinitionUncheckedCreateWithoutIssuerInput> | VCreditDefinitionCreateWithoutIssuerInput[] | VCreditDefinitionUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: VCreditDefinitionCreateOrConnectWithoutIssuerInput | VCreditDefinitionCreateOrConnectWithoutIssuerInput[]
    upsert?: VCreditDefinitionUpsertWithWhereUniqueWithoutIssuerInput | VCreditDefinitionUpsertWithWhereUniqueWithoutIssuerInput[]
    createMany?: VCreditDefinitionCreateManyIssuerInputEnvelope
    set?: VCreditDefinitionWhereUniqueInput | VCreditDefinitionWhereUniqueInput[]
    disconnect?: VCreditDefinitionWhereUniqueInput | VCreditDefinitionWhereUniqueInput[]
    delete?: VCreditDefinitionWhereUniqueInput | VCreditDefinitionWhereUniqueInput[]
    connect?: VCreditDefinitionWhereUniqueInput | VCreditDefinitionWhereUniqueInput[]
    update?: VCreditDefinitionUpdateWithWhereUniqueWithoutIssuerInput | VCreditDefinitionUpdateWithWhereUniqueWithoutIssuerInput[]
    updateMany?: VCreditDefinitionUpdateManyWithWhereWithoutIssuerInput | VCreditDefinitionUpdateManyWithWhereWithoutIssuerInput[]
    deleteMany?: VCreditDefinitionScalarWhereInput | VCreditDefinitionScalarWhereInput[]
  }

  export type PolicyUpdateManyWithoutIssuerNestedInput = {
    create?: XOR<PolicyCreateWithoutIssuerInput, PolicyUncheckedCreateWithoutIssuerInput> | PolicyCreateWithoutIssuerInput[] | PolicyUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutIssuerInput | PolicyCreateOrConnectWithoutIssuerInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutIssuerInput | PolicyUpsertWithWhereUniqueWithoutIssuerInput[]
    createMany?: PolicyCreateManyIssuerInputEnvelope
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutIssuerInput | PolicyUpdateWithWhereUniqueWithoutIssuerInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutIssuerInput | PolicyUpdateManyWithWhereWithoutIssuerInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutIssuerNestedInput = {
    create?: XOR<UserCreateWithoutIssuerInput, UserUncheckedCreateWithoutIssuerInput> | UserCreateWithoutIssuerInput[] | UserUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutIssuerInput | UserCreateOrConnectWithoutIssuerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutIssuerInput | UserUpsertWithWhereUniqueWithoutIssuerInput[]
    createMany?: UserCreateManyIssuerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutIssuerInput | UserUpdateWithWhereUniqueWithoutIssuerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutIssuerInput | UserUpdateManyWithWhereWithoutIssuerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VCreditDefinitionUncheckedUpdateManyWithoutIssuerNestedInput = {
    create?: XOR<VCreditDefinitionCreateWithoutIssuerInput, VCreditDefinitionUncheckedCreateWithoutIssuerInput> | VCreditDefinitionCreateWithoutIssuerInput[] | VCreditDefinitionUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: VCreditDefinitionCreateOrConnectWithoutIssuerInput | VCreditDefinitionCreateOrConnectWithoutIssuerInput[]
    upsert?: VCreditDefinitionUpsertWithWhereUniqueWithoutIssuerInput | VCreditDefinitionUpsertWithWhereUniqueWithoutIssuerInput[]
    createMany?: VCreditDefinitionCreateManyIssuerInputEnvelope
    set?: VCreditDefinitionWhereUniqueInput | VCreditDefinitionWhereUniqueInput[]
    disconnect?: VCreditDefinitionWhereUniqueInput | VCreditDefinitionWhereUniqueInput[]
    delete?: VCreditDefinitionWhereUniqueInput | VCreditDefinitionWhereUniqueInput[]
    connect?: VCreditDefinitionWhereUniqueInput | VCreditDefinitionWhereUniqueInput[]
    update?: VCreditDefinitionUpdateWithWhereUniqueWithoutIssuerInput | VCreditDefinitionUpdateWithWhereUniqueWithoutIssuerInput[]
    updateMany?: VCreditDefinitionUpdateManyWithWhereWithoutIssuerInput | VCreditDefinitionUpdateManyWithWhereWithoutIssuerInput[]
    deleteMany?: VCreditDefinitionScalarWhereInput | VCreditDefinitionScalarWhereInput[]
  }

  export type PolicyUncheckedUpdateManyWithoutIssuerNestedInput = {
    create?: XOR<PolicyCreateWithoutIssuerInput, PolicyUncheckedCreateWithoutIssuerInput> | PolicyCreateWithoutIssuerInput[] | PolicyUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutIssuerInput | PolicyCreateOrConnectWithoutIssuerInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutIssuerInput | PolicyUpsertWithWhereUniqueWithoutIssuerInput[]
    createMany?: PolicyCreateManyIssuerInputEnvelope
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutIssuerInput | PolicyUpdateWithWhereUniqueWithoutIssuerInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutIssuerInput | PolicyUpdateManyWithWhereWithoutIssuerInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutMerchantInput = {
    create?: XOR<UserCreateWithoutMerchantInput, UserUncheckedCreateWithoutMerchantInput> | UserCreateWithoutMerchantInput[] | UserUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMerchantInput | UserCreateOrConnectWithoutMerchantInput[]
    createMany?: UserCreateManyMerchantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MerchantTerminalCreateNestedManyWithoutMerchantInput = {
    create?: XOR<MerchantTerminalCreateWithoutMerchantInput, MerchantTerminalUncheckedCreateWithoutMerchantInput> | MerchantTerminalCreateWithoutMerchantInput[] | MerchantTerminalUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: MerchantTerminalCreateOrConnectWithoutMerchantInput | MerchantTerminalCreateOrConnectWithoutMerchantInput[]
    createMany?: MerchantTerminalCreateManyMerchantInputEnvelope
    connect?: MerchantTerminalWhereUniqueInput | MerchantTerminalWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<UserCreateWithoutMerchantInput, UserUncheckedCreateWithoutMerchantInput> | UserCreateWithoutMerchantInput[] | UserUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMerchantInput | UserCreateOrConnectWithoutMerchantInput[]
    createMany?: UserCreateManyMerchantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MerchantTerminalUncheckedCreateNestedManyWithoutMerchantInput = {
    create?: XOR<MerchantTerminalCreateWithoutMerchantInput, MerchantTerminalUncheckedCreateWithoutMerchantInput> | MerchantTerminalCreateWithoutMerchantInput[] | MerchantTerminalUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: MerchantTerminalCreateOrConnectWithoutMerchantInput | MerchantTerminalCreateOrConnectWithoutMerchantInput[]
    createMany?: MerchantTerminalCreateManyMerchantInputEnvelope
    connect?: MerchantTerminalWhereUniqueInput | MerchantTerminalWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<UserCreateWithoutMerchantInput, UserUncheckedCreateWithoutMerchantInput> | UserCreateWithoutMerchantInput[] | UserUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMerchantInput | UserCreateOrConnectWithoutMerchantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutMerchantInput | UserUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: UserCreateManyMerchantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutMerchantInput | UserUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutMerchantInput | UserUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MerchantTerminalUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<MerchantTerminalCreateWithoutMerchantInput, MerchantTerminalUncheckedCreateWithoutMerchantInput> | MerchantTerminalCreateWithoutMerchantInput[] | MerchantTerminalUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: MerchantTerminalCreateOrConnectWithoutMerchantInput | MerchantTerminalCreateOrConnectWithoutMerchantInput[]
    upsert?: MerchantTerminalUpsertWithWhereUniqueWithoutMerchantInput | MerchantTerminalUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: MerchantTerminalCreateManyMerchantInputEnvelope
    set?: MerchantTerminalWhereUniqueInput | MerchantTerminalWhereUniqueInput[]
    disconnect?: MerchantTerminalWhereUniqueInput | MerchantTerminalWhereUniqueInput[]
    delete?: MerchantTerminalWhereUniqueInput | MerchantTerminalWhereUniqueInput[]
    connect?: MerchantTerminalWhereUniqueInput | MerchantTerminalWhereUniqueInput[]
    update?: MerchantTerminalUpdateWithWhereUniqueWithoutMerchantInput | MerchantTerminalUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: MerchantTerminalUpdateManyWithWhereWithoutMerchantInput | MerchantTerminalUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: MerchantTerminalScalarWhereInput | MerchantTerminalScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<UserCreateWithoutMerchantInput, UserUncheckedCreateWithoutMerchantInput> | UserCreateWithoutMerchantInput[] | UserUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMerchantInput | UserCreateOrConnectWithoutMerchantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutMerchantInput | UserUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: UserCreateManyMerchantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutMerchantInput | UserUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutMerchantInput | UserUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MerchantTerminalUncheckedUpdateManyWithoutMerchantNestedInput = {
    create?: XOR<MerchantTerminalCreateWithoutMerchantInput, MerchantTerminalUncheckedCreateWithoutMerchantInput> | MerchantTerminalCreateWithoutMerchantInput[] | MerchantTerminalUncheckedCreateWithoutMerchantInput[]
    connectOrCreate?: MerchantTerminalCreateOrConnectWithoutMerchantInput | MerchantTerminalCreateOrConnectWithoutMerchantInput[]
    upsert?: MerchantTerminalUpsertWithWhereUniqueWithoutMerchantInput | MerchantTerminalUpsertWithWhereUniqueWithoutMerchantInput[]
    createMany?: MerchantTerminalCreateManyMerchantInputEnvelope
    set?: MerchantTerminalWhereUniqueInput | MerchantTerminalWhereUniqueInput[]
    disconnect?: MerchantTerminalWhereUniqueInput | MerchantTerminalWhereUniqueInput[]
    delete?: MerchantTerminalWhereUniqueInput | MerchantTerminalWhereUniqueInput[]
    connect?: MerchantTerminalWhereUniqueInput | MerchantTerminalWhereUniqueInput[]
    update?: MerchantTerminalUpdateWithWhereUniqueWithoutMerchantInput | MerchantTerminalUpdateWithWhereUniqueWithoutMerchantInput[]
    updateMany?: MerchantTerminalUpdateManyWithWhereWithoutMerchantInput | MerchantTerminalUpdateManyWithWhereWithoutMerchantInput[]
    deleteMany?: MerchantTerminalScalarWhereInput | MerchantTerminalScalarWhereInput[]
  }

  export type MerchantCreateNestedOneWithoutTerminalsInput = {
    create?: XOR<MerchantCreateWithoutTerminalsInput, MerchantUncheckedCreateWithoutTerminalsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutTerminalsInput
    connect?: MerchantWhereUniqueInput
  }

  export type MerchantUpdateOneRequiredWithoutTerminalsNestedInput = {
    create?: XOR<MerchantCreateWithoutTerminalsInput, MerchantUncheckedCreateWithoutTerminalsInput>
    connectOrCreate?: MerchantCreateOrConnectWithoutTerminalsInput
    upsert?: MerchantUpsertWithoutTerminalsInput
    connect?: MerchantWhereUniqueInput
    update?: XOR<XOR<MerchantUpdateToOneWithWhereWithoutTerminalsInput, MerchantUpdateWithoutTerminalsInput>, MerchantUncheckedUpdateWithoutTerminalsInput>
  }

  export type IssuerCreateNestedOneWithoutCreditDefsInput = {
    create?: XOR<IssuerCreateWithoutCreditDefsInput, IssuerUncheckedCreateWithoutCreditDefsInput>
    connectOrCreate?: IssuerCreateOrConnectWithoutCreditDefsInput
    connect?: IssuerWhereUniqueInput
  }

  export type BalanceCreateNestedManyWithoutCreditDefInput = {
    create?: XOR<BalanceCreateWithoutCreditDefInput, BalanceUncheckedCreateWithoutCreditDefInput> | BalanceCreateWithoutCreditDefInput[] | BalanceUncheckedCreateWithoutCreditDefInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutCreditDefInput | BalanceCreateOrConnectWithoutCreditDefInput[]
    createMany?: BalanceCreateManyCreditDefInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type PolicyCreateNestedManyWithoutCreditDefInput = {
    create?: XOR<PolicyCreateWithoutCreditDefInput, PolicyUncheckedCreateWithoutCreditDefInput> | PolicyCreateWithoutCreditDefInput[] | PolicyUncheckedCreateWithoutCreditDefInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutCreditDefInput | PolicyCreateOrConnectWithoutCreditDefInput[]
    createMany?: PolicyCreateManyCreditDefInputEnvelope
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type LiquidityPoolCreateNestedOneWithoutCreditDefInput = {
    create?: XOR<LiquidityPoolCreateWithoutCreditDefInput, LiquidityPoolUncheckedCreateWithoutCreditDefInput>
    connectOrCreate?: LiquidityPoolCreateOrConnectWithoutCreditDefInput
    connect?: LiquidityPoolWhereUniqueInput
  }

  export type BalanceUncheckedCreateNestedManyWithoutCreditDefInput = {
    create?: XOR<BalanceCreateWithoutCreditDefInput, BalanceUncheckedCreateWithoutCreditDefInput> | BalanceCreateWithoutCreditDefInput[] | BalanceUncheckedCreateWithoutCreditDefInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutCreditDefInput | BalanceCreateOrConnectWithoutCreditDefInput[]
    createMany?: BalanceCreateManyCreditDefInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type PolicyUncheckedCreateNestedManyWithoutCreditDefInput = {
    create?: XOR<PolicyCreateWithoutCreditDefInput, PolicyUncheckedCreateWithoutCreditDefInput> | PolicyCreateWithoutCreditDefInput[] | PolicyUncheckedCreateWithoutCreditDefInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutCreditDefInput | PolicyCreateOrConnectWithoutCreditDefInput[]
    createMany?: PolicyCreateManyCreditDefInputEnvelope
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
  }

  export type LiquidityPoolUncheckedCreateNestedOneWithoutCreditDefInput = {
    create?: XOR<LiquidityPoolCreateWithoutCreditDefInput, LiquidityPoolUncheckedCreateWithoutCreditDefInput>
    connectOrCreate?: LiquidityPoolCreateOrConnectWithoutCreditDefInput
    connect?: LiquidityPoolWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IssuerUpdateOneRequiredWithoutCreditDefsNestedInput = {
    create?: XOR<IssuerCreateWithoutCreditDefsInput, IssuerUncheckedCreateWithoutCreditDefsInput>
    connectOrCreate?: IssuerCreateOrConnectWithoutCreditDefsInput
    upsert?: IssuerUpsertWithoutCreditDefsInput
    connect?: IssuerWhereUniqueInput
    update?: XOR<XOR<IssuerUpdateToOneWithWhereWithoutCreditDefsInput, IssuerUpdateWithoutCreditDefsInput>, IssuerUncheckedUpdateWithoutCreditDefsInput>
  }

  export type BalanceUpdateManyWithoutCreditDefNestedInput = {
    create?: XOR<BalanceCreateWithoutCreditDefInput, BalanceUncheckedCreateWithoutCreditDefInput> | BalanceCreateWithoutCreditDefInput[] | BalanceUncheckedCreateWithoutCreditDefInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutCreditDefInput | BalanceCreateOrConnectWithoutCreditDefInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutCreditDefInput | BalanceUpsertWithWhereUniqueWithoutCreditDefInput[]
    createMany?: BalanceCreateManyCreditDefInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutCreditDefInput | BalanceUpdateWithWhereUniqueWithoutCreditDefInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutCreditDefInput | BalanceUpdateManyWithWhereWithoutCreditDefInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type PolicyUpdateManyWithoutCreditDefNestedInput = {
    create?: XOR<PolicyCreateWithoutCreditDefInput, PolicyUncheckedCreateWithoutCreditDefInput> | PolicyCreateWithoutCreditDefInput[] | PolicyUncheckedCreateWithoutCreditDefInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutCreditDefInput | PolicyCreateOrConnectWithoutCreditDefInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutCreditDefInput | PolicyUpsertWithWhereUniqueWithoutCreditDefInput[]
    createMany?: PolicyCreateManyCreditDefInputEnvelope
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutCreditDefInput | PolicyUpdateWithWhereUniqueWithoutCreditDefInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutCreditDefInput | PolicyUpdateManyWithWhereWithoutCreditDefInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type LiquidityPoolUpdateOneWithoutCreditDefNestedInput = {
    create?: XOR<LiquidityPoolCreateWithoutCreditDefInput, LiquidityPoolUncheckedCreateWithoutCreditDefInput>
    connectOrCreate?: LiquidityPoolCreateOrConnectWithoutCreditDefInput
    upsert?: LiquidityPoolUpsertWithoutCreditDefInput
    disconnect?: LiquidityPoolWhereInput | boolean
    delete?: LiquidityPoolWhereInput | boolean
    connect?: LiquidityPoolWhereUniqueInput
    update?: XOR<XOR<LiquidityPoolUpdateToOneWithWhereWithoutCreditDefInput, LiquidityPoolUpdateWithoutCreditDefInput>, LiquidityPoolUncheckedUpdateWithoutCreditDefInput>
  }

  export type BalanceUncheckedUpdateManyWithoutCreditDefNestedInput = {
    create?: XOR<BalanceCreateWithoutCreditDefInput, BalanceUncheckedCreateWithoutCreditDefInput> | BalanceCreateWithoutCreditDefInput[] | BalanceUncheckedCreateWithoutCreditDefInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutCreditDefInput | BalanceCreateOrConnectWithoutCreditDefInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutCreditDefInput | BalanceUpsertWithWhereUniqueWithoutCreditDefInput[]
    createMany?: BalanceCreateManyCreditDefInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutCreditDefInput | BalanceUpdateWithWhereUniqueWithoutCreditDefInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutCreditDefInput | BalanceUpdateManyWithWhereWithoutCreditDefInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type PolicyUncheckedUpdateManyWithoutCreditDefNestedInput = {
    create?: XOR<PolicyCreateWithoutCreditDefInput, PolicyUncheckedCreateWithoutCreditDefInput> | PolicyCreateWithoutCreditDefInput[] | PolicyUncheckedCreateWithoutCreditDefInput[]
    connectOrCreate?: PolicyCreateOrConnectWithoutCreditDefInput | PolicyCreateOrConnectWithoutCreditDefInput[]
    upsert?: PolicyUpsertWithWhereUniqueWithoutCreditDefInput | PolicyUpsertWithWhereUniqueWithoutCreditDefInput[]
    createMany?: PolicyCreateManyCreditDefInputEnvelope
    set?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    disconnect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    delete?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    connect?: PolicyWhereUniqueInput | PolicyWhereUniqueInput[]
    update?: PolicyUpdateWithWhereUniqueWithoutCreditDefInput | PolicyUpdateWithWhereUniqueWithoutCreditDefInput[]
    updateMany?: PolicyUpdateManyWithWhereWithoutCreditDefInput | PolicyUpdateManyWithWhereWithoutCreditDefInput[]
    deleteMany?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
  }

  export type LiquidityPoolUncheckedUpdateOneWithoutCreditDefNestedInput = {
    create?: XOR<LiquidityPoolCreateWithoutCreditDefInput, LiquidityPoolUncheckedCreateWithoutCreditDefInput>
    connectOrCreate?: LiquidityPoolCreateOrConnectWithoutCreditDefInput
    upsert?: LiquidityPoolUpsertWithoutCreditDefInput
    disconnect?: LiquidityPoolWhereInput | boolean
    delete?: LiquidityPoolWhereInput | boolean
    connect?: LiquidityPoolWhereUniqueInput
    update?: XOR<XOR<LiquidityPoolUpdateToOneWithWhereWithoutCreditDefInput, LiquidityPoolUpdateWithoutCreditDefInput>, LiquidityPoolUncheckedUpdateWithoutCreditDefInput>
  }

  export type VCreditDefinitionCreateNestedOneWithoutLiquidityPoolInput = {
    create?: XOR<VCreditDefinitionCreateWithoutLiquidityPoolInput, VCreditDefinitionUncheckedCreateWithoutLiquidityPoolInput>
    connectOrCreate?: VCreditDefinitionCreateOrConnectWithoutLiquidityPoolInput
    connect?: VCreditDefinitionWhereUniqueInput
  }

  export type VCreditDefinitionUpdateOneRequiredWithoutLiquidityPoolNestedInput = {
    create?: XOR<VCreditDefinitionCreateWithoutLiquidityPoolInput, VCreditDefinitionUncheckedCreateWithoutLiquidityPoolInput>
    connectOrCreate?: VCreditDefinitionCreateOrConnectWithoutLiquidityPoolInput
    upsert?: VCreditDefinitionUpsertWithoutLiquidityPoolInput
    connect?: VCreditDefinitionWhereUniqueInput
    update?: XOR<XOR<VCreditDefinitionUpdateToOneWithWhereWithoutLiquidityPoolInput, VCreditDefinitionUpdateWithoutLiquidityPoolInput>, VCreditDefinitionUncheckedUpdateWithoutLiquidityPoolInput>
  }

  export type UserCreateNestedOneWithoutWalletsInput = {
    create?: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletsInput
    connect?: UserWhereUniqueInput
  }

  export type BalanceCreateNestedManyWithoutWalletInput = {
    create?: XOR<BalanceCreateWithoutWalletInput, BalanceUncheckedCreateWithoutWalletInput> | BalanceCreateWithoutWalletInput[] | BalanceUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutWalletInput | BalanceCreateOrConnectWithoutWalletInput[]
    createMany?: BalanceCreateManyWalletInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutSenderWalletInput = {
    create?: XOR<TransactionCreateWithoutSenderWalletInput, TransactionUncheckedCreateWithoutSenderWalletInput> | TransactionCreateWithoutSenderWalletInput[] | TransactionUncheckedCreateWithoutSenderWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSenderWalletInput | TransactionCreateOrConnectWithoutSenderWalletInput[]
    createMany?: TransactionCreateManySenderWalletInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BalanceUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<BalanceCreateWithoutWalletInput, BalanceUncheckedCreateWithoutWalletInput> | BalanceCreateWithoutWalletInput[] | BalanceUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutWalletInput | BalanceCreateOrConnectWithoutWalletInput[]
    createMany?: BalanceCreateManyWalletInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutSenderWalletInput = {
    create?: XOR<TransactionCreateWithoutSenderWalletInput, TransactionUncheckedCreateWithoutSenderWalletInput> | TransactionCreateWithoutSenderWalletInput[] | TransactionUncheckedCreateWithoutSenderWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSenderWalletInput | TransactionCreateOrConnectWithoutSenderWalletInput[]
    createMany?: TransactionCreateManySenderWalletInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutWalletsNestedInput = {
    create?: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletsInput
    upsert?: UserUpsertWithoutWalletsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletsInput, UserUpdateWithoutWalletsInput>, UserUncheckedUpdateWithoutWalletsInput>
  }

  export type BalanceUpdateManyWithoutWalletNestedInput = {
    create?: XOR<BalanceCreateWithoutWalletInput, BalanceUncheckedCreateWithoutWalletInput> | BalanceCreateWithoutWalletInput[] | BalanceUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutWalletInput | BalanceCreateOrConnectWithoutWalletInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutWalletInput | BalanceUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: BalanceCreateManyWalletInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutWalletInput | BalanceUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutWalletInput | BalanceUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutSenderWalletNestedInput = {
    create?: XOR<TransactionCreateWithoutSenderWalletInput, TransactionUncheckedCreateWithoutSenderWalletInput> | TransactionCreateWithoutSenderWalletInput[] | TransactionUncheckedCreateWithoutSenderWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSenderWalletInput | TransactionCreateOrConnectWithoutSenderWalletInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSenderWalletInput | TransactionUpsertWithWhereUniqueWithoutSenderWalletInput[]
    createMany?: TransactionCreateManySenderWalletInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSenderWalletInput | TransactionUpdateWithWhereUniqueWithoutSenderWalletInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSenderWalletInput | TransactionUpdateManyWithWhereWithoutSenderWalletInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BalanceUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<BalanceCreateWithoutWalletInput, BalanceUncheckedCreateWithoutWalletInput> | BalanceCreateWithoutWalletInput[] | BalanceUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutWalletInput | BalanceCreateOrConnectWithoutWalletInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutWalletInput | BalanceUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: BalanceCreateManyWalletInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutWalletInput | BalanceUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutWalletInput | BalanceUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutSenderWalletNestedInput = {
    create?: XOR<TransactionCreateWithoutSenderWalletInput, TransactionUncheckedCreateWithoutSenderWalletInput> | TransactionCreateWithoutSenderWalletInput[] | TransactionUncheckedCreateWithoutSenderWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSenderWalletInput | TransactionCreateOrConnectWithoutSenderWalletInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSenderWalletInput | TransactionUpsertWithWhereUniqueWithoutSenderWalletInput[]
    createMany?: TransactionCreateManySenderWalletInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSenderWalletInput | TransactionUpdateWithWhereUniqueWithoutSenderWalletInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSenderWalletInput | TransactionUpdateManyWithWhereWithoutSenderWalletInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type WalletCreateNestedOneWithoutBalancesInput = {
    create?: XOR<WalletCreateWithoutBalancesInput, WalletUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: WalletCreateOrConnectWithoutBalancesInput
    connect?: WalletWhereUniqueInput
  }

  export type VCreditDefinitionCreateNestedOneWithoutBalancesInput = {
    create?: XOR<VCreditDefinitionCreateWithoutBalancesInput, VCreditDefinitionUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: VCreditDefinitionCreateOrConnectWithoutBalancesInput
    connect?: VCreditDefinitionWhereUniqueInput
  }

  export type WalletUpdateOneRequiredWithoutBalancesNestedInput = {
    create?: XOR<WalletCreateWithoutBalancesInput, WalletUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: WalletCreateOrConnectWithoutBalancesInput
    upsert?: WalletUpsertWithoutBalancesInput
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutBalancesInput, WalletUpdateWithoutBalancesInput>, WalletUncheckedUpdateWithoutBalancesInput>
  }

  export type VCreditDefinitionUpdateOneRequiredWithoutBalancesNestedInput = {
    create?: XOR<VCreditDefinitionCreateWithoutBalancesInput, VCreditDefinitionUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: VCreditDefinitionCreateOrConnectWithoutBalancesInput
    upsert?: VCreditDefinitionUpsertWithoutBalancesInput
    connect?: VCreditDefinitionWhereUniqueInput
    update?: XOR<XOR<VCreditDefinitionUpdateToOneWithWhereWithoutBalancesInput, VCreditDefinitionUpdateWithoutBalancesInput>, VCreditDefinitionUncheckedUpdateWithoutBalancesInput>
  }

  export type WalletCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsInput
    connect?: WalletWhereUniqueInput
  }

  export type PolicyEvaluationLogCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<PolicyEvaluationLogCreateWithoutTransactionsInput, PolicyEvaluationLogUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PolicyEvaluationLogCreateOrConnectWithoutTransactionsInput
    connect?: PolicyEvaluationLogWhereUniqueInput
  }

  export type LedgerEntryCreateNestedManyWithoutTransactionInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type WalletUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsInput
    upsert?: WalletUpsertWithoutTransactionsInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutTransactionsInput, WalletUpdateWithoutTransactionsInput>, WalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type PolicyEvaluationLogUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<PolicyEvaluationLogCreateWithoutTransactionsInput, PolicyEvaluationLogUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PolicyEvaluationLogCreateOrConnectWithoutTransactionsInput
    upsert?: PolicyEvaluationLogUpsertWithoutTransactionsInput
    disconnect?: PolicyEvaluationLogWhereInput | boolean
    delete?: PolicyEvaluationLogWhereInput | boolean
    connect?: PolicyEvaluationLogWhereUniqueInput
    update?: XOR<XOR<PolicyEvaluationLogUpdateToOneWithWhereWithoutTransactionsInput, PolicyEvaluationLogUpdateWithoutTransactionsInput>, PolicyEvaluationLogUncheckedUpdateWithoutTransactionsInput>
  }

  export type LedgerEntryUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput | LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput | LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutTransactionInput | LedgerEntryUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput> | LedgerEntryCreateWithoutTransactionInput[] | LedgerEntryUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutTransactionInput | LedgerEntryCreateOrConnectWithoutTransactionInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput | LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: LedgerEntryCreateManyTransactionInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput | LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutTransactionInput | LedgerEntryUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type TransactionCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<TransactionCreateWithoutLedgerEntriesInput, TransactionUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutLedgerEntriesInput
    connect?: TransactionWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutLedgerEntriesNestedInput = {
    create?: XOR<TransactionCreateWithoutLedgerEntriesInput, TransactionUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutLedgerEntriesInput
    upsert?: TransactionUpsertWithoutLedgerEntriesInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutLedgerEntriesInput, TransactionUpdateWithoutLedgerEntriesInput>, TransactionUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type IssuerCreateNestedOneWithoutPoliciesInput = {
    create?: XOR<IssuerCreateWithoutPoliciesInput, IssuerUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: IssuerCreateOrConnectWithoutPoliciesInput
    connect?: IssuerWhereUniqueInput
  }

  export type VCreditDefinitionCreateNestedOneWithoutPoliciesInput = {
    create?: XOR<VCreditDefinitionCreateWithoutPoliciesInput, VCreditDefinitionUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: VCreditDefinitionCreateOrConnectWithoutPoliciesInput
    connect?: VCreditDefinitionWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IssuerUpdateOneWithoutPoliciesNestedInput = {
    create?: XOR<IssuerCreateWithoutPoliciesInput, IssuerUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: IssuerCreateOrConnectWithoutPoliciesInput
    upsert?: IssuerUpsertWithoutPoliciesInput
    disconnect?: IssuerWhereInput | boolean
    delete?: IssuerWhereInput | boolean
    connect?: IssuerWhereUniqueInput
    update?: XOR<XOR<IssuerUpdateToOneWithWhereWithoutPoliciesInput, IssuerUpdateWithoutPoliciesInput>, IssuerUncheckedUpdateWithoutPoliciesInput>
  }

  export type VCreditDefinitionUpdateOneWithoutPoliciesNestedInput = {
    create?: XOR<VCreditDefinitionCreateWithoutPoliciesInput, VCreditDefinitionUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: VCreditDefinitionCreateOrConnectWithoutPoliciesInput
    upsert?: VCreditDefinitionUpsertWithoutPoliciesInput
    disconnect?: VCreditDefinitionWhereInput | boolean
    delete?: VCreditDefinitionWhereInput | boolean
    connect?: VCreditDefinitionWhereUniqueInput
    update?: XOR<XOR<VCreditDefinitionUpdateToOneWithWhereWithoutPoliciesInput, VCreditDefinitionUpdateWithoutPoliciesInput>, VCreditDefinitionUncheckedUpdateWithoutPoliciesInput>
  }

  export type TransactionCreateNestedManyWithoutPolicyLogInput = {
    create?: XOR<TransactionCreateWithoutPolicyLogInput, TransactionUncheckedCreateWithoutPolicyLogInput> | TransactionCreateWithoutPolicyLogInput[] | TransactionUncheckedCreateWithoutPolicyLogInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPolicyLogInput | TransactionCreateOrConnectWithoutPolicyLogInput[]
    createMany?: TransactionCreateManyPolicyLogInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutPolicyLogInput = {
    create?: XOR<TransactionCreateWithoutPolicyLogInput, TransactionUncheckedCreateWithoutPolicyLogInput> | TransactionCreateWithoutPolicyLogInput[] | TransactionUncheckedCreateWithoutPolicyLogInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPolicyLogInput | TransactionCreateOrConnectWithoutPolicyLogInput[]
    createMany?: TransactionCreateManyPolicyLogInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutPolicyLogNestedInput = {
    create?: XOR<TransactionCreateWithoutPolicyLogInput, TransactionUncheckedCreateWithoutPolicyLogInput> | TransactionCreateWithoutPolicyLogInput[] | TransactionUncheckedCreateWithoutPolicyLogInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPolicyLogInput | TransactionCreateOrConnectWithoutPolicyLogInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPolicyLogInput | TransactionUpsertWithWhereUniqueWithoutPolicyLogInput[]
    createMany?: TransactionCreateManyPolicyLogInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPolicyLogInput | TransactionUpdateWithWhereUniqueWithoutPolicyLogInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPolicyLogInput | TransactionUpdateManyWithWhereWithoutPolicyLogInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutPolicyLogNestedInput = {
    create?: XOR<TransactionCreateWithoutPolicyLogInput, TransactionUncheckedCreateWithoutPolicyLogInput> | TransactionCreateWithoutPolicyLogInput[] | TransactionUncheckedCreateWithoutPolicyLogInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPolicyLogInput | TransactionCreateOrConnectWithoutPolicyLogInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPolicyLogInput | TransactionUpsertWithWhereUniqueWithoutPolicyLogInput[]
    createMany?: TransactionCreateManyPolicyLogInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPolicyLogInput | TransactionUpdateWithWhereUniqueWithoutPolicyLogInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPolicyLogInput | TransactionUpdateManyWithWhereWithoutPolicyLogInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAttestationsInput = {
    create?: XOR<UserCreateWithoutAttestationsInput, UserUncheckedCreateWithoutAttestationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttestationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAttestationsNestedInput = {
    create?: XOR<UserCreateWithoutAttestationsInput, UserUncheckedCreateWithoutAttestationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttestationsInput
    upsert?: UserUpsertWithoutAttestationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttestationsInput, UserUpdateWithoutAttestationsInput>, UserUncheckedUpdateWithoutAttestationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IssuerCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    apiKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creditDefs?: VCreditDefinitionCreateNestedManyWithoutIssuerInput
    policies?: PolicyCreateNestedManyWithoutIssuerInput
  }

  export type IssuerUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    apiKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creditDefs?: VCreditDefinitionUncheckedCreateNestedManyWithoutIssuerInput
    policies?: PolicyUncheckedCreateNestedManyWithoutIssuerInput
  }

  export type IssuerCreateOrConnectWithoutUsersInput = {
    where: IssuerWhereUniqueInput
    create: XOR<IssuerCreateWithoutUsersInput, IssuerUncheckedCreateWithoutUsersInput>
  }

  export type MerchantCreateWithoutUsersInput = {
    id?: string
    name: string
    category: string
    discountRate?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    terminals?: MerchantTerminalCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    category: string
    discountRate?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    terminals?: MerchantTerminalUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutUsersInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutUsersInput, MerchantUncheckedCreateWithoutUsersInput>
  }

  export type WalletCreateWithoutUserInput = {
    id?: string
    type?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    balances?: BalanceCreateNestedManyWithoutWalletInput
    transactions?: TransactionCreateNestedManyWithoutSenderWalletInput
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: string
    type?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutWalletInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSenderWalletInput
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type WalletCreateManyUserInputEnvelope = {
    data: WalletCreateManyUserInput | WalletCreateManyUserInput[]
  }

  export type ComplianceAttestationCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    status: string
    validUntil?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceAttestationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    status: string
    validUntil?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceAttestationCreateOrConnectWithoutUserInput = {
    where: ComplianceAttestationWhereUniqueInput
    create: XOR<ComplianceAttestationCreateWithoutUserInput, ComplianceAttestationUncheckedCreateWithoutUserInput>
  }

  export type ComplianceAttestationCreateManyUserInputEnvelope = {
    data: ComplianceAttestationCreateManyUserInput | ComplianceAttestationCreateManyUserInput[]
  }

  export type IssuerUpsertWithoutUsersInput = {
    update: XOR<IssuerUpdateWithoutUsersInput, IssuerUncheckedUpdateWithoutUsersInput>
    create: XOR<IssuerCreateWithoutUsersInput, IssuerUncheckedCreateWithoutUsersInput>
    where?: IssuerWhereInput
  }

  export type IssuerUpdateToOneWithWhereWithoutUsersInput = {
    where?: IssuerWhereInput
    data: XOR<IssuerUpdateWithoutUsersInput, IssuerUncheckedUpdateWithoutUsersInput>
  }

  export type IssuerUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditDefs?: VCreditDefinitionUpdateManyWithoutIssuerNestedInput
    policies?: PolicyUpdateManyWithoutIssuerNestedInput
  }

  export type IssuerUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditDefs?: VCreditDefinitionUncheckedUpdateManyWithoutIssuerNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutIssuerNestedInput
  }

  export type MerchantUpsertWithoutUsersInput = {
    update: XOR<MerchantUpdateWithoutUsersInput, MerchantUncheckedUpdateWithoutUsersInput>
    create: XOR<MerchantCreateWithoutUsersInput, MerchantUncheckedCreateWithoutUsersInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutUsersInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutUsersInput, MerchantUncheckedUpdateWithoutUsersInput>
  }

  export type MerchantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    terminals?: MerchantTerminalUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    terminals?: MerchantTerminalUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type WalletUpsertWithWhereUniqueWithoutUserInput = {
    where: WalletWhereUniqueInput
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type WalletUpdateWithWhereUniqueWithoutUserInput = {
    where: WalletWhereUniqueInput
    data: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateManyWithWhereWithoutUserInput = {
    where: WalletScalarWhereInput
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyWithoutUserInput>
  }

  export type WalletScalarWhereInput = {
    AND?: WalletScalarWhereInput | WalletScalarWhereInput[]
    OR?: WalletScalarWhereInput[]
    NOT?: WalletScalarWhereInput | WalletScalarWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringNullableFilter<"Wallet"> | string | null
    type?: StringFilter<"Wallet"> | string
    status?: StringFilter<"Wallet"> | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
  }

  export type ComplianceAttestationUpsertWithWhereUniqueWithoutUserInput = {
    where: ComplianceAttestationWhereUniqueInput
    update: XOR<ComplianceAttestationUpdateWithoutUserInput, ComplianceAttestationUncheckedUpdateWithoutUserInput>
    create: XOR<ComplianceAttestationCreateWithoutUserInput, ComplianceAttestationUncheckedCreateWithoutUserInput>
  }

  export type ComplianceAttestationUpdateWithWhereUniqueWithoutUserInput = {
    where: ComplianceAttestationWhereUniqueInput
    data: XOR<ComplianceAttestationUpdateWithoutUserInput, ComplianceAttestationUncheckedUpdateWithoutUserInput>
  }

  export type ComplianceAttestationUpdateManyWithWhereWithoutUserInput = {
    where: ComplianceAttestationScalarWhereInput
    data: XOR<ComplianceAttestationUpdateManyMutationInput, ComplianceAttestationUncheckedUpdateManyWithoutUserInput>
  }

  export type ComplianceAttestationScalarWhereInput = {
    AND?: ComplianceAttestationScalarWhereInput | ComplianceAttestationScalarWhereInput[]
    OR?: ComplianceAttestationScalarWhereInput[]
    NOT?: ComplianceAttestationScalarWhereInput | ComplianceAttestationScalarWhereInput[]
    id?: StringFilter<"ComplianceAttestation"> | string
    userId?: StringFilter<"ComplianceAttestation"> | string
    type?: StringFilter<"ComplianceAttestation"> | string
    provider?: StringFilter<"ComplianceAttestation"> | string
    status?: StringFilter<"ComplianceAttestation"> | string
    validUntil?: DateTimeNullableFilter<"ComplianceAttestation"> | Date | string | null
    metadata?: StringNullableFilter<"ComplianceAttestation"> | string | null
    createdAt?: DateTimeFilter<"ComplianceAttestation"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceAttestation"> | Date | string
  }

  export type UserCreateWithoutIssuerInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    merchant?: MerchantCreateNestedOneWithoutUsersInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    attestations?: ComplianceAttestationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIssuerInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    merchantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    attestations?: ComplianceAttestationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIssuerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIssuerInput, UserUncheckedCreateWithoutIssuerInput>
  }

  export type UserCreateManyIssuerInputEnvelope = {
    data: UserCreateManyIssuerInput | UserCreateManyIssuerInput[]
  }

  export type VCreditDefinitionCreateWithoutIssuerInput = {
    id?: string
    name: string
    symbol: string
    decimals?: number
    type: string
    exchangeRateBaseUSD?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    balances?: BalanceCreateNestedManyWithoutCreditDefInput
    policies?: PolicyCreateNestedManyWithoutCreditDefInput
    liquidityPool?: LiquidityPoolCreateNestedOneWithoutCreditDefInput
  }

  export type VCreditDefinitionUncheckedCreateWithoutIssuerInput = {
    id?: string
    name: string
    symbol: string
    decimals?: number
    type: string
    exchangeRateBaseUSD?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutCreditDefInput
    policies?: PolicyUncheckedCreateNestedManyWithoutCreditDefInput
    liquidityPool?: LiquidityPoolUncheckedCreateNestedOneWithoutCreditDefInput
  }

  export type VCreditDefinitionCreateOrConnectWithoutIssuerInput = {
    where: VCreditDefinitionWhereUniqueInput
    create: XOR<VCreditDefinitionCreateWithoutIssuerInput, VCreditDefinitionUncheckedCreateWithoutIssuerInput>
  }

  export type VCreditDefinitionCreateManyIssuerInputEnvelope = {
    data: VCreditDefinitionCreateManyIssuerInput | VCreditDefinitionCreateManyIssuerInput[]
  }

  export type PolicyCreateWithoutIssuerInput = {
    id?: string
    name: string
    description?: string | null
    ruleType: string
    parameters: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creditDef?: VCreditDefinitionCreateNestedOneWithoutPoliciesInput
  }

  export type PolicyUncheckedCreateWithoutIssuerInput = {
    id?: string
    creditDefId?: string | null
    name: string
    description?: string | null
    ruleType: string
    parameters: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyCreateOrConnectWithoutIssuerInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutIssuerInput, PolicyUncheckedCreateWithoutIssuerInput>
  }

  export type PolicyCreateManyIssuerInputEnvelope = {
    data: PolicyCreateManyIssuerInput | PolicyCreateManyIssuerInput[]
  }

  export type UserUpsertWithWhereUniqueWithoutIssuerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutIssuerInput, UserUncheckedUpdateWithoutIssuerInput>
    create: XOR<UserCreateWithoutIssuerInput, UserUncheckedCreateWithoutIssuerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutIssuerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutIssuerInput, UserUncheckedUpdateWithoutIssuerInput>
  }

  export type UserUpdateManyWithWhereWithoutIssuerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutIssuerInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    issuerId?: StringNullableFilter<"User"> | string | null
    merchantId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type VCreditDefinitionUpsertWithWhereUniqueWithoutIssuerInput = {
    where: VCreditDefinitionWhereUniqueInput
    update: XOR<VCreditDefinitionUpdateWithoutIssuerInput, VCreditDefinitionUncheckedUpdateWithoutIssuerInput>
    create: XOR<VCreditDefinitionCreateWithoutIssuerInput, VCreditDefinitionUncheckedCreateWithoutIssuerInput>
  }

  export type VCreditDefinitionUpdateWithWhereUniqueWithoutIssuerInput = {
    where: VCreditDefinitionWhereUniqueInput
    data: XOR<VCreditDefinitionUpdateWithoutIssuerInput, VCreditDefinitionUncheckedUpdateWithoutIssuerInput>
  }

  export type VCreditDefinitionUpdateManyWithWhereWithoutIssuerInput = {
    where: VCreditDefinitionScalarWhereInput
    data: XOR<VCreditDefinitionUpdateManyMutationInput, VCreditDefinitionUncheckedUpdateManyWithoutIssuerInput>
  }

  export type VCreditDefinitionScalarWhereInput = {
    AND?: VCreditDefinitionScalarWhereInput | VCreditDefinitionScalarWhereInput[]
    OR?: VCreditDefinitionScalarWhereInput[]
    NOT?: VCreditDefinitionScalarWhereInput | VCreditDefinitionScalarWhereInput[]
    id?: StringFilter<"VCreditDefinition"> | string
    issuerId?: StringFilter<"VCreditDefinition"> | string
    name?: StringFilter<"VCreditDefinition"> | string
    symbol?: StringFilter<"VCreditDefinition"> | string
    decimals?: IntFilter<"VCreditDefinition"> | number
    type?: StringFilter<"VCreditDefinition"> | string
    exchangeRateBaseUSD?: DecimalFilter<"VCreditDefinition"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"VCreditDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"VCreditDefinition"> | Date | string
  }

  export type PolicyUpsertWithWhereUniqueWithoutIssuerInput = {
    where: PolicyWhereUniqueInput
    update: XOR<PolicyUpdateWithoutIssuerInput, PolicyUncheckedUpdateWithoutIssuerInput>
    create: XOR<PolicyCreateWithoutIssuerInput, PolicyUncheckedCreateWithoutIssuerInput>
  }

  export type PolicyUpdateWithWhereUniqueWithoutIssuerInput = {
    where: PolicyWhereUniqueInput
    data: XOR<PolicyUpdateWithoutIssuerInput, PolicyUncheckedUpdateWithoutIssuerInput>
  }

  export type PolicyUpdateManyWithWhereWithoutIssuerInput = {
    where: PolicyScalarWhereInput
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyWithoutIssuerInput>
  }

  export type PolicyScalarWhereInput = {
    AND?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
    OR?: PolicyScalarWhereInput[]
    NOT?: PolicyScalarWhereInput | PolicyScalarWhereInput[]
    id?: StringFilter<"Policy"> | string
    issuerId?: StringNullableFilter<"Policy"> | string | null
    creditDefId?: StringNullableFilter<"Policy"> | string | null
    name?: StringFilter<"Policy"> | string
    description?: StringNullableFilter<"Policy"> | string | null
    ruleType?: StringFilter<"Policy"> | string
    parameters?: StringFilter<"Policy"> | string
    isActive?: BoolFilter<"Policy"> | boolean
    priority?: IntFilter<"Policy"> | number
    createdAt?: DateTimeFilter<"Policy"> | Date | string
    updatedAt?: DateTimeFilter<"Policy"> | Date | string
  }

  export type UserCreateWithoutMerchantInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer?: IssuerCreateNestedOneWithoutUsersInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    attestations?: ComplianceAttestationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMerchantInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    issuerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    attestations?: ComplianceAttestationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMerchantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMerchantInput, UserUncheckedCreateWithoutMerchantInput>
  }

  export type UserCreateManyMerchantInputEnvelope = {
    data: UserCreateManyMerchantInput | UserCreateManyMerchantInput[]
  }

  export type MerchantTerminalCreateWithoutMerchantInput = {
    id?: string
    location: string
    secretKey: string
    createdAt?: Date | string
  }

  export type MerchantTerminalUncheckedCreateWithoutMerchantInput = {
    id?: string
    location: string
    secretKey: string
    createdAt?: Date | string
  }

  export type MerchantTerminalCreateOrConnectWithoutMerchantInput = {
    where: MerchantTerminalWhereUniqueInput
    create: XOR<MerchantTerminalCreateWithoutMerchantInput, MerchantTerminalUncheckedCreateWithoutMerchantInput>
  }

  export type MerchantTerminalCreateManyMerchantInputEnvelope = {
    data: MerchantTerminalCreateManyMerchantInput | MerchantTerminalCreateManyMerchantInput[]
  }

  export type UserUpsertWithWhereUniqueWithoutMerchantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutMerchantInput, UserUncheckedUpdateWithoutMerchantInput>
    create: XOR<UserCreateWithoutMerchantInput, UserUncheckedCreateWithoutMerchantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutMerchantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutMerchantInput, UserUncheckedUpdateWithoutMerchantInput>
  }

  export type UserUpdateManyWithWhereWithoutMerchantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutMerchantInput>
  }

  export type MerchantTerminalUpsertWithWhereUniqueWithoutMerchantInput = {
    where: MerchantTerminalWhereUniqueInput
    update: XOR<MerchantTerminalUpdateWithoutMerchantInput, MerchantTerminalUncheckedUpdateWithoutMerchantInput>
    create: XOR<MerchantTerminalCreateWithoutMerchantInput, MerchantTerminalUncheckedCreateWithoutMerchantInput>
  }

  export type MerchantTerminalUpdateWithWhereUniqueWithoutMerchantInput = {
    where: MerchantTerminalWhereUniqueInput
    data: XOR<MerchantTerminalUpdateWithoutMerchantInput, MerchantTerminalUncheckedUpdateWithoutMerchantInput>
  }

  export type MerchantTerminalUpdateManyWithWhereWithoutMerchantInput = {
    where: MerchantTerminalScalarWhereInput
    data: XOR<MerchantTerminalUpdateManyMutationInput, MerchantTerminalUncheckedUpdateManyWithoutMerchantInput>
  }

  export type MerchantTerminalScalarWhereInput = {
    AND?: MerchantTerminalScalarWhereInput | MerchantTerminalScalarWhereInput[]
    OR?: MerchantTerminalScalarWhereInput[]
    NOT?: MerchantTerminalScalarWhereInput | MerchantTerminalScalarWhereInput[]
    id?: StringFilter<"MerchantTerminal"> | string
    merchantId?: StringFilter<"MerchantTerminal"> | string
    location?: StringFilter<"MerchantTerminal"> | string
    secretKey?: StringFilter<"MerchantTerminal"> | string
    createdAt?: DateTimeFilter<"MerchantTerminal"> | Date | string
  }

  export type MerchantCreateWithoutTerminalsInput = {
    id?: string
    name: string
    category: string
    discountRate?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutMerchantInput
  }

  export type MerchantUncheckedCreateWithoutTerminalsInput = {
    id?: string
    name: string
    category: string
    discountRate?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutMerchantInput
  }

  export type MerchantCreateOrConnectWithoutTerminalsInput = {
    where: MerchantWhereUniqueInput
    create: XOR<MerchantCreateWithoutTerminalsInput, MerchantUncheckedCreateWithoutTerminalsInput>
  }

  export type MerchantUpsertWithoutTerminalsInput = {
    update: XOR<MerchantUpdateWithoutTerminalsInput, MerchantUncheckedUpdateWithoutTerminalsInput>
    create: XOR<MerchantCreateWithoutTerminalsInput, MerchantUncheckedCreateWithoutTerminalsInput>
    where?: MerchantWhereInput
  }

  export type MerchantUpdateToOneWithWhereWithoutTerminalsInput = {
    where?: MerchantWhereInput
    data: XOR<MerchantUpdateWithoutTerminalsInput, MerchantUncheckedUpdateWithoutTerminalsInput>
  }

  export type MerchantUpdateWithoutTerminalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutMerchantNestedInput
  }

  export type MerchantUncheckedUpdateWithoutTerminalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutMerchantNestedInput
  }

  export type IssuerCreateWithoutCreditDefsInput = {
    id?: string
    name: string
    slug: string
    apiKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutIssuerInput
    policies?: PolicyCreateNestedManyWithoutIssuerInput
  }

  export type IssuerUncheckedCreateWithoutCreditDefsInput = {
    id?: string
    name: string
    slug: string
    apiKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutIssuerInput
    policies?: PolicyUncheckedCreateNestedManyWithoutIssuerInput
  }

  export type IssuerCreateOrConnectWithoutCreditDefsInput = {
    where: IssuerWhereUniqueInput
    create: XOR<IssuerCreateWithoutCreditDefsInput, IssuerUncheckedCreateWithoutCreditDefsInput>
  }

  export type BalanceCreateWithoutCreditDefInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    wallet: WalletCreateNestedOneWithoutBalancesInput
  }

  export type BalanceUncheckedCreateWithoutCreditDefInput = {
    id?: string
    walletId: string
    amount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type BalanceCreateOrConnectWithoutCreditDefInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutCreditDefInput, BalanceUncheckedCreateWithoutCreditDefInput>
  }

  export type BalanceCreateManyCreditDefInputEnvelope = {
    data: BalanceCreateManyCreditDefInput | BalanceCreateManyCreditDefInput[]
  }

  export type PolicyCreateWithoutCreditDefInput = {
    id?: string
    name: string
    description?: string | null
    ruleType: string
    parameters: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer?: IssuerCreateNestedOneWithoutPoliciesInput
  }

  export type PolicyUncheckedCreateWithoutCreditDefInput = {
    id?: string
    issuerId?: string | null
    name: string
    description?: string | null
    ruleType: string
    parameters: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyCreateOrConnectWithoutCreditDefInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutCreditDefInput, PolicyUncheckedCreateWithoutCreditDefInput>
  }

  export type PolicyCreateManyCreditDefInputEnvelope = {
    data: PolicyCreateManyCreditDefInput | PolicyCreateManyCreditDefInput[]
  }

  export type LiquidityPoolCreateWithoutCreditDefInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    currency?: string
    updatedAt?: Date | string
  }

  export type LiquidityPoolUncheckedCreateWithoutCreditDefInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    currency?: string
    updatedAt?: Date | string
  }

  export type LiquidityPoolCreateOrConnectWithoutCreditDefInput = {
    where: LiquidityPoolWhereUniqueInput
    create: XOR<LiquidityPoolCreateWithoutCreditDefInput, LiquidityPoolUncheckedCreateWithoutCreditDefInput>
  }

  export type IssuerUpsertWithoutCreditDefsInput = {
    update: XOR<IssuerUpdateWithoutCreditDefsInput, IssuerUncheckedUpdateWithoutCreditDefsInput>
    create: XOR<IssuerCreateWithoutCreditDefsInput, IssuerUncheckedCreateWithoutCreditDefsInput>
    where?: IssuerWhereInput
  }

  export type IssuerUpdateToOneWithWhereWithoutCreditDefsInput = {
    where?: IssuerWhereInput
    data: XOR<IssuerUpdateWithoutCreditDefsInput, IssuerUncheckedUpdateWithoutCreditDefsInput>
  }

  export type IssuerUpdateWithoutCreditDefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutIssuerNestedInput
    policies?: PolicyUpdateManyWithoutIssuerNestedInput
  }

  export type IssuerUncheckedUpdateWithoutCreditDefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutIssuerNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutIssuerNestedInput
  }

  export type BalanceUpsertWithWhereUniqueWithoutCreditDefInput = {
    where: BalanceWhereUniqueInput
    update: XOR<BalanceUpdateWithoutCreditDefInput, BalanceUncheckedUpdateWithoutCreditDefInput>
    create: XOR<BalanceCreateWithoutCreditDefInput, BalanceUncheckedCreateWithoutCreditDefInput>
  }

  export type BalanceUpdateWithWhereUniqueWithoutCreditDefInput = {
    where: BalanceWhereUniqueInput
    data: XOR<BalanceUpdateWithoutCreditDefInput, BalanceUncheckedUpdateWithoutCreditDefInput>
  }

  export type BalanceUpdateManyWithWhereWithoutCreditDefInput = {
    where: BalanceScalarWhereInput
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyWithoutCreditDefInput>
  }

  export type BalanceScalarWhereInput = {
    AND?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
    OR?: BalanceScalarWhereInput[]
    NOT?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
    id?: StringFilter<"Balance"> | string
    walletId?: StringFilter<"Balance"> | string
    creditDefId?: StringFilter<"Balance"> | string
    amount?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"Balance"> | Date | string
  }

  export type PolicyUpsertWithWhereUniqueWithoutCreditDefInput = {
    where: PolicyWhereUniqueInput
    update: XOR<PolicyUpdateWithoutCreditDefInput, PolicyUncheckedUpdateWithoutCreditDefInput>
    create: XOR<PolicyCreateWithoutCreditDefInput, PolicyUncheckedCreateWithoutCreditDefInput>
  }

  export type PolicyUpdateWithWhereUniqueWithoutCreditDefInput = {
    where: PolicyWhereUniqueInput
    data: XOR<PolicyUpdateWithoutCreditDefInput, PolicyUncheckedUpdateWithoutCreditDefInput>
  }

  export type PolicyUpdateManyWithWhereWithoutCreditDefInput = {
    where: PolicyScalarWhereInput
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyWithoutCreditDefInput>
  }

  export type LiquidityPoolUpsertWithoutCreditDefInput = {
    update: XOR<LiquidityPoolUpdateWithoutCreditDefInput, LiquidityPoolUncheckedUpdateWithoutCreditDefInput>
    create: XOR<LiquidityPoolCreateWithoutCreditDefInput, LiquidityPoolUncheckedCreateWithoutCreditDefInput>
    where?: LiquidityPoolWhereInput
  }

  export type LiquidityPoolUpdateToOneWithWhereWithoutCreditDefInput = {
    where?: LiquidityPoolWhereInput
    data: XOR<LiquidityPoolUpdateWithoutCreditDefInput, LiquidityPoolUncheckedUpdateWithoutCreditDefInput>
  }

  export type LiquidityPoolUpdateWithoutCreditDefInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiquidityPoolUncheckedUpdateWithoutCreditDefInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VCreditDefinitionCreateWithoutLiquidityPoolInput = {
    id?: string
    name: string
    symbol: string
    decimals?: number
    type: string
    exchangeRateBaseUSD?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: IssuerCreateNestedOneWithoutCreditDefsInput
    balances?: BalanceCreateNestedManyWithoutCreditDefInput
    policies?: PolicyCreateNestedManyWithoutCreditDefInput
  }

  export type VCreditDefinitionUncheckedCreateWithoutLiquidityPoolInput = {
    id?: string
    issuerId: string
    name: string
    symbol: string
    decimals?: number
    type: string
    exchangeRateBaseUSD?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutCreditDefInput
    policies?: PolicyUncheckedCreateNestedManyWithoutCreditDefInput
  }

  export type VCreditDefinitionCreateOrConnectWithoutLiquidityPoolInput = {
    where: VCreditDefinitionWhereUniqueInput
    create: XOR<VCreditDefinitionCreateWithoutLiquidityPoolInput, VCreditDefinitionUncheckedCreateWithoutLiquidityPoolInput>
  }

  export type VCreditDefinitionUpsertWithoutLiquidityPoolInput = {
    update: XOR<VCreditDefinitionUpdateWithoutLiquidityPoolInput, VCreditDefinitionUncheckedUpdateWithoutLiquidityPoolInput>
    create: XOR<VCreditDefinitionCreateWithoutLiquidityPoolInput, VCreditDefinitionUncheckedCreateWithoutLiquidityPoolInput>
    where?: VCreditDefinitionWhereInput
  }

  export type VCreditDefinitionUpdateToOneWithWhereWithoutLiquidityPoolInput = {
    where?: VCreditDefinitionWhereInput
    data: XOR<VCreditDefinitionUpdateWithoutLiquidityPoolInput, VCreditDefinitionUncheckedUpdateWithoutLiquidityPoolInput>
  }

  export type VCreditDefinitionUpdateWithoutLiquidityPoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IssuerUpdateOneRequiredWithoutCreditDefsNestedInput
    balances?: BalanceUpdateManyWithoutCreditDefNestedInput
    policies?: PolicyUpdateManyWithoutCreditDefNestedInput
  }

  export type VCreditDefinitionUncheckedUpdateWithoutLiquidityPoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutCreditDefNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutCreditDefNestedInput
  }

  export type UserCreateWithoutWalletsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer?: IssuerCreateNestedOneWithoutUsersInput
    merchant?: MerchantCreateNestedOneWithoutUsersInput
    attestations?: ComplianceAttestationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWalletsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    issuerId?: string | null
    merchantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attestations?: ComplianceAttestationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWalletsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
  }

  export type BalanceCreateWithoutWalletInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    creditDef: VCreditDefinitionCreateNestedOneWithoutBalancesInput
  }

  export type BalanceUncheckedCreateWithoutWalletInput = {
    id?: string
    creditDefId: string
    amount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type BalanceCreateOrConnectWithoutWalletInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutWalletInput, BalanceUncheckedCreateWithoutWalletInput>
  }

  export type BalanceCreateManyWalletInputEnvelope = {
    data: BalanceCreateManyWalletInput | BalanceCreateManyWalletInput[]
  }

  export type TransactionCreateWithoutSenderWalletInput = {
    id?: string
    referenceRef?: string | null
    type: string
    status?: string
    recipientWalletId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    finalizedAt?: Date | string | null
    policyLog?: PolicyEvaluationLogCreateNestedOneWithoutTransactionsInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutSenderWalletInput = {
    id?: string
    referenceRef?: string | null
    type: string
    status?: string
    recipientWalletId?: string | null
    metadata?: string | null
    policyLogId?: string | null
    createdAt?: Date | string
    finalizedAt?: Date | string | null
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutSenderWalletInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutSenderWalletInput, TransactionUncheckedCreateWithoutSenderWalletInput>
  }

  export type TransactionCreateManySenderWalletInputEnvelope = {
    data: TransactionCreateManySenderWalletInput | TransactionCreateManySenderWalletInput[]
  }

  export type UserUpsertWithoutWalletsInput = {
    update: XOR<UserUpdateWithoutWalletsInput, UserUncheckedUpdateWithoutWalletsInput>
    create: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletsInput, UserUncheckedUpdateWithoutWalletsInput>
  }

  export type UserUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IssuerUpdateOneWithoutUsersNestedInput
    merchant?: MerchantUpdateOneWithoutUsersNestedInput
    attestations?: ComplianceAttestationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuerId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attestations?: ComplianceAttestationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BalanceUpsertWithWhereUniqueWithoutWalletInput = {
    where: BalanceWhereUniqueInput
    update: XOR<BalanceUpdateWithoutWalletInput, BalanceUncheckedUpdateWithoutWalletInput>
    create: XOR<BalanceCreateWithoutWalletInput, BalanceUncheckedCreateWithoutWalletInput>
  }

  export type BalanceUpdateWithWhereUniqueWithoutWalletInput = {
    where: BalanceWhereUniqueInput
    data: XOR<BalanceUpdateWithoutWalletInput, BalanceUncheckedUpdateWithoutWalletInput>
  }

  export type BalanceUpdateManyWithWhereWithoutWalletInput = {
    where: BalanceScalarWhereInput
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyWithoutWalletInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutSenderWalletInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutSenderWalletInput, TransactionUncheckedUpdateWithoutSenderWalletInput>
    create: XOR<TransactionCreateWithoutSenderWalletInput, TransactionUncheckedCreateWithoutSenderWalletInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutSenderWalletInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutSenderWalletInput, TransactionUncheckedUpdateWithoutSenderWalletInput>
  }

  export type TransactionUpdateManyWithWhereWithoutSenderWalletInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutSenderWalletInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    referenceRef?: StringNullableFilter<"Transaction"> | string | null
    type?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    senderWalletId?: StringNullableFilter<"Transaction"> | string | null
    recipientWalletId?: StringNullableFilter<"Transaction"> | string | null
    metadata?: StringNullableFilter<"Transaction"> | string | null
    policyLogId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    finalizedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
  }

  export type WalletCreateWithoutBalancesInput = {
    id?: string
    type?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWalletsInput
    transactions?: TransactionCreateNestedManyWithoutSenderWalletInput
  }

  export type WalletUncheckedCreateWithoutBalancesInput = {
    id?: string
    userId?: string | null
    type?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutSenderWalletInput
  }

  export type WalletCreateOrConnectWithoutBalancesInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutBalancesInput, WalletUncheckedCreateWithoutBalancesInput>
  }

  export type VCreditDefinitionCreateWithoutBalancesInput = {
    id?: string
    name: string
    symbol: string
    decimals?: number
    type: string
    exchangeRateBaseUSD?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: IssuerCreateNestedOneWithoutCreditDefsInput
    policies?: PolicyCreateNestedManyWithoutCreditDefInput
    liquidityPool?: LiquidityPoolCreateNestedOneWithoutCreditDefInput
  }

  export type VCreditDefinitionUncheckedCreateWithoutBalancesInput = {
    id?: string
    issuerId: string
    name: string
    symbol: string
    decimals?: number
    type: string
    exchangeRateBaseUSD?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    policies?: PolicyUncheckedCreateNestedManyWithoutCreditDefInput
    liquidityPool?: LiquidityPoolUncheckedCreateNestedOneWithoutCreditDefInput
  }

  export type VCreditDefinitionCreateOrConnectWithoutBalancesInput = {
    where: VCreditDefinitionWhereUniqueInput
    create: XOR<VCreditDefinitionCreateWithoutBalancesInput, VCreditDefinitionUncheckedCreateWithoutBalancesInput>
  }

  export type WalletUpsertWithoutBalancesInput = {
    update: XOR<WalletUpdateWithoutBalancesInput, WalletUncheckedUpdateWithoutBalancesInput>
    create: XOR<WalletCreateWithoutBalancesInput, WalletUncheckedCreateWithoutBalancesInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutBalancesInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutBalancesInput, WalletUncheckedUpdateWithoutBalancesInput>
  }

  export type WalletUpdateWithoutBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWalletsNestedInput
    transactions?: TransactionUpdateManyWithoutSenderWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutSenderWalletNestedInput
  }

  export type VCreditDefinitionUpsertWithoutBalancesInput = {
    update: XOR<VCreditDefinitionUpdateWithoutBalancesInput, VCreditDefinitionUncheckedUpdateWithoutBalancesInput>
    create: XOR<VCreditDefinitionCreateWithoutBalancesInput, VCreditDefinitionUncheckedCreateWithoutBalancesInput>
    where?: VCreditDefinitionWhereInput
  }

  export type VCreditDefinitionUpdateToOneWithWhereWithoutBalancesInput = {
    where?: VCreditDefinitionWhereInput
    data: XOR<VCreditDefinitionUpdateWithoutBalancesInput, VCreditDefinitionUncheckedUpdateWithoutBalancesInput>
  }

  export type VCreditDefinitionUpdateWithoutBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IssuerUpdateOneRequiredWithoutCreditDefsNestedInput
    policies?: PolicyUpdateManyWithoutCreditDefNestedInput
    liquidityPool?: LiquidityPoolUpdateOneWithoutCreditDefNestedInput
  }

  export type VCreditDefinitionUncheckedUpdateWithoutBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policies?: PolicyUncheckedUpdateManyWithoutCreditDefNestedInput
    liquidityPool?: LiquidityPoolUncheckedUpdateOneWithoutCreditDefNestedInput
  }

  export type WalletCreateWithoutTransactionsInput = {
    id?: string
    type?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWalletsInput
    balances?: BalanceCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId?: string | null
    type?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutTransactionsInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
  }

  export type PolicyEvaluationLogCreateWithoutTransactionsInput = {
    id?: string
    transactionId?: string | null
    decision: string
    results: string
    createdAt?: Date | string
  }

  export type PolicyEvaluationLogUncheckedCreateWithoutTransactionsInput = {
    id?: string
    transactionId?: string | null
    decision: string
    results: string
    createdAt?: Date | string
  }

  export type PolicyEvaluationLogCreateOrConnectWithoutTransactionsInput = {
    where: PolicyEvaluationLogWhereUniqueInput
    create: XOR<PolicyEvaluationLogCreateWithoutTransactionsInput, PolicyEvaluationLogUncheckedCreateWithoutTransactionsInput>
  }

  export type LedgerEntryCreateWithoutTransactionInput = {
    id?: string
    walletId: string
    creditDefId: string
    direction: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LedgerEntryUncheckedCreateWithoutTransactionInput = {
    id?: string
    walletId: string
    creditDefId: string
    direction: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutTransactionInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput>
  }

  export type LedgerEntryCreateManyTransactionInputEnvelope = {
    data: LedgerEntryCreateManyTransactionInput | LedgerEntryCreateManyTransactionInput[]
  }

  export type WalletUpsertWithoutTransactionsInput = {
    update: XOR<WalletUpdateWithoutTransactionsInput, WalletUncheckedUpdateWithoutTransactionsInput>
    create: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutTransactionsInput, WalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type WalletUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWalletsNestedInput
    balances?: BalanceUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type PolicyEvaluationLogUpsertWithoutTransactionsInput = {
    update: XOR<PolicyEvaluationLogUpdateWithoutTransactionsInput, PolicyEvaluationLogUncheckedUpdateWithoutTransactionsInput>
    create: XOR<PolicyEvaluationLogCreateWithoutTransactionsInput, PolicyEvaluationLogUncheckedCreateWithoutTransactionsInput>
    where?: PolicyEvaluationLogWhereInput
  }

  export type PolicyEvaluationLogUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: PolicyEvaluationLogWhereInput
    data: XOR<PolicyEvaluationLogUpdateWithoutTransactionsInput, PolicyEvaluationLogUncheckedUpdateWithoutTransactionsInput>
  }

  export type PolicyEvaluationLogUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: StringFieldUpdateOperationsInput | string
    results?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyEvaluationLogUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    decision?: StringFieldUpdateOperationsInput | string
    results?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutTransactionInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutTransactionInput, LedgerEntryUncheckedUpdateWithoutTransactionInput>
    create: XOR<LedgerEntryCreateWithoutTransactionInput, LedgerEntryUncheckedCreateWithoutTransactionInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutTransactionInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutTransactionInput, LedgerEntryUncheckedUpdateWithoutTransactionInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutTransactionInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutTransactionInput>
  }

  export type LedgerEntryScalarWhereInput = {
    AND?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    OR?: LedgerEntryScalarWhereInput[]
    NOT?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    id?: StringFilter<"LedgerEntry"> | string
    transactionId?: StringFilter<"LedgerEntry"> | string
    walletId?: StringFilter<"LedgerEntry"> | string
    creditDefId?: StringFilter<"LedgerEntry"> | string
    direction?: StringFilter<"LedgerEntry"> | string
    amount?: DecimalFilter<"LedgerEntry"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFilter<"LedgerEntry"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
  }

  export type TransactionCreateWithoutLedgerEntriesInput = {
    id?: string
    referenceRef?: string | null
    type: string
    status?: string
    recipientWalletId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    finalizedAt?: Date | string | null
    senderWallet?: WalletCreateNestedOneWithoutTransactionsInput
    policyLog?: PolicyEvaluationLogCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutLedgerEntriesInput = {
    id?: string
    referenceRef?: string | null
    type: string
    status?: string
    senderWalletId?: string | null
    recipientWalletId?: string | null
    metadata?: string | null
    policyLogId?: string | null
    createdAt?: Date | string
    finalizedAt?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutLedgerEntriesInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutLedgerEntriesInput, TransactionUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type TransactionUpsertWithoutLedgerEntriesInput = {
    update: XOR<TransactionUpdateWithoutLedgerEntriesInput, TransactionUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<TransactionCreateWithoutLedgerEntriesInput, TransactionUncheckedCreateWithoutLedgerEntriesInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutLedgerEntriesInput, TransactionUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type TransactionUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipientWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderWallet?: WalletUpdateOneWithoutTransactionsNestedInput
    policyLog?: PolicyEvaluationLogUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    senderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    policyLogId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IssuerCreateWithoutPoliciesInput = {
    id?: string
    name: string
    slug: string
    apiKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutIssuerInput
    creditDefs?: VCreditDefinitionCreateNestedManyWithoutIssuerInput
  }

  export type IssuerUncheckedCreateWithoutPoliciesInput = {
    id?: string
    name: string
    slug: string
    apiKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutIssuerInput
    creditDefs?: VCreditDefinitionUncheckedCreateNestedManyWithoutIssuerInput
  }

  export type IssuerCreateOrConnectWithoutPoliciesInput = {
    where: IssuerWhereUniqueInput
    create: XOR<IssuerCreateWithoutPoliciesInput, IssuerUncheckedCreateWithoutPoliciesInput>
  }

  export type VCreditDefinitionCreateWithoutPoliciesInput = {
    id?: string
    name: string
    symbol: string
    decimals?: number
    type: string
    exchangeRateBaseUSD?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer: IssuerCreateNestedOneWithoutCreditDefsInput
    balances?: BalanceCreateNestedManyWithoutCreditDefInput
    liquidityPool?: LiquidityPoolCreateNestedOneWithoutCreditDefInput
  }

  export type VCreditDefinitionUncheckedCreateWithoutPoliciesInput = {
    id?: string
    issuerId: string
    name: string
    symbol: string
    decimals?: number
    type: string
    exchangeRateBaseUSD?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    balances?: BalanceUncheckedCreateNestedManyWithoutCreditDefInput
    liquidityPool?: LiquidityPoolUncheckedCreateNestedOneWithoutCreditDefInput
  }

  export type VCreditDefinitionCreateOrConnectWithoutPoliciesInput = {
    where: VCreditDefinitionWhereUniqueInput
    create: XOR<VCreditDefinitionCreateWithoutPoliciesInput, VCreditDefinitionUncheckedCreateWithoutPoliciesInput>
  }

  export type IssuerUpsertWithoutPoliciesInput = {
    update: XOR<IssuerUpdateWithoutPoliciesInput, IssuerUncheckedUpdateWithoutPoliciesInput>
    create: XOR<IssuerCreateWithoutPoliciesInput, IssuerUncheckedCreateWithoutPoliciesInput>
    where?: IssuerWhereInput
  }

  export type IssuerUpdateToOneWithWhereWithoutPoliciesInput = {
    where?: IssuerWhereInput
    data: XOR<IssuerUpdateWithoutPoliciesInput, IssuerUncheckedUpdateWithoutPoliciesInput>
  }

  export type IssuerUpdateWithoutPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutIssuerNestedInput
    creditDefs?: VCreditDefinitionUpdateManyWithoutIssuerNestedInput
  }

  export type IssuerUncheckedUpdateWithoutPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutIssuerNestedInput
    creditDefs?: VCreditDefinitionUncheckedUpdateManyWithoutIssuerNestedInput
  }

  export type VCreditDefinitionUpsertWithoutPoliciesInput = {
    update: XOR<VCreditDefinitionUpdateWithoutPoliciesInput, VCreditDefinitionUncheckedUpdateWithoutPoliciesInput>
    create: XOR<VCreditDefinitionCreateWithoutPoliciesInput, VCreditDefinitionUncheckedCreateWithoutPoliciesInput>
    where?: VCreditDefinitionWhereInput
  }

  export type VCreditDefinitionUpdateToOneWithWhereWithoutPoliciesInput = {
    where?: VCreditDefinitionWhereInput
    data: XOR<VCreditDefinitionUpdateWithoutPoliciesInput, VCreditDefinitionUncheckedUpdateWithoutPoliciesInput>
  }

  export type VCreditDefinitionUpdateWithoutPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IssuerUpdateOneRequiredWithoutCreditDefsNestedInput
    balances?: BalanceUpdateManyWithoutCreditDefNestedInput
    liquidityPool?: LiquidityPoolUpdateOneWithoutCreditDefNestedInput
  }

  export type VCreditDefinitionUncheckedUpdateWithoutPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutCreditDefNestedInput
    liquidityPool?: LiquidityPoolUncheckedUpdateOneWithoutCreditDefNestedInput
  }

  export type TransactionCreateWithoutPolicyLogInput = {
    id?: string
    referenceRef?: string | null
    type: string
    status?: string
    recipientWalletId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    finalizedAt?: Date | string | null
    senderWallet?: WalletCreateNestedOneWithoutTransactionsInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPolicyLogInput = {
    id?: string
    referenceRef?: string | null
    type: string
    status?: string
    senderWalletId?: string | null
    recipientWalletId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    finalizedAt?: Date | string | null
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPolicyLogInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPolicyLogInput, TransactionUncheckedCreateWithoutPolicyLogInput>
  }

  export type TransactionCreateManyPolicyLogInputEnvelope = {
    data: TransactionCreateManyPolicyLogInput | TransactionCreateManyPolicyLogInput[]
  }

  export type TransactionUpsertWithWhereUniqueWithoutPolicyLogInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutPolicyLogInput, TransactionUncheckedUpdateWithoutPolicyLogInput>
    create: XOR<TransactionCreateWithoutPolicyLogInput, TransactionUncheckedCreateWithoutPolicyLogInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutPolicyLogInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutPolicyLogInput, TransactionUncheckedUpdateWithoutPolicyLogInput>
  }

  export type TransactionUpdateManyWithWhereWithoutPolicyLogInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutPolicyLogInput>
  }

  export type UserCreateWithoutAttestationsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    issuer?: IssuerCreateNestedOneWithoutUsersInput
    merchant?: MerchantCreateNestedOneWithoutUsersInput
    wallets?: WalletCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttestationsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    issuerId?: string | null
    merchantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttestationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttestationsInput, UserUncheckedCreateWithoutAttestationsInput>
  }

  export type UserUpsertWithoutAttestationsInput = {
    update: XOR<UserUpdateWithoutAttestationsInput, UserUncheckedUpdateWithoutAttestationsInput>
    create: XOR<UserCreateWithoutAttestationsInput, UserUncheckedCreateWithoutAttestationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttestationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttestationsInput, UserUncheckedUpdateWithoutAttestationsInput>
  }

  export type UserUpdateWithoutAttestationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IssuerUpdateOneWithoutUsersNestedInput
    merchant?: MerchantUpdateOneWithoutUsersNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttestationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuerId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WalletCreateManyUserInput = {
    id?: string
    type?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceAttestationCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    status: string
    validUntil?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUpdateManyWithoutWalletNestedInput
    transactions?: TransactionUpdateManyWithoutSenderWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutWalletNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSenderWalletNestedInput
  }

  export type WalletUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceAttestationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceAttestationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceAttestationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyIssuerInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    merchantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VCreditDefinitionCreateManyIssuerInput = {
    id?: string
    name: string
    symbol: string
    decimals?: number
    type: string
    exchangeRateBaseUSD?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyCreateManyIssuerInput = {
    id?: string
    creditDefId?: string | null
    name: string
    description?: string | null
    ruleType: string
    parameters: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant?: MerchantUpdateOneWithoutUsersNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    attestations?: ComplianceAttestationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    attestations?: ComplianceAttestationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VCreditDefinitionUpdateWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUpdateManyWithoutCreditDefNestedInput
    policies?: PolicyUpdateManyWithoutCreditDefNestedInput
    liquidityPool?: LiquidityPoolUpdateOneWithoutCreditDefNestedInput
  }

  export type VCreditDefinitionUncheckedUpdateWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balances?: BalanceUncheckedUpdateManyWithoutCreditDefNestedInput
    policies?: PolicyUncheckedUpdateManyWithoutCreditDefNestedInput
    liquidityPool?: LiquidityPoolUncheckedUpdateOneWithoutCreditDefNestedInput
  }

  export type VCreditDefinitionUncheckedUpdateManyWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    exchangeRateBaseUSD?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUpdateWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditDef?: VCreditDefinitionUpdateOneWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditDefId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateManyWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditDefId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyMerchantInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    role?: string
    status?: string
    issuerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MerchantTerminalCreateManyMerchantInput = {
    id?: string
    location: string
    secretKey: string
    createdAt?: Date | string
  }

  export type UserUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IssuerUpdateOneWithoutUsersNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    attestations?: ComplianceAttestationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    attestations?: ComplianceAttestationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantTerminalUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantTerminalUncheckedUpdateWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MerchantTerminalUncheckedUpdateManyWithoutMerchantInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    secretKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceCreateManyCreditDefInput = {
    id?: string
    walletId: string
    amount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type PolicyCreateManyCreditDefInput = {
    id?: string
    issuerId?: string | null
    name: string
    description?: string | null
    ruleType: string
    parameters: string
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceUpdateWithoutCreditDefInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type BalanceUncheckedUpdateWithoutCreditDefInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUncheckedUpdateManyWithoutCreditDefInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUpdateWithoutCreditDefInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: IssuerUpdateOneWithoutPoliciesNestedInput
  }

  export type PolicyUncheckedUpdateWithoutCreditDefInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateManyWithoutCreditDefInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ruleType?: StringFieldUpdateOperationsInput | string
    parameters?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceCreateManyWalletInput = {
    id?: string
    creditDefId: string
    amount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManySenderWalletInput = {
    id?: string
    referenceRef?: string | null
    type: string
    status?: string
    recipientWalletId?: string | null
    metadata?: string | null
    policyLogId?: string | null
    createdAt?: Date | string
    finalizedAt?: Date | string | null
  }

  export type BalanceUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditDef?: VCreditDefinitionUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type BalanceUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUncheckedUpdateManyWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutSenderWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipientWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policyLog?: PolicyEvaluationLogUpdateOneWithoutTransactionsNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutSenderWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipientWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    policyLogId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutSenderWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipientWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    policyLogId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LedgerEntryCreateManyTransactionInput = {
    id?: string
    walletId: string
    creditDefId: string
    direction: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    creditDefId?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyPolicyLogInput = {
    id?: string
    referenceRef?: string | null
    type: string
    status?: string
    senderWalletId?: string | null
    recipientWalletId?: string | null
    metadata?: string | null
    createdAt?: Date | string
    finalizedAt?: Date | string | null
  }

  export type TransactionUpdateWithoutPolicyLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    recipientWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderWallet?: WalletUpdateOneWithoutTransactionsNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPolicyLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    senderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutPolicyLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceRef?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    senderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}